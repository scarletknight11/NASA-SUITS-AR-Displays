#if UNITY_EDITOR || UNITY_STANDALONE || UNITY_WSA || UNITY_ANDROID
// Making calls from the Unity editor is not currently supported.
// These stubs are here to prevent the editor from reporting compilation errors.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// RemoteRenderingClient
// This file was auto-generated from AzureRemoteRenderingApiModel.cs.
//

// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Microsoft.Azure.RemoteRendering
{
    internal enum status
    {
        /// <summary>
        /// Success
        /// </summary>
        OK = 0,
        /// <summary>
        /// Failed
        /// </summary>
        Failed = 1,
        /// <summary>
        /// Cannot access a disposed object.
        /// </summary>
        ObjectDisposed = 2,
        /// <summary>
        /// Out of memory.
        /// </summary>
        OutOfMemory = 12,
        /// <summary>
        /// Invalid argument.
        /// </summary>
        InvalidArgument = 22,
        /// <summary>
        /// The value is out of range.
        /// </summary>
        OutOfRange = 34,
        /// <summary>
        /// Not implemented.
        /// </summary>
        NotImplemented = 38,
        /// <summary>
        /// The key does not exist in the collection.
        /// </summary>
        KeyNotFound = 77,
        /// <summary>
        /// Internal: Start of the range of core result values.
        /// </summary>
        CoreReturnValueStart = 78,
        /// <summary>
        /// Operation completed successfully.
        /// </summary>
        //Success = 79,
        /// <summary>
        /// General failure.
        /// </summary>
        Fail = 80,
        /// <summary>
        /// The user canceled the operation.
        /// </summary>
        Cancelled = 81,
        /// <summary>
        /// Incorrect user input for the operation.
        /// </summary>
        InvalidParam = 82,
        /// <summary>
        /// An object with incorrect type was passed in.
        /// </summary>
        InvalidType = 83,
        /// <summary>
        /// Not used.
        /// </summary>
        BufferTooSmall_Deprecated = 84,
        /// <summary>
        /// Operation requires an active connection.
        /// </summary>
        /// <remarks>
        /// If the connection to the server has been lost, this error can occur for most operations,
        /// since only few operations are possible without a connection.
        /// </remarks>
        NoConnection = 85,
        /// <summary>
        /// Internal.
        /// </summary>
        ApiUnavailable = 86,
        /// <summary>
        /// Static initialization of remote rendering has been called multiple times.
        /// </summary>
        AlreadyInitialized = 87,
        /// <summary>
        /// Static de-initialization of remote rendering has already been performed.
        /// </summary>
        AlreadyDeinitialized = 88,
        /// <summary>
        /// The string passed into the API is longer than allowed.
        /// </summary>
        StringTooLong = 89,
        /// <summary>
        /// The index passed into the API is outside the valid range.
        /// </summary>
        IndexOutOfRange = 90,
        /// <summary>
        /// An async operation has not yet finished.
        /// </summary>
        InProgress = 91,
        /// <summary>
        /// Static initialization of remote rendering hasn't been done yet.
        /// </summary>
        NotInitialized = 92,
        /// <summary>
        /// The string passed into the API is not valid.
        /// </summary>
        StringNotValidUtf8 = 93,
        /// <summary>
        /// An operation is not supported on the target platform.
        /// </summary>
        NotSupported = 94,
        /// <summary>
        /// Internal: Last used value of the range of core result values.
        /// </summary>
        CoreReturnValueLast = 95,
        /// <summary>
        /// Internal: Maximum value of the range of core result values.
        /// </summary>
        CoreReturnValueEnd = 96,
        /// <summary>
        /// Internal: Start of the range of file load result values.
        /// </summary>
        LoadFileReturnValueStart = 97,
        /// <summary>
        /// The requested file did not exist.
        /// </summary>
        FileNotFound = 98,
        /// <summary>
        /// The requested file is either corrupt or uses an old version that is not supported anymore.
        /// </summary>
        InvalidVersion = 99,
        /// <summary>
        /// Not used.
        /// </summary>
        IncompatibleVersion_Deprecated = 100,
        /// <summary>
        /// The requested file is either corrupt or not recognized.
        /// </summary>
        FailedToOpenFile = 101,
        /// <summary>
        /// Downloading the file from the provided URI failed.
        /// </summary>
        FileDownloadFailed = 102,
        /// <summary>
        /// Loading this model would exceed GPU memory limits. Request a larger server, or reduce the amount of loaded models.
        /// </summary>
        ExceedsMemoryLimit = 103,
        /// <summary>
        /// The target file cannot be written
        /// </summary>
        CannotWriteTargetFile = 104,
        /// <summary>
        /// The target file is corrupt or in an unsupported format
        /// </summary>
        FileCorrupt = 105,
        /// <summary>
        /// Internal: Uploading the file to the provided URI failed.
        /// </summary>
        FileUploadFailed = 106,
        /// <summary>
        /// Internal: Files can only be up/downloaded from OneDrive or Azure Blob Storage.
        /// </summary>
        UnsupportedFileProvider = 107,
        /// <summary>
        /// Internal: Last used value of the range of file load result values.
        /// </summary>
        LoadFileReturnValueLast = 108,
        /// <summary>
        /// Internal: Maximum value of the range of file load result values.
        /// </summary>
        LoadFileReturnValueEnd = 109,
        /// <summary>
        /// Internal: Start of the range of object result values.
        /// </summary>
        ObjectReturnValueStart = 110,
        /// <summary>
        /// The provided object ID is not valid (anymore).
        /// </summary>
        InvalidId = 111,
        /// <summary>
        /// The parent entity with the provided ID does not exist.
        /// </summary>
        InvalidParentId = 112,
        /// <summary>
        /// An object of the same type already exists on the target.
        /// </summary>
        AlreadyExists = 113,
        /// <summary>
        /// Re-parenting this entity to the target entity would create a cycle in the entity hierarchy.
        /// </summary>
        CyclicReference = 114,
        /// <summary>
        /// Not used.
        /// </summary>
        ObjectLocked_Deprecated = 115,
        /// <summary>
        /// Tried to transform or re-parent an object that is part of a static scene graph. See 'SceneGraphMode=static' model conversion option.
        /// </summary>
        ObjectStatic = 116,
        /// <summary>
        /// Tried to add a component, but the maximum number of this component was already present.
        /// </summary>
        ComponentLimitReached = 117,
        /// <summary>
        /// Internal: Last used value of the range of object result values.
        /// </summary>
        ObjectReturnValueLast = 118,
        /// <summary>
        /// Internal: Maximum value of the range of object result values.
        /// </summary>
        ObjectReturnValueEnd = 119,
        /// <summary>
        /// Internal: Start of the range of connection result values.
        /// </summary>
        ConnectionReturnValueStart = 120,
        /// <summary>
        /// Internal: Secure connection enabled, but certificate was missing, invalid, or not usable.
        /// </summary>
        NoServerCertificate = 121,
        /// <summary>
        /// Internal: Handshake port could not be opened for accepting connections.
        /// </summary>
        HandshakePortBusy = 122,
        /// <summary>
        /// Handshake server is unreachable.
        /// </summary>
        HandshakeUnreachable = 123,
        /// <summary>
        /// Handshake server closed the connection prematurely; likely due to TLS/Plain mismatch or invalid certificate.
        /// </summary>
        HandshakeConnectionFailed = 124,
        /// <summary>
        /// Authentication with the handshake server failed.
        /// </summary>
        AuthenticationFailed = 125,
        /// <summary>
        /// No common compatible remoting version could be determined during handshake.
        /// </summary>
        RemotingVersionMismatch = 126,
        /// <summary>
        /// No common transport protocol could be determined during handshake.
        /// </summary>
        IncompatibleTransportProtocols = 127,
        /// <summary>
        /// Handshake failed. Reason not further specified.
        /// </summary>
        HandshakeFailed = 128,
        /// <summary>
        /// Internal: Transport port could not be opened for accepting connections.
        /// </summary>
        TransportPortBusy = 129,
        /// <summary>
        /// Transport server is unreachable.
        /// </summary>
        TransportUnreachable = 130,
        /// <summary>
        /// Transport connection was closed before all communication channels had been set up.
        /// </summary>
        TransportConnectionFailed = 131,
        /// <summary>
        /// Transport connection was closed due to protocol version mismatch.
        /// </summary>
        ProtocolVersionMismatch = 132,
        /// <summary>
        /// A protocol error occurred that was severe enough to invalidate the current connection or connection attempt.
        /// </summary>
        ProtocolError = 133,
        /// <summary>
        /// Transport connection was closed due to the requested video codec not being available.
        /// </summary>
        VideoCodecNotAvailable = 134,
        /// <summary>
        /// Connection has been closed by peer.
        /// </summary>
        ConnectionLost = 135,
        /// <summary>
        /// Connection has been closed due to graphics device loss.
        /// </summary>
        DeviceLost = 136,
        /// <summary>
        /// Connection has been closed by request.
        /// </summary>
        DisconnectRequest = 137,
        /// <summary>
        /// Internal.
        /// </summary>
        Timeout = 138,
        /// <summary>
        /// A connection has been established before.
        /// </summary>
        AlreadyConnected = 139,
        /// <summary>
        /// The client SDK version is not supported anymore. Please update.
        /// </summary>
        ArrVersionMismatch = 140,
        /// <summary>
        /// Network is unreachable. This usually means the client knows no route to reach the remote host.
        /// </summary>
        HandshakeNetworkUnreachable = 141,
        /// <summary>
        /// No connection could be made because the remote side actively refused it. Usually this means that no host application is running.
        /// </summary>
        HandshakeConnectionRefused = 142,
        /// <summary>
        /// Transport connection was closed due to the requested video format not being available.
        /// </summary>
        VideoFormatNotAvailable = 143,
        /// <summary>
        /// Disconnecting after receiving a disconnect request from the peer.
        /// </summary>
        PeerDisconnectRequest = 144,
        /// <summary>
        /// Timed out while waiting for peer to close connection.
        /// </summary>
        PeerDisconnectTimeout = 145,
        /// <summary>
        /// Timed out while waiting for transport session to be opened.
        /// </summary>
        SessionOpenTimeout = 146,
        /// <summary>
        /// Timed out while waiting for the remoting handshake to complete.
        /// </summary>
        RemotingHandshakeTimeout = 147,
        /// <summary>
        /// Connection failed due to an internal error.
        /// </summary>
        InternalError = 148,
        /// <summary>
        /// Internal: Last used value of the range of connection result values.
        /// </summary>
        ConnectionReturnValueLast = 149,
        /// <summary>
        /// Internal: Maximum value of the range of connection result values.
        /// </summary>
        ConnectionReturnValueEnd = 150,
        /// <summary>
        /// Internal: Start of the range of manager result values.
        /// </summary>
        ManagerReturnValueStart = 151,
        /// <summary>
        /// Internal: Invalid tool ID.
        /// </summary>
        InvalidToolId = 152,
        /// <summary>
        /// The remote rendering manager has already been created.
        /// </summary>
        ManagerAlreadyCreated = 153,
        /// <summary>
        /// The remote rendering manager has not been created yet.
        /// </summary>
        ManagerNotCreatedYet = 154,
        /// <summary>
        /// Another session is already connected to this runtime.
        /// </summary>
        OtherSessionConnected = 155,
        /// <summary>
        /// Internal.
        /// </summary>
        BadStateTransition = 156,
        /// <summary>
        /// An internal tool failed to start
        /// </summary>
        FailedToStartTool = 157,
        /// <summary>
        /// Internal: Insufficient number of slots in Frontend.
        /// </summary>
        InsufficientSlots = 158,
        /// <summary>
        /// PrepareRender has not been called before BlitRemoteFrame.
        /// </summary>
        PrepareRenderNotCalled = 159,
        /// <summary>
        /// Internal: Last used value of the range of manager result values.
        /// </summary>
        ManagerReturnValueLast = 160,
        /// <summary>
        /// Internal: Maximum value of the range of manager result values.
        /// </summary>
        ManagerReturnValueEnd = 161,
        /// <summary>
        /// Internal: Start of the range of session result values.
        /// </summary>
        SessionReturnValueStart = 162,
        /// <summary>
        /// The secure connection failed. Check the account settings.
        /// </summary>
        InvalidToken = 163,
        /// <summary>
        /// The user provided URI is malformed.
        /// </summary>
        InvalidUri = 164,
        /// <summary>
        /// The session to the user provided session Id could not be found.
        /// </summary>
        SessionNotFound = 165,
        /// <summary>
        /// Internal: The rate limit has been exceeded. Retry the request after the duration given in the Retry-After header.
        /// </summary>
        TooManyRequests = 166,
        /// <summary>
        /// Internal: Last used value of the range of session result values.
        /// </summary>
        SessionReturnValueLast = 167,
        /// <summary>
        /// Internal: Maximum value of the range of session result values.
        /// </summary>
        SessionReturnValueEnd = 168,
    }

    internal static class NativeLibraryHelpers
    {
        internal static string[] IntPtrToStringArray(IntPtr result, int result_length)
        {
            // an empty list is returned as a single null character
            if (result_length == 1)
            {
                return Array.Empty<string>();
            }

            byte[] bytes = new byte[result_length - 1];
            System.Runtime.InteropServices.Marshal.Copy(result, bytes, 0, result_length - 1);
            System.Runtime.InteropServices.Marshal.FreeCoTaskMem(result);
            return System.Text.Encoding.UTF8.GetString(bytes).Split('\0');
        }

        internal static void CheckStatus(status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string fullMessage = string.Empty;

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException("", fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
                case status.CoreReturnValueStart:
                    throw new RRException(Result.CoreReturnValueStart, fullMessage);
                //case status.Success:
                    //throw new RRException(Result.Success, fullMessage);
                case status.Fail:
                    throw new RRException(Result.Fail, fullMessage);
                case status.Cancelled:
                    throw new RRException(Result.Cancelled, fullMessage);
                case status.InvalidParam:
                    throw new RRException(Result.InvalidParam, fullMessage);
                case status.InvalidType:
                    throw new RRException(Result.InvalidType, fullMessage);
                case status.BufferTooSmall_Deprecated:
                    throw new RRException(Result.BufferTooSmall_Deprecated, fullMessage);
                case status.NoConnection:
                    throw new RRException(Result.NoConnection, fullMessage);
                case status.ApiUnavailable:
                    throw new RRException(Result.ApiUnavailable, fullMessage);
                case status.AlreadyInitialized:
                    throw new RRException(Result.AlreadyInitialized, fullMessage);
                case status.AlreadyDeinitialized:
                    throw new RRException(Result.AlreadyDeinitialized, fullMessage);
                case status.StringTooLong:
                    throw new RRException(Result.StringTooLong, fullMessage);
                case status.IndexOutOfRange:
                    throw new RRException(Result.IndexOutOfRange, fullMessage);
                case status.InProgress:
                    throw new RRException(Result.InProgress, fullMessage);
                case status.NotInitialized:
                    throw new RRException(Result.NotInitialized, fullMessage);
                case status.StringNotValidUtf8:
                    throw new RRException(Result.StringNotValidUtf8, fullMessage);
                case status.NotSupported:
                    throw new RRException(Result.NotSupported, fullMessage);
                case status.CoreReturnValueLast:
                    throw new RRException(Result.CoreReturnValueLast, fullMessage);
                case status.CoreReturnValueEnd:
                    throw new RRException(Result.CoreReturnValueEnd, fullMessage);
                case status.LoadFileReturnValueStart:
                    throw new RRException(Result.LoadFileReturnValueStart, fullMessage);
                case status.FileNotFound:
                    throw new RRException(Result.FileNotFound, fullMessage);
                case status.InvalidVersion:
                    throw new RRException(Result.InvalidVersion, fullMessage);
                case status.IncompatibleVersion_Deprecated:
                    throw new RRException(Result.IncompatibleVersion_Deprecated, fullMessage);
                case status.FailedToOpenFile:
                    throw new RRException(Result.FailedToOpenFile, fullMessage);
                case status.FileDownloadFailed:
                    throw new RRException(Result.FileDownloadFailed, fullMessage);
                case status.ExceedsMemoryLimit:
                    throw new RRException(Result.ExceedsMemoryLimit, fullMessage);
                case status.CannotWriteTargetFile:
                    throw new RRException(Result.CannotWriteTargetFile, fullMessage);
                case status.FileCorrupt:
                    throw new RRException(Result.FileCorrupt, fullMessage);
                case status.FileUploadFailed:
                    throw new RRException(Result.FileUploadFailed, fullMessage);
                case status.UnsupportedFileProvider:
                    throw new RRException(Result.UnsupportedFileProvider, fullMessage);
                case status.LoadFileReturnValueLast:
                    throw new RRException(Result.LoadFileReturnValueLast, fullMessage);
                case status.LoadFileReturnValueEnd:
                    throw new RRException(Result.LoadFileReturnValueEnd, fullMessage);
                case status.ObjectReturnValueStart:
                    throw new RRException(Result.ObjectReturnValueStart, fullMessage);
                case status.InvalidId:
                    throw new RRException(Result.InvalidId, fullMessage);
                case status.InvalidParentId:
                    throw new RRException(Result.InvalidParentId, fullMessage);
                case status.AlreadyExists:
                    throw new RRException(Result.AlreadyExists, fullMessage);
                case status.CyclicReference:
                    throw new RRException(Result.CyclicReference, fullMessage);
                case status.ObjectLocked_Deprecated:
                    throw new RRException(Result.ObjectLocked_Deprecated, fullMessage);
                case status.ObjectStatic:
                    throw new RRException(Result.ObjectStatic, fullMessage);
                case status.ComponentLimitReached:
                    throw new RRException(Result.ComponentLimitReached, fullMessage);
                case status.ObjectReturnValueLast:
                    throw new RRException(Result.ObjectReturnValueLast, fullMessage);
                case status.ObjectReturnValueEnd:
                    throw new RRException(Result.ObjectReturnValueEnd, fullMessage);
                case status.ConnectionReturnValueStart:
                    throw new RRException(Result.ConnectionReturnValueStart, fullMessage);
                case status.NoServerCertificate:
                    throw new RRException(Result.NoServerCertificate, fullMessage);
                case status.HandshakePortBusy:
                    throw new RRException(Result.HandshakePortBusy, fullMessage);
                case status.HandshakeUnreachable:
                    throw new RRException(Result.HandshakeUnreachable, fullMessage);
                case status.HandshakeConnectionFailed:
                    throw new RRException(Result.HandshakeConnectionFailed, fullMessage);
                case status.AuthenticationFailed:
                    throw new RRException(Result.AuthenticationFailed, fullMessage);
                case status.RemotingVersionMismatch:
                    throw new RRException(Result.RemotingVersionMismatch, fullMessage);
                case status.IncompatibleTransportProtocols:
                    throw new RRException(Result.IncompatibleTransportProtocols, fullMessage);
                case status.HandshakeFailed:
                    throw new RRException(Result.HandshakeFailed, fullMessage);
                case status.TransportPortBusy:
                    throw new RRException(Result.TransportPortBusy, fullMessage);
                case status.TransportUnreachable:
                    throw new RRException(Result.TransportUnreachable, fullMessage);
                case status.TransportConnectionFailed:
                    throw new RRException(Result.TransportConnectionFailed, fullMessage);
                case status.ProtocolVersionMismatch:
                    throw new RRException(Result.ProtocolVersionMismatch, fullMessage);
                case status.ProtocolError:
                    throw new RRException(Result.ProtocolError, fullMessage);
                case status.VideoCodecNotAvailable:
                    throw new RRException(Result.VideoCodecNotAvailable, fullMessage);
                case status.ConnectionLost:
                    throw new RRException(Result.ConnectionLost, fullMessage);
                case status.DeviceLost:
                    throw new RRException(Result.DeviceLost, fullMessage);
                case status.DisconnectRequest:
                    throw new RRException(Result.DisconnectRequest, fullMessage);
                case status.Timeout:
                    throw new RRException(Result.Timeout, fullMessage);
                case status.AlreadyConnected:
                    throw new RRException(Result.AlreadyConnected, fullMessage);
                case status.ArrVersionMismatch:
                    throw new RRException(Result.ArrVersionMismatch, fullMessage);
                case status.HandshakeNetworkUnreachable:
                    throw new RRException(Result.HandshakeNetworkUnreachable, fullMessage);
                case status.HandshakeConnectionRefused:
                    throw new RRException(Result.HandshakeConnectionRefused, fullMessage);
                case status.VideoFormatNotAvailable:
                    throw new RRException(Result.VideoFormatNotAvailable, fullMessage);
                case status.PeerDisconnectRequest:
                    throw new RRException(Result.PeerDisconnectRequest, fullMessage);
                case status.PeerDisconnectTimeout:
                    throw new RRException(Result.PeerDisconnectTimeout, fullMessage);
                case status.SessionOpenTimeout:
                    throw new RRException(Result.SessionOpenTimeout, fullMessage);
                case status.RemotingHandshakeTimeout:
                    throw new RRException(Result.RemotingHandshakeTimeout, fullMessage);
                case status.InternalError:
                    throw new RRException(Result.InternalError, fullMessage);
                case status.ConnectionReturnValueLast:
                    throw new RRException(Result.ConnectionReturnValueLast, fullMessage);
                case status.ConnectionReturnValueEnd:
                    throw new RRException(Result.ConnectionReturnValueEnd, fullMessage);
                case status.ManagerReturnValueStart:
                    throw new RRException(Result.ManagerReturnValueStart, fullMessage);
                case status.InvalidToolId:
                    throw new RRException(Result.InvalidToolId, fullMessage);
                case status.ManagerAlreadyCreated:
                    throw new RRException(Result.ManagerAlreadyCreated, fullMessage);
                case status.ManagerNotCreatedYet:
                    throw new RRException(Result.ManagerNotCreatedYet, fullMessage);
                case status.OtherSessionConnected:
                    throw new RRException(Result.OtherSessionConnected, fullMessage);
                case status.BadStateTransition:
                    throw new RRException(Result.BadStateTransition, fullMessage);
                case status.FailedToStartTool:
                    throw new RRException(Result.FailedToStartTool, fullMessage);
                case status.InsufficientSlots:
                    throw new RRException(Result.InsufficientSlots, fullMessage);
                case status.PrepareRenderNotCalled:
                    throw new RRException(Result.PrepareRenderNotCalled, fullMessage);
                case status.ManagerReturnValueLast:
                    throw new RRException(Result.ManagerReturnValueLast, fullMessage);
                case status.ManagerReturnValueEnd:
                    throw new RRException(Result.ManagerReturnValueEnd, fullMessage);
                case status.SessionReturnValueStart:
                    throw new RRException(Result.SessionReturnValueStart, fullMessage);
                case status.InvalidToken:
                    throw new RRException(Result.InvalidToken, fullMessage);
                case status.InvalidUri:
                    throw new RRException(Result.InvalidUri, fullMessage);
                case status.SessionNotFound:
                    throw new RRException(Result.SessionNotFound, fullMessage);
                case status.TooManyRequests:
                    throw new RRException(Result.TooManyRequests, fullMessage);
                case status.SessionReturnValueLast:
                    throw new RRException(Result.SessionReturnValueLast, fullMessage);
                case status.SessionReturnValueEnd:
                    throw new RRException(Result.SessionReturnValueEnd, fullMessage);
            }
        }

        internal static void CheckStatus(IntPtr handle, status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string message;
            string requestCorrelationVector;
            string responseCorrelationVector;

            Microsoft.Azure.RemoteRendering.status code = Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_error_details(handle, out message, out requestCorrelationVector, out responseCorrelationVector);

            string fullMessage;
            if (code == status.Failed)
            {
                throw new InvalidOperationException("Unexpected error in exception handling.");
            }
            else if (code != status.OK)
            {
                fullMessage = "Exception thrown and an unexpected error in exception handling.";
            }
            else
            {
                fullMessage = message + ".";
                if (!string.IsNullOrEmpty(requestCorrelationVector))
                {
                    fullMessage += " Request CV: " + requestCorrelationVector + ".";
                }
                if (!string.IsNullOrEmpty(responseCorrelationVector))
                {
                    fullMessage += " Response CV: " + responseCorrelationVector + ".";
                }
            }

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException("", fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
                case status.CoreReturnValueStart:
                    throw new RRException(Result.CoreReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                //case status.Success:
                    //throw new RRException(Result.Success, message, requestCorrelationVector, responseCorrelationVector);
                case status.Fail:
                    throw new RRException(Result.Fail, message, requestCorrelationVector, responseCorrelationVector);
                case status.Cancelled:
                    throw new RRException(Result.Cancelled, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidParam:
                    throw new RRException(Result.InvalidParam, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidType:
                    throw new RRException(Result.InvalidType, message, requestCorrelationVector, responseCorrelationVector);
                case status.BufferTooSmall_Deprecated:
                    throw new RRException(Result.BufferTooSmall_Deprecated, message, requestCorrelationVector, responseCorrelationVector);
                case status.NoConnection:
                    throw new RRException(Result.NoConnection, message, requestCorrelationVector, responseCorrelationVector);
                case status.ApiUnavailable:
                    throw new RRException(Result.ApiUnavailable, message, requestCorrelationVector, responseCorrelationVector);
                case status.AlreadyInitialized:
                    throw new RRException(Result.AlreadyInitialized, message, requestCorrelationVector, responseCorrelationVector);
                case status.AlreadyDeinitialized:
                    throw new RRException(Result.AlreadyDeinitialized, message, requestCorrelationVector, responseCorrelationVector);
                case status.StringTooLong:
                    throw new RRException(Result.StringTooLong, message, requestCorrelationVector, responseCorrelationVector);
                case status.IndexOutOfRange:
                    throw new RRException(Result.IndexOutOfRange, message, requestCorrelationVector, responseCorrelationVector);
                case status.InProgress:
                    throw new RRException(Result.InProgress, message, requestCorrelationVector, responseCorrelationVector);
                case status.NotInitialized:
                    throw new RRException(Result.NotInitialized, message, requestCorrelationVector, responseCorrelationVector);
                case status.StringNotValidUtf8:
                    throw new RRException(Result.StringNotValidUtf8, message, requestCorrelationVector, responseCorrelationVector);
                case status.NotSupported:
                    throw new RRException(Result.NotSupported, message, requestCorrelationVector, responseCorrelationVector);
                case status.CoreReturnValueLast:
                    throw new RRException(Result.CoreReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.CoreReturnValueEnd:
                    throw new RRException(Result.CoreReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.LoadFileReturnValueStart:
                    throw new RRException(Result.LoadFileReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.FileNotFound:
                    throw new RRException(Result.FileNotFound, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidVersion:
                    throw new RRException(Result.InvalidVersion, message, requestCorrelationVector, responseCorrelationVector);
                case status.IncompatibleVersion_Deprecated:
                    throw new RRException(Result.IncompatibleVersion_Deprecated, message, requestCorrelationVector, responseCorrelationVector);
                case status.FailedToOpenFile:
                    throw new RRException(Result.FailedToOpenFile, message, requestCorrelationVector, responseCorrelationVector);
                case status.FileDownloadFailed:
                    throw new RRException(Result.FileDownloadFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.ExceedsMemoryLimit:
                    throw new RRException(Result.ExceedsMemoryLimit, message, requestCorrelationVector, responseCorrelationVector);
                case status.CannotWriteTargetFile:
                    throw new RRException(Result.CannotWriteTargetFile, message, requestCorrelationVector, responseCorrelationVector);
                case status.FileCorrupt:
                    throw new RRException(Result.FileCorrupt, message, requestCorrelationVector, responseCorrelationVector);
                case status.FileUploadFailed:
                    throw new RRException(Result.FileUploadFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.UnsupportedFileProvider:
                    throw new RRException(Result.UnsupportedFileProvider, message, requestCorrelationVector, responseCorrelationVector);
                case status.LoadFileReturnValueLast:
                    throw new RRException(Result.LoadFileReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.LoadFileReturnValueEnd:
                    throw new RRException(Result.LoadFileReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectReturnValueStart:
                    throw new RRException(Result.ObjectReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidId:
                    throw new RRException(Result.InvalidId, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidParentId:
                    throw new RRException(Result.InvalidParentId, message, requestCorrelationVector, responseCorrelationVector);
                case status.AlreadyExists:
                    throw new RRException(Result.AlreadyExists, message, requestCorrelationVector, responseCorrelationVector);
                case status.CyclicReference:
                    throw new RRException(Result.CyclicReference, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectLocked_Deprecated:
                    throw new RRException(Result.ObjectLocked_Deprecated, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectStatic:
                    throw new RRException(Result.ObjectStatic, message, requestCorrelationVector, responseCorrelationVector);
                case status.ComponentLimitReached:
                    throw new RRException(Result.ComponentLimitReached, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectReturnValueLast:
                    throw new RRException(Result.ObjectReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.ObjectReturnValueEnd:
                    throw new RRException(Result.ObjectReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.ConnectionReturnValueStart:
                    throw new RRException(Result.ConnectionReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.NoServerCertificate:
                    throw new RRException(Result.NoServerCertificate, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakePortBusy:
                    throw new RRException(Result.HandshakePortBusy, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeUnreachable:
                    throw new RRException(Result.HandshakeUnreachable, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeConnectionFailed:
                    throw new RRException(Result.HandshakeConnectionFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.AuthenticationFailed:
                    throw new RRException(Result.AuthenticationFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.RemotingVersionMismatch:
                    throw new RRException(Result.RemotingVersionMismatch, message, requestCorrelationVector, responseCorrelationVector);
                case status.IncompatibleTransportProtocols:
                    throw new RRException(Result.IncompatibleTransportProtocols, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeFailed:
                    throw new RRException(Result.HandshakeFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.TransportPortBusy:
                    throw new RRException(Result.TransportPortBusy, message, requestCorrelationVector, responseCorrelationVector);
                case status.TransportUnreachable:
                    throw new RRException(Result.TransportUnreachable, message, requestCorrelationVector, responseCorrelationVector);
                case status.TransportConnectionFailed:
                    throw new RRException(Result.TransportConnectionFailed, message, requestCorrelationVector, responseCorrelationVector);
                case status.ProtocolVersionMismatch:
                    throw new RRException(Result.ProtocolVersionMismatch, message, requestCorrelationVector, responseCorrelationVector);
                case status.ProtocolError:
                    throw new RRException(Result.ProtocolError, message, requestCorrelationVector, responseCorrelationVector);
                case status.VideoCodecNotAvailable:
                    throw new RRException(Result.VideoCodecNotAvailable, message, requestCorrelationVector, responseCorrelationVector);
                case status.ConnectionLost:
                    throw new RRException(Result.ConnectionLost, message, requestCorrelationVector, responseCorrelationVector);
                case status.DeviceLost:
                    throw new RRException(Result.DeviceLost, message, requestCorrelationVector, responseCorrelationVector);
                case status.DisconnectRequest:
                    throw new RRException(Result.DisconnectRequest, message, requestCorrelationVector, responseCorrelationVector);
                case status.Timeout:
                    throw new RRException(Result.Timeout, message, requestCorrelationVector, responseCorrelationVector);
                case status.AlreadyConnected:
                    throw new RRException(Result.AlreadyConnected, message, requestCorrelationVector, responseCorrelationVector);
                case status.ArrVersionMismatch:
                    throw new RRException(Result.ArrVersionMismatch, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeNetworkUnreachable:
                    throw new RRException(Result.HandshakeNetworkUnreachable, message, requestCorrelationVector, responseCorrelationVector);
                case status.HandshakeConnectionRefused:
                    throw new RRException(Result.HandshakeConnectionRefused, message, requestCorrelationVector, responseCorrelationVector);
                case status.VideoFormatNotAvailable:
                    throw new RRException(Result.VideoFormatNotAvailable, message, requestCorrelationVector, responseCorrelationVector);
                case status.PeerDisconnectRequest:
                    throw new RRException(Result.PeerDisconnectRequest, message, requestCorrelationVector, responseCorrelationVector);
                case status.PeerDisconnectTimeout:
                    throw new RRException(Result.PeerDisconnectTimeout, message, requestCorrelationVector, responseCorrelationVector);
                case status.SessionOpenTimeout:
                    throw new RRException(Result.SessionOpenTimeout, message, requestCorrelationVector, responseCorrelationVector);
                case status.RemotingHandshakeTimeout:
                    throw new RRException(Result.RemotingHandshakeTimeout, message, requestCorrelationVector, responseCorrelationVector);
                case status.InternalError:
                    throw new RRException(Result.InternalError, message, requestCorrelationVector, responseCorrelationVector);
                case status.ConnectionReturnValueLast:
                    throw new RRException(Result.ConnectionReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.ConnectionReturnValueEnd:
                    throw new RRException(Result.ConnectionReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerReturnValueStart:
                    throw new RRException(Result.ManagerReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidToolId:
                    throw new RRException(Result.InvalidToolId, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerAlreadyCreated:
                    throw new RRException(Result.ManagerAlreadyCreated, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerNotCreatedYet:
                    throw new RRException(Result.ManagerNotCreatedYet, message, requestCorrelationVector, responseCorrelationVector);
                case status.OtherSessionConnected:
                    throw new RRException(Result.OtherSessionConnected, message, requestCorrelationVector, responseCorrelationVector);
                case status.BadStateTransition:
                    throw new RRException(Result.BadStateTransition, message, requestCorrelationVector, responseCorrelationVector);
                case status.FailedToStartTool:
                    throw new RRException(Result.FailedToStartTool, message, requestCorrelationVector, responseCorrelationVector);
                case status.InsufficientSlots:
                    throw new RRException(Result.InsufficientSlots, message, requestCorrelationVector, responseCorrelationVector);
                case status.PrepareRenderNotCalled:
                    throw new RRException(Result.PrepareRenderNotCalled, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerReturnValueLast:
                    throw new RRException(Result.ManagerReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.ManagerReturnValueEnd:
                    throw new RRException(Result.ManagerReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
                case status.SessionReturnValueStart:
                    throw new RRException(Result.SessionReturnValueStart, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidToken:
                    throw new RRException(Result.InvalidToken, message, requestCorrelationVector, responseCorrelationVector);
                case status.InvalidUri:
                    throw new RRException(Result.InvalidUri, message, requestCorrelationVector, responseCorrelationVector);
                case status.SessionNotFound:
                    throw new RRException(Result.SessionNotFound, message, requestCorrelationVector, responseCorrelationVector);
                case status.TooManyRequests:
                    throw new RRException(Result.TooManyRequests, message, requestCorrelationVector, responseCorrelationVector);
                case status.SessionReturnValueLast:
                    throw new RRException(Result.SessionReturnValueLast, message, requestCorrelationVector, responseCorrelationVector);
                case status.SessionReturnValueEnd:
                    throw new RRException(Result.SessionReturnValueEnd, message, requestCorrelationVector, responseCorrelationVector);
            }
        }

        internal static void CheckStatus(ulong handle, status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string fullMessage = string.Format("An error occurred: {0} ({0:d})", value);

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException("", fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
                case status.CoreReturnValueStart:
                    throw new RRException(Result.CoreReturnValueStart, fullMessage);
                //case status.Success:
                    //throw new RRException(Result.Success, fullMessage);
                case status.Fail:
                    throw new RRException(Result.Fail, fullMessage);
                case status.Cancelled:
                    throw new RRException(Result.Cancelled, fullMessage);
                case status.InvalidParam:
                    throw new RRException(Result.InvalidParam, fullMessage);
                case status.InvalidType:
                    throw new RRException(Result.InvalidType, fullMessage);
                case status.BufferTooSmall_Deprecated:
                    throw new RRException(Result.BufferTooSmall_Deprecated, fullMessage);
                case status.NoConnection:
                    throw new RRException(Result.NoConnection, fullMessage);
                case status.ApiUnavailable:
                    throw new RRException(Result.ApiUnavailable, fullMessage);
                case status.AlreadyInitialized:
                    throw new RRException(Result.AlreadyInitialized, fullMessage);
                case status.AlreadyDeinitialized:
                    throw new RRException(Result.AlreadyDeinitialized, fullMessage);
                case status.StringTooLong:
                    throw new RRException(Result.StringTooLong, fullMessage);
                case status.IndexOutOfRange:
                    throw new RRException(Result.IndexOutOfRange, fullMessage);
                case status.InProgress:
                    throw new RRException(Result.InProgress, fullMessage);
                case status.NotInitialized:
                    throw new RRException(Result.NotInitialized, fullMessage);
                case status.StringNotValidUtf8:
                    throw new RRException(Result.StringNotValidUtf8, fullMessage);
                case status.NotSupported:
                    throw new RRException(Result.NotSupported, fullMessage);
                case status.CoreReturnValueLast:
                    throw new RRException(Result.CoreReturnValueLast, fullMessage);
                case status.CoreReturnValueEnd:
                    throw new RRException(Result.CoreReturnValueEnd, fullMessage);
                case status.LoadFileReturnValueStart:
                    throw new RRException(Result.LoadFileReturnValueStart, fullMessage);
                case status.FileNotFound:
                    throw new RRException(Result.FileNotFound, fullMessage);
                case status.InvalidVersion:
                    throw new RRException(Result.InvalidVersion, fullMessage);
                case status.IncompatibleVersion_Deprecated:
                    throw new RRException(Result.IncompatibleVersion_Deprecated, fullMessage);
                case status.FailedToOpenFile:
                    throw new RRException(Result.FailedToOpenFile, fullMessage);
                case status.FileDownloadFailed:
                    throw new RRException(Result.FileDownloadFailed, fullMessage);
                case status.ExceedsMemoryLimit:
                    throw new RRException(Result.ExceedsMemoryLimit, fullMessage);
                case status.CannotWriteTargetFile:
                    throw new RRException(Result.CannotWriteTargetFile, fullMessage);
                case status.FileCorrupt:
                    throw new RRException(Result.FileCorrupt, fullMessage);
                case status.FileUploadFailed:
                    throw new RRException(Result.FileUploadFailed, fullMessage);
                case status.UnsupportedFileProvider:
                    throw new RRException(Result.UnsupportedFileProvider, fullMessage);
                case status.LoadFileReturnValueLast:
                    throw new RRException(Result.LoadFileReturnValueLast, fullMessage);
                case status.LoadFileReturnValueEnd:
                    throw new RRException(Result.LoadFileReturnValueEnd, fullMessage);
                case status.ObjectReturnValueStart:
                    throw new RRException(Result.ObjectReturnValueStart, fullMessage);
                case status.InvalidId:
                    throw new RRException(Result.InvalidId, fullMessage);
                case status.InvalidParentId:
                    throw new RRException(Result.InvalidParentId, fullMessage);
                case status.AlreadyExists:
                    throw new RRException(Result.AlreadyExists, fullMessage);
                case status.CyclicReference:
                    throw new RRException(Result.CyclicReference, fullMessage);
                case status.ObjectLocked_Deprecated:
                    throw new RRException(Result.ObjectLocked_Deprecated, fullMessage);
                case status.ObjectStatic:
                    throw new RRException(Result.ObjectStatic, fullMessage);
                case status.ComponentLimitReached:
                    throw new RRException(Result.ComponentLimitReached, fullMessage);
                case status.ObjectReturnValueLast:
                    throw new RRException(Result.ObjectReturnValueLast, fullMessage);
                case status.ObjectReturnValueEnd:
                    throw new RRException(Result.ObjectReturnValueEnd, fullMessage);
                case status.ConnectionReturnValueStart:
                    throw new RRException(Result.ConnectionReturnValueStart, fullMessage);
                case status.NoServerCertificate:
                    throw new RRException(Result.NoServerCertificate, fullMessage);
                case status.HandshakePortBusy:
                    throw new RRException(Result.HandshakePortBusy, fullMessage);
                case status.HandshakeUnreachable:
                    throw new RRException(Result.HandshakeUnreachable, fullMessage);
                case status.HandshakeConnectionFailed:
                    throw new RRException(Result.HandshakeConnectionFailed, fullMessage);
                case status.AuthenticationFailed:
                    throw new RRException(Result.AuthenticationFailed, fullMessage);
                case status.RemotingVersionMismatch:
                    throw new RRException(Result.RemotingVersionMismatch, fullMessage);
                case status.IncompatibleTransportProtocols:
                    throw new RRException(Result.IncompatibleTransportProtocols, fullMessage);
                case status.HandshakeFailed:
                    throw new RRException(Result.HandshakeFailed, fullMessage);
                case status.TransportPortBusy:
                    throw new RRException(Result.TransportPortBusy, fullMessage);
                case status.TransportUnreachable:
                    throw new RRException(Result.TransportUnreachable, fullMessage);
                case status.TransportConnectionFailed:
                    throw new RRException(Result.TransportConnectionFailed, fullMessage);
                case status.ProtocolVersionMismatch:
                    throw new RRException(Result.ProtocolVersionMismatch, fullMessage);
                case status.ProtocolError:
                    throw new RRException(Result.ProtocolError, fullMessage);
                case status.VideoCodecNotAvailable:
                    throw new RRException(Result.VideoCodecNotAvailable, fullMessage);
                case status.ConnectionLost:
                    throw new RRException(Result.ConnectionLost, fullMessage);
                case status.DeviceLost:
                    throw new RRException(Result.DeviceLost, fullMessage);
                case status.DisconnectRequest:
                    throw new RRException(Result.DisconnectRequest, fullMessage);
                case status.Timeout:
                    throw new RRException(Result.Timeout, fullMessage);
                case status.AlreadyConnected:
                    throw new RRException(Result.AlreadyConnected, fullMessage);
                case status.ArrVersionMismatch:
                    throw new RRException(Result.ArrVersionMismatch, fullMessage);
                case status.HandshakeNetworkUnreachable:
                    throw new RRException(Result.HandshakeNetworkUnreachable, fullMessage);
                case status.HandshakeConnectionRefused:
                    throw new RRException(Result.HandshakeConnectionRefused, fullMessage);
                case status.VideoFormatNotAvailable:
                    throw new RRException(Result.VideoFormatNotAvailable, fullMessage);
                case status.PeerDisconnectRequest:
                    throw new RRException(Result.PeerDisconnectRequest, fullMessage);
                case status.PeerDisconnectTimeout:
                    throw new RRException(Result.PeerDisconnectTimeout, fullMessage);
                case status.SessionOpenTimeout:
                    throw new RRException(Result.SessionOpenTimeout, fullMessage);
                case status.RemotingHandshakeTimeout:
                    throw new RRException(Result.RemotingHandshakeTimeout, fullMessage);
                case status.InternalError:
                    throw new RRException(Result.InternalError, fullMessage);
                case status.ConnectionReturnValueLast:
                    throw new RRException(Result.ConnectionReturnValueLast, fullMessage);
                case status.ConnectionReturnValueEnd:
                    throw new RRException(Result.ConnectionReturnValueEnd, fullMessage);
                case status.ManagerReturnValueStart:
                    throw new RRException(Result.ManagerReturnValueStart, fullMessage);
                case status.InvalidToolId:
                    throw new RRException(Result.InvalidToolId, fullMessage);
                case status.ManagerAlreadyCreated:
                    throw new RRException(Result.ManagerAlreadyCreated, fullMessage);
                case status.ManagerNotCreatedYet:
                    throw new RRException(Result.ManagerNotCreatedYet, fullMessage);
                case status.OtherSessionConnected:
                    throw new RRException(Result.OtherSessionConnected, fullMessage);
                case status.BadStateTransition:
                    throw new RRException(Result.BadStateTransition, fullMessage);
                case status.FailedToStartTool:
                    throw new RRException(Result.FailedToStartTool, fullMessage);
                case status.InsufficientSlots:
                    throw new RRException(Result.InsufficientSlots, fullMessage);
                case status.PrepareRenderNotCalled:
                    throw new RRException(Result.PrepareRenderNotCalled, fullMessage);
                case status.ManagerReturnValueLast:
                    throw new RRException(Result.ManagerReturnValueLast, fullMessage);
                case status.ManagerReturnValueEnd:
                    throw new RRException(Result.ManagerReturnValueEnd, fullMessage);
                case status.SessionReturnValueStart:
                    throw new RRException(Result.SessionReturnValueStart, fullMessage);
                case status.InvalidToken:
                    throw new RRException(Result.InvalidToken, fullMessage);
                case status.InvalidUri:
                    throw new RRException(Result.InvalidUri, fullMessage);
                case status.SessionNotFound:
                    throw new RRException(Result.SessionNotFound, fullMessage);
                case status.TooManyRequests:
                    throw new RRException(Result.TooManyRequests, fullMessage);
                case status.SessionReturnValueLast:
                    throw new RRException(Result.SessionReturnValueLast, fullMessage);
                case status.SessionReturnValueEnd:
                    throw new RRException(Result.SessionReturnValueEnd, fullMessage);
            }
        }
    }

    /// <summary>
    /// This interface is implemented by classes to be cached by the <see cref="ProjectedObjectCache"/>.
    /// </summary>
    internal interface ICachedObject
    {
        /// <summary>
        /// Unique cookie value for projected object identification.
        /// </summary>
        ulong Cookie { get; }
    }

    /// <summary>
    /// Represents a cache of event handlers for projected object events.
    /// </summary>
    internal static class ProjectedObjectEventHandlerCache
    {
        private readonly static IDictionary<ulong, IDictionary<string, Delegate>> tracked = new Dictionary<ulong, IDictionary<string, Delegate>>();

        /// <summary>
        /// Gets a value indicating whether the cache is empty.
        /// </summary>
        public static bool IsEmpty => tracked.Count == 0;

        /// <summary>
        /// Adds an event handler to the cache for the specified instance and event.
        /// The delegate is added to the multicast delegate.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The event handler.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void AddEventHandler<T>(ICachedObject instance, string eventName, T handler)
            where T : Delegate
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            if (string.IsNullOrWhiteSpace(eventName))
            {
                throw new ArgumentException("The argument is either null, empty, or whitespace.", nameof(eventName));
            }

            if (handler == null)
            {
                throw new ArgumentNullException(nameof(handler));
            }

            lock (tracked)
            {
                IDictionary<string, Delegate> eventDelegates = GetOrInitializeEvents(instance);

                if (!eventDelegates.TryGetValue(eventName, out Delegate existingHandler) || existingHandler == null)
                {
                    eventDelegates[eventName] = handler;
                    return;
                }

                eventDelegates[eventName] = Delegate.Combine(existingHandler, handler);
            }
        }

        /// <summary>
        /// Removes an event handler from the cache for the specified instance and event.
        /// The delegate is removed from the multicast delegate.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The handler.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void RemoveEventHandler<T>(ICachedObject instance, string eventName, T handler)
            where T : Delegate
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            if (string.IsNullOrWhiteSpace(eventName))
            {
                throw new ArgumentException("The argument is either null, empty, or whitespace.", nameof(eventName));
            }

            if (handler == null)
            {
                throw new ArgumentNullException(nameof(handler));
            }

            lock (tracked)
            {
                IDictionary<string, Delegate> eventDelegates = GetOrInitializeEvents(instance);

                if (!eventDelegates.TryGetValue(eventName, out Delegate existingHandler) || existingHandler == null)
                {
                    return;
                }

                eventDelegates[eventName] = Delegate.Remove(existingHandler, handler);
            }
        }

        /// <summary>
        /// Gets the event handler for the specified instance and event name.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="instance">The instance.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <returns><see cref="IReadOnlyCollection{T}"/>.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static T GetEventHandler<T>(ICachedObject instance, string eventName)
            where T : Delegate
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            if (string.IsNullOrWhiteSpace(eventName))
            {
                throw new ArgumentException("The argument is either null, empty, or whitespace.", nameof(eventName));
            }

            lock (tracked)
            {
                if (!tracked.TryGetValue(instance.Cookie, out IDictionary<string, Delegate> events))
                {
                    // No events have been cached for the object.
                    return null;
                }

                if (!events.TryGetValue(eventName, out Delegate eventDelegate))
                {
                    // The specified event has not been cached for the object.
                    return null;
                }

                return eventDelegate as T;
            }
        }

        /// <summary>
        /// Clears the cache of event handles for the specified instance.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public static void Clear(ICachedObject instance)
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            Clear(instance.Cookie);
        }

        /// <summary>
        /// Clears the cache of event handles for the specified instance cookie.
        /// </summary>
        /// <param name="cookie">The cookie.</param>
        /// <exception cref="ArgumentException"></exception>
        public static void Clear(ulong cookie)
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            lock (tracked)
            {
                tracked.Remove(cookie);
            }
        }

        private static IDictionary<string, Delegate> GetOrInitializeEvents(ICachedObject instance)
        {
            // We assume a lock on `tracked` is already held at this point, so no need to lock here.
            if (!tracked.TryGetValue(instance.Cookie, out IDictionary<string, Delegate> events))
            {
                // Setup event handler cache for the object.
                events = new Dictionary<string, Delegate>(StringComparer.Ordinal);
                tracked[instance.Cookie] = events;
            }

            return events;
        }
    }

    /// <summary>
    /// Represents a cache of projected object events.
    /// </summary>
    internal static class ProjectedObjectCache
    {
        private static readonly Dictionary<ulong, Dictionary<Type, System.WeakReference<ICachedObject>>> tracked = new Dictionary<ulong, Dictionary<Type, WeakReference<ICachedObject>>>();

        private static readonly Microsoft.Azure.RemoteRendering.ProjectedObjectCleanupNative projectedObjectCleanupHandlerDelegate = ProjectedObjectCleanupHandler;

        /// <summary>
        /// Gets a value indicating whether the cache is empty.
        /// </summary>
        public static bool IsEmpty => tracked.Count == 0;

        /// <summary>
        /// Initializes static members of the <see cref="ProjectedObjectCache"/> class.
        /// </summary>
        static ProjectedObjectCache()
        {
            NativeLibraryHelpers.CheckStatus(NativeLibrary.arr_set_projected_object_cleanup(projectedObjectCleanupHandlerDelegate));
        }

        /// <summary>
        /// Adds the specified instance to the cache.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void Add(ICachedObject instance)
        {
            if (instance is null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            lock (tracked)
            {
                if (!tracked.TryGetValue(instance.Cookie, out Dictionary<Type, WeakReference<ICachedObject>> cachedReference))
                {
                    tracked[instance.Cookie] = new Dictionary<Type, WeakReference<ICachedObject>>();
                    tracked[instance.Cookie][instance.GetType()] = new System.WeakReference<ICachedObject>(instance);
                    return;
                }

                // Ensure that we have a good reference.
                if (cachedReference.ContainsKey(instance.GetType()))
                {
                    if (!cachedReference[instance.GetType()].TryGetTarget(out _))
                    {
                        cachedReference[instance.GetType()].SetTarget(instance);
                    }
                }
            }
        }

        /// <summary>
        /// Gets a cached instance using the specified instance cookie.
        /// If a cached instance isn't found, a new instance is created using the <paramref name="createFactory"/>, which
        /// is then cahced and returned.
        /// </summary>
        /// <typeparam name="T">The type of the object to get or create.</typeparam>
        /// <param name="cookie">The cookie.</param>
        /// <param name="createFactory">The create factory.</param>
        /// <returns>A cached instance of type <typeparamref name="T"/>.</returns>
        /// <exception cref="ArgumentException"><paramref name="cookie"/> is not valid.</exception>
        public static T GetOrCreate<T>(ulong cookie, Func<ulong, T> createFactory)
            where T : class, ICachedObject
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            ICachedObject referenceTarget;

            lock (tracked)
            {
                if (!tracked.TryGetValue(cookie, out Dictionary<Type, System.WeakReference<ICachedObject>> reference))
                {
                    // Object is not being tracked.
                    return default;
                }

                if (!reference.ContainsKey(typeof(T)))
                {
                    tracked[cookie].Add(typeof(T), new WeakReference<ICachedObject>(null));
                }

                if (!reference[typeof(T)].TryGetTarget(out referenceTarget))
                {
                    // The reference is gone, so create a new one.
                    referenceTarget = createFactory(cookie);
                    tracked[cookie][typeof(T)].SetTarget(referenceTarget);
                }
            }

            return (T)referenceTarget;
        }

        /// <summary>
        /// Removes the specified instance from the cache.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public static void Remove(ICachedObject instance)
        {
            if (instance is null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            Remove(instance.Cookie, instance.GetType());
        }

        /// <summary>
        /// Removes the specified instance from the cache using the instance cookie.
        /// </summary>
        /// <param name="cookie">The cookie.</param>
        /// <exception cref="ArgumentException"></exception>
        public static void Remove(ulong cookie, Type type)
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            lock (tracked)
            {
                tracked[cookie].Remove(type);
            }
        }

        public static void Remove(ulong cookie)
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            lock (tracked)
            {
                tracked.Remove(cookie);
            }
        }

        [AOT.MonoPInvokeCallback(typeof(Microsoft.Azure.RemoteRendering.ProjectedObjectCleanupNative))]
        private static void ProjectedObjectCleanupHandler(ulong cookie)
        {
            Remove(cookie);
            ProjectedObjectEventHandlerCache.Clear(cookie);
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void DestructorHookDelegateNative(ulong cookie);

    /// <summary>
    /// Delegate for receiving log messages.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="level">
    /// Level of the log message.
    /// </param>
    /// <param name="message">
    /// Message as an IntPtr to the underlying UTF-8 char array.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingClient"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection"/>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void LogEventHandlerNative(ulong cookie, Microsoft.Azure.RemoteRendering.LogLevel level, System.IntPtr message);

    /// <summary>
    /// Delegate for receiving connection status updates.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="status">
    /// The new connection status.
    /// </param>
    /// <param name="error">
    /// Additional error information in case of an unintended disconnect.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession"/>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ConnectionStatusChangedEventHandlerNative(ulong cookie, Microsoft.Azure.RemoteRendering.ConnectionStatus status, Microsoft.Azure.RemoteRendering.Result error);

    /// <summary>
    /// Delegate for receiving notification when an update tick has completed on a <see cref="RenderingConnection"/>.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void RenderingConnectionUpdatedEventHandlerNative(ulong cookie);

    /// <summary>
    /// Informs the application that a remote rendering client requires an updated access token or authentication token.
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="args">
    /// The callback handle.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingClient.TokenRequired"/>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void TokenRequiredEventHandlerNative(ulong cookie, IntPtr args);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ProjectedObjectCleanupNative(ulong cookie);

    internal static partial class NativeLibrary
    {
        internal const string DllName = "RemoteRenderingClient";
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_asset_conversion_result_get_conversion_uuid(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_asset_conversion_status_result_get_error_message(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_asset_conversion_status_result_get_result(IntPtr handle, out Microsoft.Azure.RemoteRendering.ConversionSessionStatus result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_get_enable_depth(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_get_far_plane(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_get_inverse_depth(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_get_near_plane(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_set_enable_depth(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_set_inverse_depth(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_camera_settings_set_near_and_far_plane(ulong handle, float near_plane, float far_plane);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_albedo_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_albedo_texture(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_alpha_clip_threshold(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_color_flags(ulong handle, out Microsoft.Azure.RemoteRendering.ColorMaterialFeatures result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_color_transparency_mode(ulong handle, out Microsoft.Azure.RemoteRendering.ColorTransparencyMode result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_fade_out(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_fresnel_effect_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_fresnel_effect_exponent(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_tex_coord_offset(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_tex_coord_scale(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_get_vertex_mix(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_albedo_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_albedo_texture(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_alpha_clip_threshold(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_color_flags(ulong handle, Microsoft.Azure.RemoteRendering.ColorMaterialFeatures value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_color_transparency_mode(ulong handle, Microsoft.Azure.RemoteRendering.ColorTransparencyMode value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_fade_out(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_fresnel_effect_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_fresnel_effect_exponent(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_tex_coord_offset(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_tex_coord_scale(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_color_material_set_vertex_mix(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_destroy(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_get_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_get_owner(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_component_base_set_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_conversion_properties_array_result_get_conversions(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out Microsoft.Azure.RemoteRendering.ConversionPropertiesAbi[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_conversion_properties_result_get_minimum_retry_delay(IntPtr handle, out int result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_conversion_properties_result_get_properties(IntPtr handle, out Microsoft.Azure.RemoteRendering.ConversionPropertiesAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_create_rendering_session_result_get_session(IntPtr handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_get_cut_plane_filter_mask(ulong handle, out byte result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_get_fade_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4Ub result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_get_fade_length(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_get_normal(ulong handle, out Microsoft.Azure.RemoteRendering.Axis result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_set_cut_plane_filter_mask(ulong handle, byte value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_set_fade_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4Ub value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_set_fade_length(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_cut_plane_component_set_normal(ulong handle, Microsoft.Azure.RemoteRendering.Axis value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_get_render_frame_count(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_get_render_polygon_count(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_get_render_wireframe(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_set_render_frame_count(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_set_render_polygon_count(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_debug_rendering_settings_set_render_wireframe(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_destroy(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_find_component_of_type(ulong handle, Microsoft.Azure.RemoteRendering.ObjectType type, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_children(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_components(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_parent(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_position(ulong handle, out Microsoft.Azure.RemoteRendering.Double3 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_rotation(ulong handle, out Microsoft.Azure.RemoteRendering.Quaternion result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_scale(ulong handle, out Microsoft.Azure.RemoteRendering.Float3 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_static(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_query_local_bounds_async(ulong handle, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_query_metadata_async(ulong handle, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_query_world_bounds_async(ulong handle, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_parent(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_position(ulong handle, Microsoft.Azure.RemoteRendering.Double3 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_rotation(ulong handle, Microsoft.Azure.RemoteRendering.Quaternion value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_entity_set_scale(ulong handle, Microsoft.Azure.RemoteRendering.Float3 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_get_error_details(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result_message, [MarshalAs(UnmanagedType.LPStr)] out string result_requestCorrelationVector, [MarshalAs(UnmanagedType.LPStr)] out string result_responseCorrelationVector);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_get_handle_type(IntPtr handle, out Microsoft.Azure.RemoteRendering.HandleType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_get_handle_type_unsigned_long_long(ulong handle, out Microsoft.Azure.RemoteRendering.HandleType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_create(out ulong instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_get_api(ulong handle, out Microsoft.Azure.RemoteRendering.GraphicsApiType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_get_last_frame_statistics(ulong handle, out Microsoft.Azure.RemoteRendering.FrameStatistics stats, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_open_xr_d3d11_blit_remote_frame(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_open_xr_d3d11_get_remote_focus_point(ulong handle, ulong space_handle, out Microsoft.Azure.RemoteRendering.Float3 position, out Microsoft.Azure.RemoteRendering.Float3 normal, out Microsoft.Azure.RemoteRendering.Float3 velocity, out Microsoft.Azure.RemoteRendering.FocusPointResult result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_open_xr_d3d11_update_app_space(ulong handle, ulong space_handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_set_pose_mode(ulong handle, Microsoft.Azure.RemoteRendering.PoseMode mode, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_blit_remote_frame_to_proxy(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_deinit_simulation(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_get_remote_focus_point(ulong handle, out Microsoft.Azure.RemoteRendering.Float3 position, out Microsoft.Azure.RemoteRendering.Float3 normal, out Microsoft.Azure.RemoteRendering.Float3 velocity, out Microsoft.Azure.RemoteRendering.FocusPointResult result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_init_simulation_int_ptr_d3d_device_int_ptr_proxy_depth_int_ptr_proxy_color_single_refresh_rate_boolean_flip_blit_remote_frame_texture_vertically_boolean_flip_reproject_texture_vertically_boolean_stereo(ulong handle, System.IntPtr d3d_device, System.IntPtr proxy_depth, System.IntPtr proxy_color, float refresh_rate, [MarshalAs(UnmanagedType.U1)] bool flip_blit_remote_frame_texture_vertically, [MarshalAs(UnmanagedType.U1)] bool flip_reproject_texture_vertically, [MarshalAs(UnmanagedType.U1)] bool stereo, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_init_simulation_int_ptr_d3d_device_int32_render_target_width_int32_render_target_height_single_refresh_rate_boolean_flip_blit_remote_frame_texture_vertically_boolean_flip_reproject_texture_vertically_boolean_stereo(ulong handle, System.IntPtr d3d_device, int render_target_width, int render_target_height, float refresh_rate, [MarshalAs(UnmanagedType.U1)] bool flip_blit_remote_frame_texture_vertically, [MarshalAs(UnmanagedType.U1)] bool flip_reproject_texture_vertically, [MarshalAs(UnmanagedType.U1)] bool stereo, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_reproject_proxy(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_sim_d3d11_update(ulong handle, Microsoft.Azure.RemoteRendering.SimulationUpdateParameters update_parameters, out Microsoft.Azure.RemoteRendering.SimulationUpdateResult proxy_frame_update_result, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_wmr_d3d11_blit_remote_frame(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_wmr_d3d11_get_remote_focus_point(ulong handle, System.IntPtr coordinate_system, out Microsoft.Azure.RemoteRendering.Float3 position, out Microsoft.Azure.RemoteRendering.Float3 normal, out Microsoft.Azure.RemoteRendering.Float3 velocity, out Microsoft.Azure.RemoteRendering.FocusPointResult result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_graphics_binding_wmr_d3d11_update_user_coordinate_system(ulong handle, System.IntPtr coordinate_system, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_cut_plane_filter_mask(ulong handle, out byte result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_disable_collision_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_hidden_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_see_through_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_selected_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_shell_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalStates feature, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_tint_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4Ub result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_use_cut_plane_filter_mask_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_get_use_tint_color_state(ulong handle, out Microsoft.Azure.RemoteRendering.HierarchicalEnableState result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_cut_plane_filter_mask(ulong handle, byte value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_disable_collision_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_hidden_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_see_through_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_selected_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_shell_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalStates feature, Microsoft.Azure.RemoteRendering.HierarchicalEnableState enabled_state);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_tint_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4Ub value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_use_cut_plane_filter_mask_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_hierarchical_state_override_component_set_use_tint_color_state(ulong handle, Microsoft.Azure.RemoteRendering.HierarchicalEnableState value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_light_component_base_get_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4Ub result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_light_component_base_get_intensity(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_light_component_base_set_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4Ub value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_light_component_base_set_intensity(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_get_loaded_objects_of_type(IntPtr handle, Microsoft.Azure.RemoteRendering.ObjectType type, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=3)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_get_loaded_resource_of_type(IntPtr handle, Microsoft.Azure.RemoteRendering.ObjectType type, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=3)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_get_root(IntPtr handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_load_model_result_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_copy_from(ulong handle, ulong other);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_get_material_sub_type(ulong handle, out Microsoft.Azure.RemoteRendering.MaterialType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_get_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_material_set_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_get_materials(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_get_mesh(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_get_used_materials(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_set_material(ulong handle, int idx, ulong material);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_component_set_mesh(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_get_bounds(ulong handle, out Microsoft.Azure.RemoteRendering.Bounds result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_get_materials(ulong handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out ulong[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_mesh_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_base_create(out ulong instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_base_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_base_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_entry_get_as_bool(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_entry_get_as_double(IntPtr handle, out double result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_entry_get_as_int(IntPtr handle, out int result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_entry_get_as_int64(IntPtr handle, out long result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_entry_get_as_string(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_entry_get_as_uint64(IntPtr handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_entry_get_name(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_entry_get_type(IntPtr handle, out Microsoft.Azure.RemoteRendering.MetadataValueType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_get_metadata(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out IntPtr[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_get_metadata_by_name(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string name, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_get_valid(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_object_metadata_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_get_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4Ub result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_get_pulse_intensity(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_get_pulse_rate_hz(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_set_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4Ub value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_set_pulse_intensity(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_outline_settings_set_pulse_rate_hz(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_albedo_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_albedo_texture(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_alpha_clip_threshold(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_aomap(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_aoscale(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_fade_out(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_fresnel_effect_color(ulong handle, out Microsoft.Azure.RemoteRendering.Color4 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_fresnel_effect_exponent(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_metalness(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_metalness_map(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_normal_map(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_pbr_flags(ulong handle, out Microsoft.Azure.RemoteRendering.PbrMaterialFeatures result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_pbr_vertex_alpha_mode(ulong handle, out Microsoft.Azure.RemoteRendering.PbrVertexAlphaMode result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_roughness(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_roughness_map(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_tex_coord_offset(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_get_tex_coord_scale(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_albedo_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_albedo_texture(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_alpha_clip_threshold(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_aomap(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_aoscale(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_fade_out(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_fresnel_effect_color(ulong handle, Microsoft.Azure.RemoteRendering.Color4 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_fresnel_effect_exponent(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_metalness(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_metalness_map(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_normal_map(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_pbr_flags(ulong handle, Microsoft.Azure.RemoteRendering.PbrMaterialFeatures value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_pbr_vertex_alpha_mode(ulong handle, Microsoft.Azure.RemoteRendering.PbrVertexAlphaMode value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_roughness(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_roughness_map(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_tex_coord_offset(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_pbr_material_set_tex_coord_scale(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_cloud_settings_get_point_size_override(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_cloud_settings_get_point_size_scale(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_cloud_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_cloud_settings_set_point_size_override(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_cloud_settings_set_point_size_scale(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_get_attenuation_cutoff(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_get_length(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_get_projected_cube_map(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_get_radius(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_set_attenuation_cutoff(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_set_length(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_set_projected_cube_map(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_point_light_component_set_radius(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_ray_cast_query_result_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_ray_cast_query_result_get_hits(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out Microsoft.Azure.RemoteRendering.RayCastHitAbi[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_ray_cast_query_result_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_addref(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_create_new_rendering_session_async(ulong handle, Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsAbi options, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_create_new_rendering_session_unsafe_async(ulong handle, Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafeAbi options, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_create_session_configuration_configuration(Microsoft.Azure.RemoteRendering.SessionConfigurationAbi configuration, out ulong instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_dispose(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_get_asset_conversion_status_async(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string conversion_id, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_get_configuration(ulong handle, out Microsoft.Azure.RemoteRendering.SessionConfigurationAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_get_conversion_properties_async(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string conversion_id, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_get_current_conversions_async(ulong handle, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_get_current_rendering_sessions_async(ulong handle, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_get_log_level(ulong handle, out Microsoft.Azure.RemoteRendering.LogLevel result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_open_rendering_session_async(ulong handle, [MarshalAs(UnmanagedType.LPStr)] string session_id, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_release(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_set_destructor_hook(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_set_log_level(ulong handle, Microsoft.Azure.RemoteRendering.LogLevel value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_set_message_logged(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.LogEventHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_set_token_required(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.TokenRequiredEventHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_remote_rendering_client_start_asset_conversion_async(ulong handle, Microsoft.Azure.RemoteRendering.AssetConversionOptionsAbi conversion_options, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_create_component(ulong handle, Microsoft.Azure.RemoteRendering.ObjectType component_type, ulong owner, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_create_entity(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_create_material(ulong handle, Microsoft.Azure.RemoteRendering.MaterialType type, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_get_camera_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_get_debug_rendering_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_get_log_level(ulong handle, out Microsoft.Azure.RemoteRendering.LogLevel result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_get_outline_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_get_point_cloud_settings_experimental(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_get_shell_rendering_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_get_single_sided_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_get_sky_reflection_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_get_stage_space_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_get_zfighting_mitigation_settings(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_load_model_async(ulong handle, Microsoft.Azure.RemoteRendering.LoadModelOptionsAbi options, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_load_model_from_sas_async(ulong handle, Microsoft.Azure.RemoteRendering.LoadModelFromSasOptionsAbi options, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_load_texture_async(ulong handle, Microsoft.Azure.RemoteRendering.LoadTextureOptionsAbi options, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_load_texture_from_sas_async(ulong handle, Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptionsAbi options, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_query_server_performance_assessment_async(ulong handle, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_ray_cast_query_async(ulong handle, Microsoft.Azure.RemoteRendering.RayCast cast, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_set_destructor_hook(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_set_log_level(ulong handle, Microsoft.Azure.RemoteRendering.LogLevel value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_set_message_logged(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.LogEventHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_set_updated(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.RenderingConnectionUpdatedEventHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_connection_update(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_addref(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_connect_async(ulong handle, Microsoft.Azure.RemoteRendering.RendererInitOptionsAbi init_options, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_connect_to_arr_inspector_async(ulong handle, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_disconnect(ulong handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_get_client(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_get_connection_status(ulong handle, out Microsoft.Azure.RemoteRendering.ConnectionStatus result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_get_is_connected(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_get_properties_async(ulong handle, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_get_renderer_init_options(ulong handle, out Microsoft.Azure.RemoteRendering.RendererInitOptionsAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_get_session_uuid(ulong handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_properties_array_result_get_session_properties(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] out Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi[] result, out int result_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_properties_result_get_minimum_retry_delay(IntPtr handle, out int result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_properties_result_get_session_properties(IntPtr handle, out Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_release(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_renew_async(ulong handle, Microsoft.Azure.RemoteRendering.RenderingSessionUpdateOptions update_options, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_set_connection_status_changed(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.ConnectionStatusChangedEventHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_set_destructor_hook(ulong handle, ulong value, Microsoft.Azure.RemoteRendering.DestructorHookDelegateNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_rendering_session_stop_async(ulong handle, Microsoft.Azure.RemoteRendering.PromiseSafeHandle promiseHandle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_addref(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_create(out ulong instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_resource_base_release(ulong handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_context_result_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_context_result_create(out IntPtr instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_context_result_get_context(IntPtr handle, out Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_context_result_get_error_code(IntPtr handle, out Microsoft.Azure.RemoteRendering.Result result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_session_context_result_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_set_projected_object_cleanup(Microsoft.Azure.RemoteRendering.ProjectedObjectCleanupNative callback);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_shell_rendering_settings_get_desaturation(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_shell_rendering_settings_get_opacity(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_shell_rendering_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_shell_rendering_settings_set_desaturation(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_shell_rendering_settings_set_opacity(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_single_sided_settings_get_mode(ulong handle, out Microsoft.Azure.RemoteRendering.SingleSidedMode result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_single_sided_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_single_sided_settings_set_mode(ulong handle, Microsoft.Azure.RemoteRendering.SingleSidedMode value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_sky_reflection_settings_get_sky_reflection_texture(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_sky_reflection_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_sky_reflection_settings_set_sky_reflection_texture(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_attenuation_cutoff(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_falloff_exponent(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_projected2d_texture(ulong handle, out ulong result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_radius(ulong handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_get_spot_angle_deg(ulong handle, out Microsoft.Azure.RemoteRendering.Float2 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_attenuation_cutoff(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_falloff_exponent(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_projected2d_texture(ulong handle, ulong value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_radius(ulong handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_spot_light_component_set_spot_angle_deg(ulong handle, Microsoft.Azure.RemoteRendering.Float2 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_stage_space_settings_get_position(ulong handle, out Microsoft.Azure.RemoteRendering.Double3 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_stage_space_settings_get_rotation(ulong handle, out Microsoft.Azure.RemoteRendering.Quaternion result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_stage_space_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_stage_space_settings_set_position(ulong handle, Microsoft.Azure.RemoteRendering.Double3 value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_stage_space_settings_set_rotation(ulong handle, Microsoft.Azure.RemoteRendering.Quaternion value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_texture_get_name(ulong handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_texture_get_type(ulong handle, out Microsoft.Azure.RemoteRendering.ObjectType result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_texture_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_get_access_token(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_get_authentication_token(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_set_access_token(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_token_required_event_args_set_authentication_token(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_get_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_get_highlighting(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_get_valid(ulong handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_set_enabled(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.RemoteRendering.status arr_zfighting_mitigation_settings_set_highlighting(ulong handle, [MarshalAs(UnmanagedType.U1)] bool value);
    }

    // CODE STARTS HERE

    abstract class BasePrivateDictionary<TKey, TValue> : IDictionary<TKey, TValue>
    {
        protected abstract int InternalGetCount();
        protected abstract TKey InternalGetKey(int index);
        protected abstract TValue InternalGetItem(TKey key);
        protected abstract void InternalSetItem(TKey key, TValue value);
        protected abstract void InternalRemoveKey(TKey key);

        public TValue this[TKey key] { get { return InternalGetItem(key); } set { InternalSetItem(key, value); } }

        public ICollection<TKey> Keys { get { return Enumerable.Range(0, InternalGetCount()).Select(n => InternalGetKey(n)).ToList().AsReadOnly(); } }

        public ICollection<TValue> Values { get { return Enumerable.Range(0, InternalGetCount()).Select(n => InternalGetKey(n)).Select(k => InternalGetItem(k)).ToList().AsReadOnly(); } }

        public int Count { get { return InternalGetCount(); } }

        public bool IsReadOnly { get { return false; } }

        public void Add(TKey key, TValue value)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                InternalSetItem(key, value);
                return;
            }
            throw new ArgumentException();
        }

        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        public void Clear()
        {
            while (InternalGetCount() > 0)
            {
                TKey key = InternalGetKey(0);
                InternalRemoveKey(key);
            }
        }

        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            try
            {
                TValue value = InternalGetItem(item.Key);
                if (Comparer<TValue>.Default.Compare(value, item.Value) == 0)
                {
                    return true;
                }
                return false;
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
        }

        public bool ContainsKey(TKey key)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            return true;
        }

        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                array[arrayIndex + i] = new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }

        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                yield return new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }

        public bool Remove(TKey key)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            InternalRemoveKey(key);
            return true;
        }

        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return Remove(item.Key);
        }

        public bool TryGetValue(TKey key, out TValue value)
        {
            try
            {
                value = InternalGetItem(key);
                return true;
            }
            catch (KeyNotFoundException)
            {
                value = default(TValue);
                return false;
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                yield return new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }
    }

    abstract class BasePrivateList<T> : IList<T>
    {
        protected abstract int InternalGetCount();
        protected abstract T InternalGetItem(int index);
        protected abstract void InternalSetItem(int index, T value);
        protected abstract void InternalRemoveItem(int index);

        public int Count { get { return InternalGetCount(); } }

        public bool IsReadOnly { get { return false; } }

        public T this[int index] { get { return InternalGetItem(index); } set { InternalSetItem(index, value); } }

        public int IndexOf(T item)
        {
            int count = InternalGetCount();
            for (int i = 0; i < count; i++)
            {
                if (Comparer<T>.Default.Compare(item, InternalGetItem(i)) == 0)
                {
                    return i;
                }
            }
            return -1;
        }

        public void Insert(int index, T item)
        {
            InternalSetItem(index, item);
        }

        public void RemoveAt(int index)
        {
            InternalRemoveItem(index);
        }

        public void Add(T item)
        {
            InternalSetItem(InternalGetCount(), item);
        }

        public void Clear()
        {
            while (InternalGetCount() > 0)
            {
                InternalRemoveItem(0);
            }
        }

        public bool Contains(T item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            for (int i = 0; i < Count; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public bool Remove(T item)
        {
            int index = IndexOf(item);
            if (index < 0) return false;
            InternalRemoveItem(index);
            return true;
        }

        public IEnumerator<T> GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }
    }

    internal static class Factories
    {
        internal static Microsoft.Azure.RemoteRendering.SessionContextResult SessionContextResultFactory(IntPtr handle, bool transfer)
        {
            if (handle == IntPtr.Zero)
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type(handle, out result));
            Microsoft.Azure.RemoteRendering.SessionContextResult result_object;
            switch (result)
            {
                case HandleType.CreateRenderingSessionResult:
                    result_object = new Microsoft.Azure.RemoteRendering.CreateRenderingSessionResult(handle, transfer);
                    break;
                case HandleType.SessionContextResult:
                    result_object = new Microsoft.Azure.RemoteRendering.SessionContextResult(handle, transfer);
                    break;
                case HandleType.RenderingSessionPropertiesResult:
                    result_object = new Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesResult(handle, transfer);
                    break;
                case HandleType.ConversionPropertiesResult:
                    result_object = new Microsoft.Azure.RemoteRendering.ConversionPropertiesResult(handle, transfer);
                    break;
                case HandleType.RenderingSessionPropertiesArrayResult:
                    result_object = new Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesArrayResult(handle, transfer);
                    break;
                case HandleType.AssetConversionResult:
                    result_object = new Microsoft.Azure.RemoteRendering.AssetConversionResult(handle, transfer);
                    break;
                case HandleType.AssetConversionStatusResult:
                    result_object = new Microsoft.Azure.RemoteRendering.AssetConversionStatusResult(handle, transfer);
                    break;
                case HandleType.ConversionPropertiesArrayResult:
                    result_object = new Microsoft.Azure.RemoteRendering.ConversionPropertiesArrayResult(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.ObjectBase ObjectBaseFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.ObjectBase result_object;
            switch (result)
            {
                case HandleType.ComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.ComponentBase(handle, transfer);
                    break;
                case HandleType.ObjectBase:
                    result_object = new Microsoft.Azure.RemoteRendering.ObjectBase(handle, transfer);
                    break;
                case HandleType.LightComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.LightComponentBase(handle, transfer);
                    break;
                case HandleType.CutPlaneComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.CutPlaneComponent(handle, transfer);
                    break;
                case HandleType.HierarchicalStateOverrideComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.HierarchicalStateOverrideComponent(handle, transfer);
                    break;
                case HandleType.PointLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.PointLightComponent(handle, transfer);
                    break;
                case HandleType.SpotLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.SpotLightComponent(handle, transfer);
                    break;
                case HandleType.DirectionalLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.DirectionalLightComponent(handle, transfer);
                    break;
                case HandleType.MeshComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.MeshComponent(handle, transfer);
                    break;
                case HandleType.Entity:
                    result_object = new Microsoft.Azure.RemoteRendering.Entity(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.ComponentBase ComponentBaseFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.ComponentBase result_object;
            switch (result)
            {
                case HandleType.LightComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.LightComponentBase(handle, transfer);
                    break;
                case HandleType.ComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.ComponentBase(handle, transfer);
                    break;
                case HandleType.CutPlaneComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.CutPlaneComponent(handle, transfer);
                    break;
                case HandleType.HierarchicalStateOverrideComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.HierarchicalStateOverrideComponent(handle, transfer);
                    break;
                case HandleType.PointLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.PointLightComponent(handle, transfer);
                    break;
                case HandleType.SpotLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.SpotLightComponent(handle, transfer);
                    break;
                case HandleType.DirectionalLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.DirectionalLightComponent(handle, transfer);
                    break;
                case HandleType.MeshComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.MeshComponent(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.LightComponentBase LightComponentBaseFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.LightComponentBase result_object;
            switch (result)
            {
                case HandleType.PointLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.PointLightComponent(handle, transfer);
                    break;
                case HandleType.LightComponentBase:
                    result_object = new Microsoft.Azure.RemoteRendering.LightComponentBase(handle, transfer);
                    break;
                case HandleType.SpotLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.SpotLightComponent(handle, transfer);
                    break;
                case HandleType.DirectionalLightComponent:
                    result_object = new Microsoft.Azure.RemoteRendering.DirectionalLightComponent(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.ResourceBase ResourceBaseFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.ResourceBase result_object;
            switch (result)
            {
                case HandleType.Material:
                    result_object = new Microsoft.Azure.RemoteRendering.Material(handle, transfer);
                    break;
                case HandleType.ResourceBase:
                    result_object = new Microsoft.Azure.RemoteRendering.ResourceBase(handle, transfer);
                    break;
                case HandleType.PbrMaterial:
                    result_object = new Microsoft.Azure.RemoteRendering.PbrMaterial(handle, transfer);
                    break;
                case HandleType.ColorMaterial:
                    result_object = new Microsoft.Azure.RemoteRendering.ColorMaterial(handle, transfer);
                    break;
                case HandleType.Mesh:
                    result_object = new Microsoft.Azure.RemoteRendering.Mesh(handle, transfer);
                    break;
                case HandleType.Texture:
                    result_object = new Microsoft.Azure.RemoteRendering.Texture(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.Material MaterialFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.Material result_object;
            switch (result)
            {
                case HandleType.PbrMaterial:
                    result_object = new Microsoft.Azure.RemoteRendering.PbrMaterial(handle, transfer);
                    break;
                case HandleType.Material:
                    result_object = new Microsoft.Azure.RemoteRendering.Material(handle, transfer);
                    break;
                case HandleType.ColorMaterial:
                    result_object = new Microsoft.Azure.RemoteRendering.ColorMaterial(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

        internal static Microsoft.Azure.RemoteRendering.GraphicsBinding GraphicsBindingFactory(ulong handle, bool transfer)
        {
            if (handle == default(ulong))
            {
                return null;
            }

            HandleType result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_get_handle_type_unsigned_long_long(handle, out result));
            Microsoft.Azure.RemoteRendering.GraphicsBinding result_object;
            switch (result)
            {
                case HandleType.GraphicsBindingSimD3d11:
                    result_object = new Microsoft.Azure.RemoteRendering.GraphicsBindingSimD3d11(handle, transfer);
                    break;
                case HandleType.GraphicsBinding:
                    result_object = new Microsoft.Azure.RemoteRendering.GraphicsBinding(handle, transfer);
                    break;
                case HandleType.GraphicsBindingWmrD3d11:
                    result_object = new Microsoft.Azure.RemoteRendering.GraphicsBindingWmrD3d11(handle, transfer);
                    break;
                case HandleType.GraphicsBindingOpenXrD3d11:
                    result_object = new Microsoft.Azure.RemoteRendering.GraphicsBindingOpenXrD3d11(handle, transfer);
                    break;
                default:
                    throw new ArgumentException();
            }
            return result_object;
        }

    }

    /// <summary>
    /// 2-component vector with single precision.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Float2
    {
        readonly public float X;

        readonly public float Y;

    }

    /// <summary>
    /// 3-component vector with single precision.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Float3
    {
        readonly public float X;

        readonly public float Y;

        readonly public float Z;

    }

    /// <summary>
    /// 4-component vector with single precision.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Float4
    {
        readonly public float X;

        readonly public float Y;

        readonly public float Z;

        readonly public float W;

    }

    /// <summary>
    /// 3-component vector with double precision.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Double3
    {
        readonly public double X;

        readonly public double Y;

        readonly public double Z;

    }

    /// <summary>
    /// 4-component color (red, green, blue, alpha) with single precision.
    /// </summary>
    /// <remarks>
    /// Values are in 0..1 range, but can go above that range to represent high-dynamic range (HDR) colors.
    /// The color values are assumed to be in 'linear space', not in 'Gamma space'.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Color4
    {
        readonly public float R;

        readonly public float G;

        readonly public float B;

        readonly public float A;

    }

    /// <summary>
    /// 4 component color (red, green, blue, alpha) based on 8 bit components [0..255].
    /// </summary>
    /// <remarks>
    /// Values are in 0..255 range and represent low-dynamic range (LDR) colors.
    /// The color values are assumed to be in 'Gamma space'.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Color4UbChannels
    {
        public byte R;

        public byte G;

        public byte B;

        public byte A;

    }

    /// <summary>
    /// 4 component color (red, green, blue, alpha) based on 8 bit components [0..255].
    /// </summary>
    /// <remarks>
    /// Values are in 0..255 range and represent low-dynamic range (LDR) colors.
    /// The color values are assumed to be in 'Gamma space'.
    /// </remarks>
    [StructLayout(LayoutKind.Explicit)]
    public partial struct Color4Ub
    {
        [FieldOffset(0)]
        /// <summary>
        /// Interprets the color as r,g,b,a byte values.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Color4UbChannels Channels;

        [FieldOffset(0)]
        /// <summary>
        /// Interprets the color as a single 32bit integer. Used for assignments and comparisons.
        /// </summary>
        public int Bytes;

    }

    /// <summary>
    /// Single precision quaternion to describe an object rotation.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Quaternion
    {
        readonly public float X;

        readonly public float Y;

        readonly public float Z;

        readonly public float W;

    }

    /// <summary>
    /// 4x4 matrix based on single precision components.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Matrix4x4
    {
        readonly public Microsoft.Azure.RemoteRendering.Float4 Column0;

        readonly public Microsoft.Azure.RemoteRendering.Float4 Column1;

        readonly public Microsoft.Azure.RemoteRendering.Float4 Column2;

        readonly public Microsoft.Azure.RemoteRendering.Float4 Column3;

    }

    /// <summary>
    /// A generic, possibly off-center definition of a camera's field of view.
    /// </summary>
    /// <remarks>
    /// Angles to the right and to the top from the center are positive, while angles to the left and to the bottom are negative.
    /// To define a symmetric field of view, set AngleLeft = -AngleRight and AngleDown = -AngleUp.
    /// All angle values are defined in radians and have to be in range (-PI/2; PI/2), with AngleLeft less than AngleRight and AngleDown less than AngleUp or the field of
    /// view will be regarded as invalid. Respective functions will yield a <see cref="Result.InvalidParam"/> error if the field
    /// of view is invalid.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SimulationUpdateParameters"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SimulationUpdateResult"/>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct CameraFov
    {
        /// <summary>
        /// Maximum view angle in radians to the left of the camera view (typically negative)
        /// </summary>
        public float AngleLeft;

        /// <summary>
        /// Maximum view angle in radians to the right of the camera view
        /// </summary>
        public float AngleRight;

        /// <summary>
        /// Maximum view angle in radians to the top of the camera view
        /// </summary>
        public float AngleUp;

        /// <summary>
        /// / Maximum view angle in radians to the bottom of the camera view (typically negative)
        /// </summary>
        public float AngleDown;

    }

    /// <summary>
    /// This struct holds matrices for the left and right camera view in stereo rendering.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SimulationUpdateParameters"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SimulationUpdateResult"/>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct StereoMatrix4x4
    {
        /// <summary>
        /// The matrix for the left eye view.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Matrix4x4 Left;

        /// <summary>
        /// The matrix for the right eye view.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Matrix4x4 Right;

    }

    /// <summary>
    /// This struct holds field of views for the left and right camera view in stereo rendering.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SimulationUpdateParameters"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SimulationUpdateResult"/>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct StereoCameraFov
    {
        /// <summary>
        /// The field of view for the left camera view.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.CameraFov Left;

        /// <summary>
        /// The field of view for the right camera view.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.CameraFov Right;

    }

    /// <summary>
    /// Axis-aligned bounding box, based on double precision min and max position.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Bounds
    {
        /// <summary>
        /// Position of the minimum corner.
        /// </summary>
        readonly public Microsoft.Azure.RemoteRendering.Double3 Min;

        /// <summary>
        /// Position of the maximum corner.
        /// </summary>
        readonly public Microsoft.Azure.RemoteRendering.Double3 Max;

    }

    /// <summary>
    /// Frame statistics to do client-side performance assessment. See <see cref="GraphicsBinding.GetLastFrameStatistics(FrameStatistics)"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBinding.GetLastFrameStatistics(Microsoft.Azure.RemoteRendering.FrameStatistics)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/performance-queries">Server-side performance queries</seealso>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct FrameStatistics
    {
        /// <summary>
        /// Time between the client's request for a new remote frame and the arrival of the requested frame.
        /// </summary>
        /// <remarks>
        /// This includes, but is not limited to, the network round-trip latency and delays caused by operations necessary
        /// on the server side before sending, and on the client side after receiving (rendering, video encoding/decoding, etc).
        /// </remarks>
        public float LatencyPoseToReceive;

        /// <summary>
        /// Time between arrival of a new frame and its actual usage.
        /// </summary>
        /// <remarks>
        /// Gives the latency between the availability of new frame data and
        /// its actual use. This contains client-side CPU drawcall time, frame reprojection, etc.
        /// </remarks>
        public float LatencyReceiveToPresent;

        /// <summary>
        /// The latency until the finished frame is displayed.
        /// </summary>
        /// <remarks>
        /// This mainly contains aspects like GPU workload and waiting for V-sync but
        /// can also encompass overhead introduced by the rendering infrastructure.
        /// For example, some game engines introduce a scheduling overhead in this phase.
        /// </remarks>
        public float LatencyPresentToDisplay;

        /// <summary>
        /// The time between subsequent calls to PresentFrame on the CPU.
        /// </summary>
        /// <remarks>
        /// Values greater than the display duration (for example 16.6 ms on a 60-Hz client device)
        /// indicate issues caused by the client application not finishing its CPU workload in time.
        /// </remarks>
        public float TimeSinceLastPresent;

        /// <summary>
        /// Number of received frames in the last second that were used on the device more than once.
        /// </summary>
        /// <remarks>
        /// Non-zero values indicate that frames had to be reprojected either due to network jitter or excessive server rendering time.
        /// </remarks>
        public int VideoFrameReusedCount;

        /// <summary>
        /// Number of received frames in the last second that were decoded, but not shown on display because a newer frame has arrived.
        /// </summary>
        /// <remarks>
        /// Non-zero values indicate that network jitter caused multiple frames to be delayed and then arrived on the client device together in a burst.
        /// </remarks>
        public int VideoFramesSkipped;

        /// <summary>
        /// The number of frames received from the server in the last second.
        /// </summary>
        public int VideoFramesReceived;

        /// <summary>
        /// Very similar to <see cref="FrameStatistics.VideoFramesSkipped"/>, but the reason for being discarded is that a frame came in so late that it couldn't even be correlated with any pending pose anymore. If this happens, there is some severe network contention.
        /// </summary>
        public int VideoFramesDiscarded;

        /// <summary>
        /// Minimum amount of time between two consecutive frames arriving during the last second.
        /// </summary>
        /// <remarks>
        /// Together with <see cref="FrameStatistics.VideoFrameMaxDelta"/> this range gives an indication of jitter caused either by the network or video codec.
        /// </remarks>
        public float VideoFrameMinDelta;

        /// <summary>
        /// Maximum amount of time between two consecutive frames arriving during the last second.
        /// </summary>
        /// <remarks>
        /// Together with <see cref="FrameStatistics.VideoFrameMinDelta"/> this range gives an indication of jitter caused either by the network or video codec.
        /// </remarks>
        public float VideoFrameMaxDelta;

    }

    /// <summary>
    /// Describes a single performance assessment value. See <see cref="PerformanceAssessment"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PerformanceAssessment"/>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct PerformanceInformation
    {
        /// <summary>
        /// Aggregated value to assess.
        /// </summary>
        public float Aggregate;

        /// <summary>
        /// Rating for the aggregate value.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceRating Rating;

    }

    /// <summary>
    /// Performance assessment of Remote Rendering statistics. See <see cref="RenderingConnection.QueryServerPerformanceAssessmentAsync"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.QueryServerPerformanceAssessmentAsync"/>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct PerformanceAssessment
    {
        /// <summary>
        /// Average CPU time per frame in milliseconds.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation TimeCpu;

        /// <summary>
        /// Average GPU time per frame in milliseconds.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation TimeGpu;

        /// <summary>
        /// Total CPU utilization in percent on the server host machine.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation UtilizationCpu;

        /// <summary>
        /// Total GPU utilization in percent on the server host machine.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation UtilizationGpu;

        /// <summary>
        /// Total main memory utilization in percent on the server host machine.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation MemoryCpu;

        /// <summary>
        /// Total dedicated video memory utilization in percent of the server GPU.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation MemoryGpu;

        /// <summary>
        /// Approximate average round-trip network latency in milliseconds.
        /// </summary>
        /// <remarks>
        /// The value is computed by subtracting actual server rendering time from <see cref="FrameStatistics.latencyPoseToReceive"/>.
        /// While this approximation is not accurate, it gives some indication of the network latency isolated from the latency values computed on the client.
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/performance-queries">Server-side performance queries</seealso>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation NetworkLatency;

        /// <summary>
        /// Number of triangles rendered in one frame.
        /// </summary>
        /// <remarks>
        /// This number also includes the triangles that are culled during rendering.
        /// That means, this number does not vary a lot across different camera positions, but the performance on the other hand may vary a lot,
        /// depending on the triangle culling rate.
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/reference/limits">Remote Rendering limitations</seealso>
        public Microsoft.Azure.RemoteRendering.PerformanceInformation PolygonsRendered;

    }

    /// <summary>
    /// When <see cref="GraphicsBindingSimD3d11"/> is used, this must be filled out and passed to <see cref="GraphicsBindingSimD3d11.Update(SimulationUpdateParameters,SimulationUpdateResult)"/> once per frame.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingSimD3d11.Update(Microsoft.Azure.RemoteRendering.SimulationUpdateParameters,Microsoft.Azure.RemoteRendering.SimulationUpdateResult)"/>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SimulationUpdateParameters
    {
        /// <summary>
        /// Frame counter, should be incremented every frame.
        /// </summary>
        public int FrameId;

        /// <summary>
        /// Camera transform matrices (translation and rotation). For mono rendering, only the left member of viewTransform is used.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.StereoMatrix4x4 ViewTransform;

        /// <summary>
        /// The cameras' field of view definitions. For mono rendering, only the left field of view is used.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.StereoCameraFov FieldOfView;

    }

    /// <summary>
    /// When <see cref="GraphicsBindingSimD3d11"/> is used, objects of this struct will contain the result after successfully calling <see cref="GraphicsBindingSimD3d11.Update(SimulationUpdateParameters,SimulationUpdateResult)"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingSimD3d11.Update(Microsoft.Azure.RemoteRendering.SimulationUpdateParameters,Microsoft.Azure.RemoteRendering.SimulationUpdateResult)"/>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SimulationUpdateResult
    {
        /// <summary>
        /// Frame counter, should be incremented every frame.
        /// </summary>
        public int FrameId;

        /// <summary>
        /// Distance (in meters) to the camera's near clipping plane.
        /// </summary>
        public float NearPlaneDistance;

        /// <summary>
        /// Distance (in meters) to the camera's far clipping plane.
        /// </summary>
        public float FarPlaneDistance;

        /// <summary>
        /// Camera transform matrices (translation and rotation). For mono rendering, only the left matrix is valid.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.StereoMatrix4x4 ViewTransform;

        /// <summary>
        /// Camera field of view (translation and rotation). For mono rendering, only the left field of view is valid.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.StereoCameraFov FieldOfView;

    }

    /// <summary>
    /// Parameters for doing a raycast.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.RayCastQueryAsync(Microsoft.Azure.RemoteRendering.RayCast)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial Queries</seealso>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct RayCast
    {
        /// <summary>
        /// Start position for the raycast in world space.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 StartPos;

        /// <summary>
        /// End position of the raycast in world space.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 EndPos;

        /// <summary>
        /// See <see cref="HitCollectionPolicy"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HitCollectionPolicy HitCollection;

        /// <summary>
        /// The maximum number of hits to collect. Only needed for <see cref="HitCollectionPolicy.ClosestHits"/>. This number must be between 0 and 256, with 256 being a hard limit for the number of supported hit results. A value of 0 returns up to the maximum number of supported hits. In case the number of actual hits exceeds the limit, the n closest hits are returned.
        /// </summary>
        public int MaxHits;

        /// <summary>
        /// Reserved for future use.
        /// </summary>
        public uint CollisionMask;

    }

    /// <summary>
    /// Contains information about a single raycast hit.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.RayCastQueryAsync(Microsoft.Azure.RemoteRendering.RayCast)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial Queries</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RayCastHitAbi
    {
        /// <summary>
        /// The <see cref="Entity"/> that was hit with the raycast.
        /// </summary>
        public ulong HitObject;

        /// <summary>
        /// The ID or index of the part that was hit.
        /// </summary>
        /// <remarks>
        /// This can be used to get the <see cref="Material"/> at the raycast intersection.
        /// First query for the <see cref="MeshComponent"/>, then query for the material using <c>MeshComponent.UsedMaterials[SubPartId].</c>
        /// </remarks>
        public int SubPartId;

        /// <summary>
        /// The world space position where <see cref="RayCastHit.HitObject"/> was hit.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 HitPosition;

        /// <summary>
        /// The world space normal where <see cref="RayCastHit.HitObject"/> was hit.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float3 HitNormal;

        /// <summary>
        /// Distance along the normalized ray direction to the hit.
        /// </summary>
        /// <remarks>
        /// <see cref="RayCast.StartPos"/> + normalize(<see cref="RayCast.EndPos"/> - <see cref="RayCast.StartPos"/>) * <see cref="RayCastHit.DistanceToHit"/> == <see cref="RayCastHit.HitPosition"/>
        /// </remarks>
        public double DistanceToHit;

        public Microsoft.Azure.RemoteRendering.RayCastHit Convert()
        {
            return Microsoft.Azure.RemoteRendering.RayCastHitAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RayCastHit Convert(Microsoft.Azure.RemoteRendering.RayCastHitAbi value)
        {
            Microsoft.Azure.RemoteRendering.RayCastHit result = new Microsoft.Azure.RemoteRendering.RayCastHit();

            result.HitObject = value.HitObject != default(ulong) ? new Microsoft.Azure.RemoteRendering.Entity(value.HitObject, false) : null;
            result.SubPartId = value.SubPartId;
            result.HitPosition = value.HitPosition;
            result.HitNormal = value.HitNormal;
            result.DistanceToHit = value.DistanceToHit;

            return result;
        }
    }

    /// <summary>
    /// Contains information about a single raycast hit.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.RayCastQueryAsync(Microsoft.Azure.RemoteRendering.RayCast)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial Queries</seealso>
    public partial struct RayCastHit
    {
        /// <summary>
        /// The <see cref="Entity"/> that was hit with the raycast.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Entity HitObject;

        /// <summary>
        /// The ID or index of the part that was hit.
        /// </summary>
        /// <remarks>
        /// This can be used to get the <see cref="Material"/> at the raycast intersection.
        /// First query for the <see cref="MeshComponent"/>, then query for the material using <c>MeshComponent.UsedMaterials[SubPartId].</c>
        /// </remarks>
        public int SubPartId;

        /// <summary>
        /// The world space position where <see cref="RayCastHit.HitObject"/> was hit.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Double3 HitPosition;

        /// <summary>
        /// The world space normal where <see cref="RayCastHit.HitObject"/> was hit.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Float3 HitNormal;

        /// <summary>
        /// Distance along the normalized ray direction to the hit.
        /// </summary>
        /// <remarks>
        /// <see cref="RayCast.StartPos"/> + normalize(<see cref="RayCast.EndPos"/> - <see cref="RayCast.StartPos"/>) * <see cref="RayCastHit.DistanceToHit"/> == <see cref="RayCastHit.HitPosition"/>
        /// </remarks>
        public double DistanceToHit;

        internal Microsoft.Azure.RemoteRendering.RayCastHitAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RayCastHit.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RayCastHitAbi Convert(Microsoft.Azure.RemoteRendering.RayCastHit value)
        {
            Microsoft.Azure.RemoteRendering.RayCastHitAbi result = new Microsoft.Azure.RemoteRendering.RayCastHitAbi();

            result.HitObject = value.HitObject?.handle ?? default(ulong);
            result.SubPartId = value.SubPartId;
            result.HitPosition = value.HitPosition;
            result.HitNormal = value.HitNormal;
            result.DistanceToHit = value.DistanceToHit;

            return result;
        }
    }

    /// <summary>
    /// Account information and domain to associate an <see cref="RemoteRenderingClient"/> instance with.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingClient"/>
    [StructLayout(LayoutKind.Sequential)]
    internal struct SessionConfigurationAbi
    {
        /// <summary>
        /// Domain that will be used for account authentication for the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// The domain is of the form [region].mixedreality.azure.com.
        /// [region] should be set to the location of the Azure Remote Rendering account. For example, eastus.mixedreality.azure.com or westeurope.mixedreality.azure.com.
        /// Legacy mixedreality.azure.com authentication domain is being phased out.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AccountDomain;

        /// <summary>
        /// Domain that will be used to generate sessions for the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// The domain is of the form [region].mixedreality.azure.com.
        /// [region] should be selected based on the region closest to the user. For example, westus2.mixedreality.azure.com or westeurope.mixedreality.azure.com.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string RemoteRenderingDomain;

        /// <summary>
        /// The ID of the account that's being used with the Azure Remote Rendering service.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AccountId;

        /// <summary>
        /// The key of the account that's being used with the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// Only one of AccountKey, AccessToken or AuthenticationToken needs to be set.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AccountKey;

        /// <summary>
        /// An access token for the account that's being used with the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// Only one of AccountKey, AccessToken or AuthenticationToken needs to be set.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AccessToken;

        /// <summary>
        /// An authentication token for Azure Active Directory (AAD).
        /// </summary>
        /// <remarks>
        /// Only one of AccountKey, AccessToken or AuthenticationToken needs to be set.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AuthenticationToken;

        public Microsoft.Azure.RemoteRendering.SessionConfiguration Convert()
        {
            return Microsoft.Azure.RemoteRendering.SessionConfigurationAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.SessionConfiguration Convert(Microsoft.Azure.RemoteRendering.SessionConfigurationAbi value)
        {
            Microsoft.Azure.RemoteRendering.SessionConfiguration result = new Microsoft.Azure.RemoteRendering.SessionConfiguration();

            result.AccountDomain = value.AccountDomain;
            result.RemoteRenderingDomain = value.RemoteRenderingDomain;
            result.AccountId = value.AccountId;
            result.AccountKey = value.AccountKey;
            result.AccessToken = value.AccessToken;
            result.AuthenticationToken = value.AuthenticationToken;

            return result;
        }
    }

    /// <summary>
    /// Account information and domain to associate an <see cref="RemoteRenderingClient"/> instance with.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingClient"/>
    public partial struct SessionConfiguration
    {
        /// <summary>
        /// Domain that will be used for account authentication for the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// The domain is of the form [region].mixedreality.azure.com.
        /// [region] should be set to the location of the Azure Remote Rendering account. For example, eastus.mixedreality.azure.com or westeurope.mixedreality.azure.com.
        /// Legacy mixedreality.azure.com authentication domain is being phased out.
        /// </remarks>
        public string AccountDomain;

        /// <summary>
        /// Domain that will be used to generate sessions for the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// The domain is of the form [region].mixedreality.azure.com.
        /// [region] should be selected based on the region closest to the user. For example, westus2.mixedreality.azure.com or westeurope.mixedreality.azure.com.
        /// </remarks>
        public string RemoteRenderingDomain;

        /// <summary>
        /// The ID of the account that's being used with the Azure Remote Rendering service.
        /// </summary>
        public string AccountId;

        /// <summary>
        /// The key of the account that's being used with the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// Only one of AccountKey, AccessToken or AuthenticationToken needs to be set.
        /// </remarks>
        public string AccountKey;

        /// <summary>
        /// An access token for the account that's being used with the Azure Remote Rendering service.
        /// </summary>
        /// <remarks>
        /// Only one of AccountKey, AccessToken or AuthenticationToken needs to be set.
        /// </remarks>
        public string AccessToken;

        /// <summary>
        /// An authentication token for Azure Active Directory (AAD).
        /// </summary>
        /// <remarks>
        /// Only one of AccountKey, AccessToken or AuthenticationToken needs to be set.
        /// </remarks>
        public string AuthenticationToken;

        internal Microsoft.Azure.RemoteRendering.SessionConfigurationAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.SessionConfiguration.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.SessionConfigurationAbi Convert(Microsoft.Azure.RemoteRendering.SessionConfiguration value)
        {
            Microsoft.Azure.RemoteRendering.SessionConfigurationAbi result = new Microsoft.Azure.RemoteRendering.SessionConfigurationAbi();

            result.AccountDomain = value.AccountDomain;
            result.RemoteRenderingDomain = value.RemoteRenderingDomain;
            result.AccountId = value.AccountId;
            result.AccountKey = value.AccountKey;
            result.AccessToken = value.AccessToken;
            result.AuthenticationToken = value.AuthenticationToken;

            return result;
        }
    }

    /// <summary>
    /// Parameters for connecting to the runtime of an <see cref="RenderingSession"/>.
    /// </summary>
    /// <seealso cref="RenderingSession.Connect(RendererInitOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/sessions">Remote Rendering Sessions</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/rendering-modes">Rendering modes</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RendererInitOptionsAbi
    {
        /// <summary>
        /// Rendering mode to be used.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ServiceRenderMode RenderMode;

        /// <summary>
        /// Internal flag used to ignore SSL certification. Should be set to <c>false</c> (default) for most applications.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)]
        public bool IgnoreCertificateValidation;

        public Microsoft.Azure.RemoteRendering.RendererInitOptions Convert()
        {
            return Microsoft.Azure.RemoteRendering.RendererInitOptionsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RendererInitOptions Convert(Microsoft.Azure.RemoteRendering.RendererInitOptionsAbi value)
        {
            Microsoft.Azure.RemoteRendering.RendererInitOptions result = new Microsoft.Azure.RemoteRendering.RendererInitOptions();

            result.RenderMode = value.RenderMode;
            result.IgnoreCertificateValidation = value.IgnoreCertificateValidation;

            return result;
        }
    }

    /// <summary>
    /// Parameters for connecting to the runtime of an <see cref="RenderingSession"/>.
    /// </summary>
    /// <seealso cref="RenderingSession.Connect(RendererInitOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/sessions">Remote Rendering Sessions</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/rendering-modes">Rendering modes</seealso>
    public partial struct RendererInitOptions
    {
        /// <summary>
        /// Rendering mode to be used.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ServiceRenderMode RenderMode;

        /// <summary>
        /// Internal flag used to ignore SSL certification. Should be set to <c>false</c> (default) for most applications.
        /// </summary>
        public bool IgnoreCertificateValidation;

        internal Microsoft.Azure.RemoteRendering.RendererInitOptionsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RendererInitOptions.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RendererInitOptionsAbi Convert(Microsoft.Azure.RemoteRendering.RendererInitOptions value)
        {
            Microsoft.Azure.RemoteRendering.RendererInitOptionsAbi result = new Microsoft.Azure.RemoteRendering.RendererInitOptionsAbi();

            result.RenderMode = value.RenderMode;
            result.IgnoreCertificateValidation = value.IgnoreCertificateValidation;

            return result;
        }
    }

    /// <summary>
    /// Input parameters for specifying an asset to convert.
    /// </summary>
    /// <seealso cref="AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionInputOptionsAbi
    {
        /// <summary>
        /// The URI of the Azure Blob Storage container containing the input model. Example: "https://contosostorage01.blob.core.windows.net/arrInput"
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string StorageContainerUri;

        /// <summary>
        /// Optional. An Azure Blob Storage container shared access signature (SAS) giving read and list access to the storage container. If not provided, the Azure Remote Rendering account needs to be linked with the storage account containing the blob container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string StorageContainerReadListSas;

        /// <summary>
        /// Only Blobs starting with this prefix will be downloaded to perform the conversion. Example: "models/"
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string BlobPrefix;

        /// <summary>
        /// The relative path starting at blobPrefix (or at the container root if blobPrefix is not specified) to the input model. Must point to file with a supported file format ending. Example: "house.fbx".
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/model-conversion#supported-source-formats">A list of supported file formats</seealso>
        [MarshalAs(UnmanagedType.LPStr)]
        public string RelativeInputAssetPath;

        public Microsoft.Azure.RemoteRendering.AssetConversionInputOptions Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionInputOptionsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionInputOptions Convert(Microsoft.Azure.RemoteRendering.AssetConversionInputOptionsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputOptions result = new Microsoft.Azure.RemoteRendering.AssetConversionInputOptions();

            result.StorageContainerUri = value.StorageContainerUri;
            result.StorageContainerReadListSas = value.StorageContainerReadListSas;
            result.BlobPrefix = value.BlobPrefix;
            result.RelativeInputAssetPath = value.RelativeInputAssetPath;

            return result;
        }
    }

    /// <summary>
    /// Input parameters for specifying an asset to convert.
    /// </summary>
    /// <seealso cref="AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    public partial struct AssetConversionInputOptions
    {
        /// <summary>
        /// The URI of the Azure Blob Storage container containing the input model. Example: "https://contosostorage01.blob.core.windows.net/arrInput"
        /// </summary>
        public string StorageContainerUri;

        /// <summary>
        /// Optional. An Azure Blob Storage container shared access signature (SAS) giving read and list access to the storage container. If not provided, the Azure Remote Rendering account needs to be linked with the storage account containing the blob container.
        /// </summary>
        public string StorageContainerReadListSas;

        /// <summary>
        /// Only Blobs starting with this prefix will be downloaded to perform the conversion. Example: "models/"
        /// </summary>
        public string BlobPrefix;

        /// <summary>
        /// The relative path starting at blobPrefix (or at the container root if blobPrefix is not specified) to the input model. Must point to file with a supported file format ending. Example: "house.fbx".
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/model-conversion#supported-source-formats">A list of supported file formats</seealso>
        public string RelativeInputAssetPath;

        internal Microsoft.Azure.RemoteRendering.AssetConversionInputOptionsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionInputOptions.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionInputOptionsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionInputOptions value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionInputOptionsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionInputOptionsAbi();

            result.StorageContainerUri = value.StorageContainerUri;
            result.StorageContainerReadListSas = value.StorageContainerReadListSas;
            result.BlobPrefix = value.BlobPrefix;
            result.RelativeInputAssetPath = value.RelativeInputAssetPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for specifying the output location of a converted asset.
    /// </summary>
    /// <seealso cref="AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionOutputOptionsAbi
    {
        /// <summary>
        /// The URI of the Azure Blob Storage container where the result of the conversion should be written to. Example: "https://contosostorage01.blob.core.windows.net/arrOutput"
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string StorageContainerUri;

        /// <summary>
        /// Optional. An Azure Blob Storage container shared access signature (SAS) giving write access to the storage container. If not provided, the Azure Remote Rendering account needs to be linked with the storage account containing the blob container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string StorageContainerWriteSas;

        /// <summary>
        /// A prefix which gets prepended in front of all files produced by the conversion process. Will be treated as a virtual folder.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string BlobPrefix;

        /// <summary>
        /// The file name of the output asset. Must end in '.arrAsset'. Example: "house.arrAsset"
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string OutputAssetFilename;

        public Microsoft.Azure.RemoteRendering.AssetConversionOutputOptions Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionOutputOptionsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionOutputOptions Convert(Microsoft.Azure.RemoteRendering.AssetConversionOutputOptionsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionOutputOptions result = new Microsoft.Azure.RemoteRendering.AssetConversionOutputOptions();

            result.StorageContainerUri = value.StorageContainerUri;
            result.StorageContainerWriteSas = value.StorageContainerWriteSas;
            result.BlobPrefix = value.BlobPrefix;
            result.OutputAssetFilename = value.OutputAssetFilename;

            return result;
        }
    }

    /// <summary>
    /// Parameters for specifying the output location of a converted asset.
    /// </summary>
    /// <seealso cref="AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    public partial struct AssetConversionOutputOptions
    {
        /// <summary>
        /// The URI of the Azure Blob Storage container where the result of the conversion should be written to. Example: "https://contosostorage01.blob.core.windows.net/arrOutput"
        /// </summary>
        public string StorageContainerUri;

        /// <summary>
        /// Optional. An Azure Blob Storage container shared access signature (SAS) giving write access to the storage container. If not provided, the Azure Remote Rendering account needs to be linked with the storage account containing the blob container.
        /// </summary>
        public string StorageContainerWriteSas;

        /// <summary>
        /// A prefix which gets prepended in front of all files produced by the conversion process. Will be treated as a virtual folder.
        /// </summary>
        public string BlobPrefix;

        /// <summary>
        /// The file name of the output asset. Must end in '.arrAsset'. Example: "house.arrAsset"
        /// </summary>
        public string OutputAssetFilename;

        internal Microsoft.Azure.RemoteRendering.AssetConversionOutputOptionsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionOutputOptions.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionOutputOptionsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionOutputOptions value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionOutputOptionsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionOutputOptionsAbi();

            result.StorageContainerUri = value.StorageContainerUri;
            result.StorageContainerWriteSas = value.StorageContainerWriteSas;
            result.BlobPrefix = value.BlobPrefix;
            result.OutputAssetFilename = value.OutputAssetFilename;

            return result;
        }
    }

    /// <summary>
    /// Parameters for specifying the output location of a converted asset.
    /// </summary>
    /// <seealso cref="AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct AssetConversionOptionsAbi
    {
        /// <summary>
        /// A unique string that specifies this conversion. Can be left empty to assign a random GUID.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ConversionId;

        /// <summary>
        /// Conversion input options for the source model to convert.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionInputOptionsAbi InputOptions;

        /// <summary>
        /// Conversion output options for the converted target model.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionOutputOptionsAbi OutputOptions;

        public Microsoft.Azure.RemoteRendering.AssetConversionOptions Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionOptionsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.AssetConversionOptions Convert(Microsoft.Azure.RemoteRendering.AssetConversionOptionsAbi value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionOptions result = new Microsoft.Azure.RemoteRendering.AssetConversionOptions();

            result.ConversionId = value.ConversionId;
            result.InputOptions = value.InputOptions.Convert();
            result.OutputOptions = value.OutputOptions.Convert();

            return result;
        }
    }

    /// <summary>
    /// Parameters for specifying the output location of a converted asset.
    /// </summary>
    /// <seealso cref="AssetConversionBlobContainer"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/blob-storage">Use Azure Blob Storage for model conversion</seealso>
    public partial struct AssetConversionOptions
    {
        /// <summary>
        /// A unique string that specifies this conversion. Can be left empty to assign a random GUID.
        /// </summary>
        public string ConversionId;

        /// <summary>
        /// Conversion input options for the source model to convert.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionInputOptions InputOptions;

        /// <summary>
        /// Conversion output options for the converted target model.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.AssetConversionOutputOptions OutputOptions;

        internal Microsoft.Azure.RemoteRendering.AssetConversionOptionsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.AssetConversionOptions.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.AssetConversionOptionsAbi Convert(Microsoft.Azure.RemoteRendering.AssetConversionOptions value)
        {
            Microsoft.Azure.RemoteRendering.AssetConversionOptionsAbi result = new Microsoft.Azure.RemoteRendering.AssetConversionOptionsAbi();

            result.ConversionId = value.ConversionId;
            result.InputOptions = value.InputOptions.Convert();
            result.OutputOptions = value.OutputOptions.Convert();

            return result;
        }
    }

    /// <summary>
    /// Parameters for creating a rendering session.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingClient.CreateNewRenderingSessionAsync(Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/reference/vm-sizes">Server sizes</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RenderingSessionCreationOptionsAbi
    {
        /// <summary>
        /// A new unique ID of a session. Can be left empty to assign a random GUID.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string SessionId;

        /// <summary>
        /// Specifies how long the rendering session should be active before it is shut down.
        /// </summary>
        /// <remarks>
        /// The lease time starts the moment that the rendering server has finished booting.
        /// From that point on, it will be active for the specified lease time, unless it is either manually shut down earlier,
        /// or the lease time is extended beyond the original request.
        /// </remarks>
        public int MaxLeaseInMinutes;

        /// <summary>
        /// On what type of server to create the rendering session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionVmSize Size;

        public Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptions Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptions Convert(Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsAbi value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptions result = new Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptions();

            result.SessionId = value.SessionId;
            result.MaxLeaseInMinutes = value.MaxLeaseInMinutes;
            result.Size = value.Size;

            return result;
        }
    }

    /// <summary>
    /// Parameters for creating a rendering session.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingClient.CreateNewRenderingSessionAsync(Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/reference/vm-sizes">Server sizes</seealso>
    public partial struct RenderingSessionCreationOptions
    {
        /// <summary>
        /// A new unique ID of a session. Can be left empty to assign a random GUID.
        /// </summary>
        public string SessionId;

        /// <summary>
        /// Specifies how long the rendering session should be active before it is shut down.
        /// </summary>
        /// <remarks>
        /// The lease time starts the moment that the rendering server has finished booting.
        /// From that point on, it will be active for the specified lease time, unless it is either manually shut down earlier,
        /// or the lease time is extended beyond the original request.
        /// </remarks>
        public int MaxLeaseInMinutes;

        /// <summary>
        /// On what type of server to create the rendering session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionVmSize Size;

        internal Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptions.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsAbi Convert(Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptions value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsAbi result = new Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsAbi();

            result.SessionId = value.SessionId;
            result.MaxLeaseInMinutes = value.MaxLeaseInMinutes;
            result.Size = value.Size;

            return result;
        }
    }

    /// <summary>
    /// Internal struct.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RenderingSessionCreationOptionsUnsafeAbi
    {
        [MarshalAs(UnmanagedType.LPStr)]
        public string SessionId;

        public int MaxLeaseInMinutes;

        [MarshalAs(UnmanagedType.LPStr)]
        public string Size;

        public Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafe Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafeAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafe Convert(Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafeAbi value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafe result = new Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafe();

            result.SessionId = value.SessionId;
            result.MaxLeaseInMinutes = value.MaxLeaseInMinutes;
            result.Size = value.Size;

            return result;
        }
    }

    /// <summary>
    /// Internal struct.
    /// </summary>
    public partial struct RenderingSessionCreationOptionsUnsafe
    {
        public string SessionId;

        public int MaxLeaseInMinutes;

        public string Size;

        internal Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafeAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafe.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafeAbi Convert(Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafe value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafeAbi result = new Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafeAbi();

            result.SessionId = value.SessionId;
            result.MaxLeaseInMinutes = value.MaxLeaseInMinutes;
            result.Size = value.Size;

            return result;
        }
    }

    /// <summary>
    /// Parameters for updating a rendering session.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession.RenewAsync(Microsoft.Azure.RemoteRendering.RenderingSessionUpdateOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/sessions">Remote Rendering Sessions</seealso>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct RenderingSessionUpdateOptions
    {
        /// <summary>
        /// The new lease time to use for the rendering session.
        /// </summary>
        /// <remarks>
        /// This replaces any previously set lease time. To extend the lease, pass in a larger value than before. You can also shorten the previously requested lease time by passing in a smaller value.
        /// </remarks>
        public int MaxLeaseInMinutes;

    }

    /// <summary>
    /// Extended return value information for <see cref="RenderingSession"/> and <see cref="RemoteRenderingClient"/> async calls.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SessionContextResult"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingClient"/>
    [StructLayout(LayoutKind.Sequential)]
    internal struct SessionGeneralContextAbi
    {
        /// <summary>
        /// See <see cref="Result"/> for details in case of failure.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result Result;

        /// <summary>
        /// HTTP response code.
        /// </summary>
        public uint HttpResponseCode;

        /// <summary>
        /// Depending on the type of error, this string may contain additional information.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ErrorMessage;

        /// <summary>
        /// Request correlation vector, as reported by the service.
        /// </summary>
        /// <remarks>
        /// If you request assistance from the Remote Rendering service team, you may be asked to provide this information, for the team to be able to find all relevant data to debug an issue.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string RequestCorrelationVector;

        /// <summary>
        /// Response correlation vector, as reported by the service.
        /// </summary>
        /// <remarks>
        /// If you request assistance from the Remote Rendering service team, you may be asked to provide this information, for the team to be able to find all relevant data to debug an issue.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ResponseCorrelationVector;

        public Microsoft.Azure.RemoteRendering.SessionGeneralContext Convert()
        {
            return Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.SessionGeneralContext Convert(Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi value)
        {
            Microsoft.Azure.RemoteRendering.SessionGeneralContext result = new Microsoft.Azure.RemoteRendering.SessionGeneralContext();

            result.Result = value.Result;
            result.HttpResponseCode = value.HttpResponseCode;
            result.ErrorMessage = value.ErrorMessage;
            result.RequestCorrelationVector = value.RequestCorrelationVector;
            result.ResponseCorrelationVector = value.ResponseCorrelationVector;

            return result;
        }
    }

    /// <summary>
    /// Extended return value information for <see cref="RenderingSession"/> and <see cref="RemoteRenderingClient"/> async calls.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SessionContextResult"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingClient"/>
    public partial struct SessionGeneralContext
    {
        /// <summary>
        /// See <see cref="Result"/> for details in case of failure.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result Result;

        /// <summary>
        /// HTTP response code.
        /// </summary>
        public uint HttpResponseCode;

        /// <summary>
        /// Depending on the type of error, this string may contain additional information.
        /// </summary>
        public string ErrorMessage;

        /// <summary>
        /// Request correlation vector, as reported by the service.
        /// </summary>
        /// <remarks>
        /// If you request assistance from the Remote Rendering service team, you may be asked to provide this information, for the team to be able to find all relevant data to debug an issue.
        /// </remarks>
        public string RequestCorrelationVector;

        /// <summary>
        /// Response correlation vector, as reported by the service.
        /// </summary>
        /// <remarks>
        /// If you request assistance from the Remote Rendering service team, you may be asked to provide this information, for the team to be able to find all relevant data to debug an issue.
        /// </remarks>
        public string ResponseCorrelationVector;

        internal Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.SessionGeneralContext.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi Convert(Microsoft.Azure.RemoteRendering.SessionGeneralContext value)
        {
            Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi result = new Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi();

            result.Result = value.Result;
            result.HttpResponseCode = value.HttpResponseCode;
            result.ErrorMessage = value.ErrorMessage;
            result.RequestCorrelationVector = value.RequestCorrelationVector;
            result.ResponseCorrelationVector = value.ResponseCorrelationVector;

            return result;
        }
    }

    /// <summary>
    /// Properties of a rendering session.
    /// </summary>
    /// <remarks>
    /// This information can be queried through <see cref="RenderingSession.GetPropertiesAsync"/>.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession.GetPropertiesAsync"/>
    /// <seealso cref="SessionPropertiesAsync"/>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RenderingSessionPropertiesAbi
    {
        /// <summary>
        /// See <see cref="RenderingSessionStatus"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionStatus Status;

        /// <summary>
        /// See <see cref="RenderingSessionVmSize"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionVmSize Size;

        /// <summary>
        /// The name of the host machine on which the session is running.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string Hostname;

        /// <summary>
        /// Session message.
        /// </summary>
        /// <remarks>
        /// If the <see cref="RenderingSessionProperties.Status"/> is <see cref="RenderingSessionStatus.Error"/> or <see cref="RenderingSessionStatus.Expired"/>, the message may contain additional information.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string Message;

        /// <summary>
        /// String representation of the server size.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/reference/vm-sizes">Server sizes</seealso>
        [MarshalAs(UnmanagedType.LPStr)]
        public string SizeString;

        /// <summary>
        /// A string holding a unique ID for the session.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string Id;

        /// <summary>
        /// How long the session has been active (in minutes).
        /// </summary>
        public int ElapsedTimeInMinutes;

        /// <summary>
        /// The currently set lease duration for the session, in minutes. If <see cref="RenderingSessionProperties.ElapsedTimeInMinutes"/> reaches this value, the session will be shut down automatically.
        /// </summary>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession.RenewAsync(Microsoft.Azure.RemoteRendering.RenderingSessionUpdateOptions)"/>
        public int MaxLeaseInMinutes;

        /// <summary>
        /// Session handshake port.
        /// </summary>
        public int HandshakePort;

        /// <summary>
        /// ArrInspector port.
        /// </summary>
        public int ArrInspectorPort;

        public Microsoft.Azure.RemoteRendering.RenderingSessionProperties Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RenderingSessionProperties Convert(Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionProperties result = new Microsoft.Azure.RemoteRendering.RenderingSessionProperties();

            result.Status = value.Status;
            result.Size = value.Size;
            result.Hostname = value.Hostname;
            result.Message = value.Message;
            result.SizeString = value.SizeString;
            result.Id = value.Id;
            result.ElapsedTimeInMinutes = value.ElapsedTimeInMinutes;
            result.MaxLeaseInMinutes = value.MaxLeaseInMinutes;
            result.HandshakePort = value.HandshakePort;
            result.ArrInspectorPort = value.ArrInspectorPort;

            return result;
        }
    }

    /// <summary>
    /// Properties of a rendering session.
    /// </summary>
    /// <remarks>
    /// This information can be queried through <see cref="RenderingSession.GetPropertiesAsync"/>.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession.GetPropertiesAsync"/>
    /// <seealso cref="SessionPropertiesAsync"/>
    public partial struct RenderingSessionProperties
    {
        /// <summary>
        /// See <see cref="RenderingSessionStatus"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionStatus Status;

        /// <summary>
        /// See <see cref="RenderingSessionVmSize"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RenderingSessionVmSize Size;

        /// <summary>
        /// The name of the host machine on which the session is running.
        /// </summary>
        public string Hostname;

        /// <summary>
        /// Session message.
        /// </summary>
        /// <remarks>
        /// If the <see cref="RenderingSessionProperties.Status"/> is <see cref="RenderingSessionStatus.Error"/> or <see cref="RenderingSessionStatus.Expired"/>, the message may contain additional information.
        /// </remarks>
        public string Message;

        /// <summary>
        /// String representation of the server size.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/reference/vm-sizes">Server sizes</seealso>
        public string SizeString;

        /// <summary>
        /// A string holding a unique ID for the session.
        /// </summary>
        public string Id;

        /// <summary>
        /// How long the session has been active (in minutes).
        /// </summary>
        public int ElapsedTimeInMinutes;

        /// <summary>
        /// The currently set lease duration for the session, in minutes. If <see cref="RenderingSessionProperties.ElapsedTimeInMinutes"/> reaches this value, the session will be shut down automatically.
        /// </summary>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession.RenewAsync(Microsoft.Azure.RemoteRendering.RenderingSessionUpdateOptions)"/>
        public int MaxLeaseInMinutes;

        /// <summary>
        /// Session handshake port.
        /// </summary>
        public int HandshakePort;

        /// <summary>
        /// ArrInspector port.
        /// </summary>
        public int ArrInspectorPort;

        internal Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RenderingSessionProperties.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi Convert(Microsoft.Azure.RemoteRendering.RenderingSessionProperties value)
        {
            Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi result = new Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi();

            result.Status = value.Status;
            result.Size = value.Size;
            result.Hostname = value.Hostname;
            result.Message = value.Message;
            result.SizeString = value.SizeString;
            result.Id = value.Id;
            result.ElapsedTimeInMinutes = value.ElapsedTimeInMinutes;
            result.MaxLeaseInMinutes = value.MaxLeaseInMinutes;
            result.HandshakePort = value.HandshakePort;
            result.ArrInspectorPort = value.ArrInspectorPort;

            return result;
        }
    }

    /// <summary>
    /// Properties of an asset conversion.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct ConversionPropertiesAbi
    {
        /// <summary>
        /// The ID of the conversion supplied when the conversion was created.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string Id;

        /// <summary>
        /// The status of the conversion.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ConversionStatus Status;

        /// <summary>
        /// The time when the conversion was created. Date and time in ISO 8601 format.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string CreationTime;

        /// <summary>
        /// In case of an error, this may contain additional information.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ErrorMessage;

        /// <summary>
        /// The URI of the Azure blob storage container containing the input model.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string InputStorageContainerUri;

        /// <summary>
        /// Only Blobs starting with this prefix are downloaded to perform the conversion.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string InputBlobPrefix;

        /// <summary>
        /// The relative path starting at blobPrefix (or at the container root if blobPrefix is not provided) to the input model.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string InputRelativeAssetPath;

        /// <summary>
        /// The URI of the Azure blob storage container where the result of the conversion should be written to.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string OutputStorageContainerUri;

        /// <summary>
        /// A prefix which gets prepended in front of all files produced by the conversion process. Will be treated as a virtual folder.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string OutputBlobPrefix;

        /// <summary>
        /// The file name of the output asset.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string OutputAssetFilename;

        /// <summary>
        /// URI of the asset generated by the conversion process (once it has finished successfully).
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string OutputAssetUri;

        public Microsoft.Azure.RemoteRendering.ConversionProperties Convert()
        {
            return Microsoft.Azure.RemoteRendering.ConversionPropertiesAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.ConversionProperties Convert(Microsoft.Azure.RemoteRendering.ConversionPropertiesAbi value)
        {
            Microsoft.Azure.RemoteRendering.ConversionProperties result = new Microsoft.Azure.RemoteRendering.ConversionProperties();

            result.Id = value.Id;
            result.Status = value.Status;
            result.CreationTime = value.CreationTime;
            result.ErrorMessage = value.ErrorMessage;
            result.InputStorageContainerUri = value.InputStorageContainerUri;
            result.InputBlobPrefix = value.InputBlobPrefix;
            result.InputRelativeAssetPath = value.InputRelativeAssetPath;
            result.OutputStorageContainerUri = value.OutputStorageContainerUri;
            result.OutputBlobPrefix = value.OutputBlobPrefix;
            result.OutputAssetFilename = value.OutputAssetFilename;
            result.OutputAssetUri = value.OutputAssetUri;

            return result;
        }
    }

    /// <summary>
    /// Properties of an asset conversion.
    /// </summary>
    public partial struct ConversionProperties
    {
        /// <summary>
        /// The ID of the conversion supplied when the conversion was created.
        /// </summary>
        public string Id;

        /// <summary>
        /// The status of the conversion.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ConversionStatus Status;

        /// <summary>
        /// The time when the conversion was created. Date and time in ISO 8601 format.
        /// </summary>
        public string CreationTime;

        /// <summary>
        /// In case of an error, this may contain additional information.
        /// </summary>
        public string ErrorMessage;

        /// <summary>
        /// The URI of the Azure blob storage container containing the input model.
        /// </summary>
        public string InputStorageContainerUri;

        /// <summary>
        /// Only Blobs starting with this prefix are downloaded to perform the conversion.
        /// </summary>
        public string InputBlobPrefix;

        /// <summary>
        /// The relative path starting at blobPrefix (or at the container root if blobPrefix is not provided) to the input model.
        /// </summary>
        public string InputRelativeAssetPath;

        /// <summary>
        /// The URI of the Azure blob storage container where the result of the conversion should be written to.
        /// </summary>
        public string OutputStorageContainerUri;

        /// <summary>
        /// A prefix which gets prepended in front of all files produced by the conversion process. Will be treated as a virtual folder.
        /// </summary>
        public string OutputBlobPrefix;

        /// <summary>
        /// The file name of the output asset.
        /// </summary>
        public string OutputAssetFilename;

        /// <summary>
        /// URI of the asset generated by the conversion process (once it has finished successfully).
        /// </summary>
        public string OutputAssetUri;

        internal Microsoft.Azure.RemoteRendering.ConversionPropertiesAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.ConversionProperties.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.ConversionPropertiesAbi Convert(Microsoft.Azure.RemoteRendering.ConversionProperties value)
        {
            Microsoft.Azure.RemoteRendering.ConversionPropertiesAbi result = new Microsoft.Azure.RemoteRendering.ConversionPropertiesAbi();

            result.Id = value.Id;
            result.Status = value.Status;
            result.CreationTime = value.CreationTime;
            result.ErrorMessage = value.ErrorMessage;
            result.InputStorageContainerUri = value.InputStorageContainerUri;
            result.InputBlobPrefix = value.InputBlobPrefix;
            result.InputRelativeAssetPath = value.InputRelativeAssetPath;
            result.OutputStorageContainerUri = value.OutputStorageContainerUri;
            result.OutputBlobPrefix = value.OutputBlobPrefix;
            result.OutputAssetFilename = value.OutputAssetFilename;
            result.OutputAssetUri = value.OutputAssetUri;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading data from Azure blob storage.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelOptions)"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureOptions)"/>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadFromBlobOptionsAbi
    {
        /// <summary>
        /// Name of the Azure Storage account to load data from.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string StorageAccountName;

        /// <summary>
        /// Name of the blob container in the storage account.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string BlobContainerName;

        /// <summary>
        /// Path to the asset inside the blob container.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string AssetPath;

        public Microsoft.Azure.RemoteRendering.LoadFromBlobOptions Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadFromBlobOptionsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadFromBlobOptions Convert(Microsoft.Azure.RemoteRendering.LoadFromBlobOptionsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadFromBlobOptions result = new Microsoft.Azure.RemoteRendering.LoadFromBlobOptions();

            result.StorageAccountName = value.StorageAccountName;
            result.BlobContainerName = value.BlobContainerName;
            result.AssetPath = value.AssetPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading data from Azure blob storage.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelOptions)"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureOptions)"/>
    public partial struct LoadFromBlobOptions
    {
        /// <summary>
        /// Name of the Azure Storage account to load data from.
        /// </summary>
        public string StorageAccountName;

        /// <summary>
        /// Name of the blob container in the storage account.
        /// </summary>
        public string BlobContainerName;

        /// <summary>
        /// Path to the asset inside the blob container.
        /// </summary>
        public string AssetPath;

        internal Microsoft.Azure.RemoteRendering.LoadFromBlobOptionsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadFromBlobOptions.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadFromBlobOptionsAbi Convert(Microsoft.Azure.RemoteRendering.LoadFromBlobOptions value)
        {
            Microsoft.Azure.RemoteRendering.LoadFromBlobOptionsAbi result = new Microsoft.Azure.RemoteRendering.LoadFromBlobOptionsAbi();

            result.StorageAccountName = value.StorageAccountName;
            result.BlobContainerName = value.BlobContainerName;
            result.AssetPath = value.AssetPath;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a model using a URI.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadModelFromSasAsync(Microsoft.Azure.RemoteRendering.LoadModelFromSasOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadModelFromSasOptionsAbi
    {
        /// <summary>
        /// URI to the model.
        /// </summary>
        /// <remarks>
        /// Either 'builtin://xyz' or a URI pointing to a converted model. Both raw (public) URIs to blob store and URIs with embedded SAS tokens to blob store are supported.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ModelUri;

        /// <summary>
        /// Optional parent <see cref="Entity"/> for the model.
        /// </summary>
        /// <remarks>
        /// If not null, the loaded model will be attached to Parent as a child object.
        /// Otherwise, it will become a top level entity.
        /// </remarks>
        public ulong Parent;

        public Microsoft.Azure.RemoteRendering.LoadModelFromSasOptions Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadModelFromSasOptionsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadModelFromSasOptions Convert(Microsoft.Azure.RemoteRendering.LoadModelFromSasOptionsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadModelFromSasOptions result = new Microsoft.Azure.RemoteRendering.LoadModelFromSasOptions();

            result.ModelUri = value.ModelUri;
            result.Parent = value.Parent != default(ulong) ? new Microsoft.Azure.RemoteRendering.Entity(value.Parent, false) : null;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a model using a URI.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadModelFromSasAsync(Microsoft.Azure.RemoteRendering.LoadModelFromSasOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
    public partial struct LoadModelFromSasOptions
    {
        /// <summary>
        /// URI to the model.
        /// </summary>
        /// <remarks>
        /// Either 'builtin://xyz' or a URI pointing to a converted model. Both raw (public) URIs to blob store and URIs with embedded SAS tokens to blob store are supported.
        /// </remarks>
        public string ModelUri;

        /// <summary>
        /// Optional parent <see cref="Entity"/> for the model.
        /// </summary>
        /// <remarks>
        /// If not null, the loaded model will be attached to Parent as a child object.
        /// Otherwise, it will become a top level entity.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Entity Parent;

        internal Microsoft.Azure.RemoteRendering.LoadModelFromSasOptionsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadModelFromSasOptions.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadModelFromSasOptionsAbi Convert(Microsoft.Azure.RemoteRendering.LoadModelFromSasOptions value)
        {
            Microsoft.Azure.RemoteRendering.LoadModelFromSasOptionsAbi result = new Microsoft.Azure.RemoteRendering.LoadModelFromSasOptionsAbi();

            result.ModelUri = value.ModelUri;
            result.Parent = value.Parent?.handle ?? default(ulong);

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a model from Azure blob storage.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadModelOptionsAbi
    {
        /// <summary>
        /// See <see cref="LoadFromBlobOptions"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadFromBlobOptionsAbi Blob;

        /// <summary>
        /// Optional parent <see cref="Entity"/> for the model.
        /// </summary>
        /// <remarks>
        /// If not null, the loaded model will be attached to Parent as a child object.
        /// Otherwise, it will become a top level entity.
        /// </remarks>
        public ulong Parent;

        public Microsoft.Azure.RemoteRendering.LoadModelOptions Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadModelOptionsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadModelOptions Convert(Microsoft.Azure.RemoteRendering.LoadModelOptionsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadModelOptions result = new Microsoft.Azure.RemoteRendering.LoadModelOptions();

            result.Blob = value.Blob.Convert();
            result.Parent = value.Parent != default(ulong) ? new Microsoft.Azure.RemoteRendering.Entity(value.Parent, false) : null;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a model from Azure blob storage.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
    public partial struct LoadModelOptions
    {
        /// <summary>
        /// See <see cref="LoadFromBlobOptions"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadFromBlobOptions Blob;

        /// <summary>
        /// Optional parent <see cref="Entity"/> for the model.
        /// </summary>
        /// <remarks>
        /// If not null, the loaded model will be attached to Parent as a child object.
        /// Otherwise, it will become a top level entity.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Entity Parent;

        internal Microsoft.Azure.RemoteRendering.LoadModelOptionsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadModelOptions.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadModelOptionsAbi Convert(Microsoft.Azure.RemoteRendering.LoadModelOptions value)
        {
            Microsoft.Azure.RemoteRendering.LoadModelOptionsAbi result = new Microsoft.Azure.RemoteRendering.LoadModelOptionsAbi();

            result.Blob = value.Blob.Convert();
            result.Parent = value.Parent?.handle ?? default(ulong);

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a texture using a URI.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadTextureFromSasAsync(Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadTextureFromSasOptionsAbi
    {
        /// <summary>
        /// URI to the texture.
        /// </summary>
        /// <remarks>
        /// Either 'builtin://xyz' or a URI pointing to a texture. Both raw (public) URIs to blob store and URIs with embedded SAS tokens to blob store are supported.
        /// </remarks>
        [MarshalAs(UnmanagedType.LPStr)]
        public string TextureUri;

        /// <summary>
        /// The expected texture type.
        /// </summary>
        /// <remarks>
        /// This has to match the data that is stored in the referenced file.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.TextureType TextureType;

        public Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptions Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptionsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptions Convert(Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptionsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptions result = new Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptions();

            result.TextureUri = value.TextureUri;
            result.TextureType = value.TextureType;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a texture using a URI.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadTextureFromSasAsync(Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures</seealso>
    public partial struct LoadTextureFromSasOptions
    {
        /// <summary>
        /// URI to the texture.
        /// </summary>
        /// <remarks>
        /// Either 'builtin://xyz' or a URI pointing to a texture. Both raw (public) URIs to blob store and URIs with embedded SAS tokens to blob store are supported.
        /// </remarks>
        public string TextureUri;

        /// <summary>
        /// The expected texture type.
        /// </summary>
        /// <remarks>
        /// This has to match the data that is stored in the referenced file.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.TextureType TextureType;

        internal Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptionsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptions.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptionsAbi Convert(Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptions value)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptionsAbi result = new Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptionsAbi();

            result.TextureUri = value.TextureUri;
            result.TextureType = value.TextureType;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a texture.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures</seealso>
    [StructLayout(LayoutKind.Sequential)]
    internal struct LoadTextureOptionsAbi
    {
        /// <summary>
        /// See <see cref="LoadFromBlobOptions"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadFromBlobOptionsAbi Blob;

        /// <summary>
        /// The expected texture type.
        /// </summary>
        /// <remarks>
        /// This has to match the data that is stored in the referenced file.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.TextureType TextureType;

        public Microsoft.Azure.RemoteRendering.LoadTextureOptions Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadTextureOptionsAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.LoadTextureOptions Convert(Microsoft.Azure.RemoteRendering.LoadTextureOptionsAbi value)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureOptions result = new Microsoft.Azure.RemoteRendering.LoadTextureOptions();

            result.Blob = value.Blob.Convert();
            result.TextureType = value.TextureType;

            return result;
        }
    }

    /// <summary>
    /// Parameters for loading a texture.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures</seealso>
    public partial struct LoadTextureOptions
    {
        /// <summary>
        /// See <see cref="LoadFromBlobOptions"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LoadFromBlobOptions Blob;

        /// <summary>
        /// The expected texture type.
        /// </summary>
        /// <remarks>
        /// This has to match the data that is stored in the referenced file.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.TextureType TextureType;

        internal Microsoft.Azure.RemoteRendering.LoadTextureOptionsAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.LoadTextureOptions.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.LoadTextureOptionsAbi Convert(Microsoft.Azure.RemoteRendering.LoadTextureOptions value)
        {
            Microsoft.Azure.RemoteRendering.LoadTextureOptionsAbi result = new Microsoft.Azure.RemoteRendering.LoadTextureOptionsAbi();

            result.Blob = value.Blob.Convert();
            result.TextureType = value.TextureType;

            return result;
        }
    }

    /// <summary>
    /// Options for Remote Rendering runtime initialization.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct RemoteRenderingInitializationAbi
    {
        /// <summary>
        /// Selects the <see cref="RemoteRenderingInitialization.ConnectionType">connection type</see> for this session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ConnectionType ConnectionType;

        /// <summary>
        /// Selects the <see cref="GraphicsApiType">graphics binding</see> for rendering.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.GraphicsApiType GraphicsApi;

        /// <summary>
        /// Right vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis Right;

        /// <summary>
        /// Up vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis Up;

        /// <summary>
        /// Forward vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis Forward;

        /// <summary>
        /// How many units in the client's coordinate system make up one meter.
        /// </summary>
        public float UnitsPerMeter;

        /// <summary>
        /// The name (and version) of the client tool.
        /// </summary>
        [MarshalAs(UnmanagedType.LPStr)]
        public string ToolId;

        public Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization Convert()
        {
            return Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi.Convert(this);
        }

        public static Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization Convert(Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi value)
        {
            Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization result = new Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization();

            result.ConnectionType = value.ConnectionType;
            result.GraphicsApi = value.GraphicsApi;
            result.Right = value.Right;
            result.Up = value.Up;
            result.Forward = value.Forward;
            result.UnitsPerMeter = value.UnitsPerMeter;
            result.ToolId = value.ToolId;

            return result;
        }
    }

    /// <summary>
    /// Options for Remote Rendering runtime initialization.
    /// </summary>
    public partial struct RemoteRenderingInitialization
    {
        /// <summary>
        /// Selects the <see cref="RemoteRenderingInitialization.ConnectionType">connection type</see> for this session.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ConnectionType ConnectionType;

        /// <summary>
        /// Selects the <see cref="GraphicsApiType">graphics binding</see> for rendering.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.GraphicsApiType GraphicsApi;

        /// <summary>
        /// Right vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis Right;

        /// <summary>
        /// Up vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis Up;

        /// <summary>
        /// Forward vector direction in the client's coordinate system.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Axis Forward;

        /// <summary>
        /// How many units in the client's coordinate system make up one meter.
        /// </summary>
        public float UnitsPerMeter;

        /// <summary>
        /// The name (and version) of the client tool.
        /// </summary>
        public string ToolId;

        internal Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi Convert()
        {
            return Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization.Convert(this);
        }

        internal static Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi Convert(Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization value)
        {
            Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi result = new Microsoft.Azure.RemoteRendering.RemoteRenderingInitializationAbi();

            result.ConnectionType = value.ConnectionType;
            result.GraphicsApi = value.GraphicsApi;
            result.Right = value.Right;
            result.Up = value.Up;
            result.Forward = value.Forward;
            result.UnitsPerMeter = value.UnitsPerMeter;
            result.ToolId = value.ToolId;

            return result;
        }
    }

    /// <summary>
    /// Generic result type used by the Remote Rendering API.
    /// </summary>
    public enum Result : int
    {
        /// <summary>
        /// Internal: Start of the range of core result values.
        /// </summary>
        CoreReturnValueStart = -1,
        /// <summary>
        /// Operation completed successfully.
        /// </summary>
        Success = 0,
        /// <summary>
        /// General failure.
        /// </summary>
        Fail = 1,
        /// <summary>
        /// The user canceled the operation.
        /// </summary>
        Cancelled = 2,
        /// <summary>
        /// Incorrect user input for the operation.
        /// </summary>
        InvalidParam = 3,
        /// <summary>
        /// An object with incorrect type was passed in.
        /// </summary>
        InvalidType = 4,
        /// <summary>
        /// Not used.
        /// </summary>
        BufferTooSmall_Deprecated = 5,
        /// <summary>
        /// Operation requires an active connection.
        /// </summary>
        /// <remarks>
        /// If the connection to the server has been lost, this error can occur for most operations,
        /// since only few operations are possible without a connection.
        /// </remarks>
        NoConnection = 6,
        /// <summary>
        /// Internal.
        /// </summary>
        ApiUnavailable = 7,
        /// <summary>
        /// Static initialization of remote rendering has been called multiple times.
        /// </summary>
        AlreadyInitialized = 8,
        /// <summary>
        /// Static de-initialization of remote rendering has already been performed.
        /// </summary>
        AlreadyDeinitialized = 9,
        /// <summary>
        /// The string passed into the API is longer than allowed.
        /// </summary>
        StringTooLong = 10,
        /// <summary>
        /// The index passed into the API is outside the valid range.
        /// </summary>
        IndexOutOfRange = 11,
        /// <summary>
        /// An async operation has not yet finished.
        /// </summary>
        InProgress = 12,
        /// <summary>
        /// Static initialization of remote rendering hasn't been done yet.
        /// </summary>
        NotInitialized = 13,
        /// <summary>
        /// The string passed into the API is not valid.
        /// </summary>
        StringNotValidUtf8 = 14,
        /// <summary>
        /// An operation is not supported on the target platform.
        /// </summary>
        NotSupported = 15,
        /// <summary>
        /// Internal: Last used value of the range of core result values.
        /// </summary>
        CoreReturnValueLast = 16,
        /// <summary>
        /// Internal: Maximum value of the range of core result values.
        /// </summary>
        CoreReturnValueEnd = 200,
        /// <summary>
        /// Internal: Start of the range of file load result values.
        /// </summary>
        LoadFileReturnValueStart = 299,
        /// <summary>
        /// The requested file did not exist.
        /// </summary>
        FileNotFound = 300,
        /// <summary>
        /// The requested file is either corrupt or uses an old version that is not supported anymore.
        /// </summary>
        InvalidVersion = 301,
        /// <summary>
        /// Not used.
        /// </summary>
        IncompatibleVersion_Deprecated = 302,
        /// <summary>
        /// The requested file is either corrupt or not recognized.
        /// </summary>
        FailedToOpenFile = 303,
        /// <summary>
        /// Downloading the file from the provided URI failed.
        /// </summary>
        FileDownloadFailed = 304,
        /// <summary>
        /// Loading this model would exceed GPU memory limits. Request a larger server, or reduce the amount of loaded models.
        /// </summary>
        ExceedsMemoryLimit = 305,
        /// <summary>
        /// The target file cannot be written
        /// </summary>
        CannotWriteTargetFile = 306,
        /// <summary>
        /// The target file is corrupt or in an unsupported format
        /// </summary>
        FileCorrupt = 307,
        /// <summary>
        /// Internal: Uploading the file to the provided URI failed.
        /// </summary>
        FileUploadFailed = 308,
        /// <summary>
        /// Internal: Files can only be up/downloaded from OneDrive or Azure Blob Storage.
        /// </summary>
        UnsupportedFileProvider = 309,
        /// <summary>
        /// Internal: Last used value of the range of file load result values.
        /// </summary>
        LoadFileReturnValueLast = 310,
        /// <summary>
        /// Internal: Maximum value of the range of file load result values.
        /// </summary>
        LoadFileReturnValueEnd = 500,
        /// <summary>
        /// Internal: Start of the range of object result values.
        /// </summary>
        ObjectReturnValueStart = 599,
        /// <summary>
        /// The provided object ID is not valid (anymore).
        /// </summary>
        InvalidId = 600,
        /// <summary>
        /// The parent entity with the provided ID does not exist.
        /// </summary>
        InvalidParentId = 601,
        /// <summary>
        /// An object of the same type already exists on the target.
        /// </summary>
        AlreadyExists = 602,
        /// <summary>
        /// Re-parenting this entity to the target entity would create a cycle in the entity hierarchy.
        /// </summary>
        CyclicReference = 603,
        /// <summary>
        /// Not used.
        /// </summary>
        ObjectLocked_Deprecated = 604,
        /// <summary>
        /// Tried to transform or re-parent an object that is part of a static scene graph. See 'SceneGraphMode=static' model conversion option.
        /// </summary>
        ObjectStatic = 605,
        /// <summary>
        /// Tried to add a component, but the maximum number of this component was already present.
        /// </summary>
        ComponentLimitReached = 606,
        /// <summary>
        /// Internal: Last used value of the range of object result values.
        /// </summary>
        ObjectReturnValueLast = 607,
        /// <summary>
        /// Internal: Maximum value of the range of object result values.
        /// </summary>
        ObjectReturnValueEnd = 800,
        /// <summary>
        /// Internal: Start of the range of connection result values.
        /// </summary>
        ConnectionReturnValueStart = 899,
        /// <summary>
        /// Internal: Secure connection enabled, but certificate was missing, invalid, or not usable.
        /// </summary>
        NoServerCertificate = 900,
        /// <summary>
        /// Internal: Handshake port could not be opened for accepting connections.
        /// </summary>
        HandshakePortBusy = 901,
        /// <summary>
        /// Handshake server is unreachable.
        /// </summary>
        HandshakeUnreachable = 902,
        /// <summary>
        /// Handshake server closed the connection prematurely; likely due to TLS/Plain mismatch or invalid certificate.
        /// </summary>
        HandshakeConnectionFailed = 903,
        /// <summary>
        /// Authentication with the handshake server failed.
        /// </summary>
        AuthenticationFailed = 904,
        /// <summary>
        /// No common compatible remoting version could be determined during handshake.
        /// </summary>
        RemotingVersionMismatch = 905,
        /// <summary>
        /// No common transport protocol could be determined during handshake.
        /// </summary>
        IncompatibleTransportProtocols = 906,
        /// <summary>
        /// Handshake failed. Reason not further specified.
        /// </summary>
        HandshakeFailed = 907,
        /// <summary>
        /// Internal: Transport port could not be opened for accepting connections.
        /// </summary>
        TransportPortBusy = 908,
        /// <summary>
        /// Transport server is unreachable.
        /// </summary>
        TransportUnreachable = 909,
        /// <summary>
        /// Transport connection was closed before all communication channels had been set up.
        /// </summary>
        TransportConnectionFailed = 910,
        /// <summary>
        /// Transport connection was closed due to protocol version mismatch.
        /// </summary>
        ProtocolVersionMismatch = 911,
        /// <summary>
        /// A protocol error occurred that was severe enough to invalidate the current connection or connection attempt.
        /// </summary>
        ProtocolError = 912,
        /// <summary>
        /// Transport connection was closed due to the requested video codec not being available.
        /// </summary>
        VideoCodecNotAvailable = 913,
        /// <summary>
        /// Connection has been closed by peer.
        /// </summary>
        ConnectionLost = 914,
        /// <summary>
        /// Connection has been closed due to graphics device loss.
        /// </summary>
        DeviceLost = 915,
        /// <summary>
        /// Connection has been closed by request.
        /// </summary>
        DisconnectRequest = 916,
        /// <summary>
        /// Internal.
        /// </summary>
        Timeout = 917,
        /// <summary>
        /// A connection has been established before.
        /// </summary>
        AlreadyConnected = 918,
        /// <summary>
        /// The client SDK version is not supported anymore. Please update.
        /// </summary>
        ArrVersionMismatch = 919,
        /// <summary>
        /// Network is unreachable. This usually means the client knows no route to reach the remote host.
        /// </summary>
        HandshakeNetworkUnreachable = 920,
        /// <summary>
        /// No connection could be made because the remote side actively refused it. Usually this means that no host application is running.
        /// </summary>
        HandshakeConnectionRefused = 921,
        /// <summary>
        /// Transport connection was closed due to the requested video format not being available.
        /// </summary>
        VideoFormatNotAvailable = 922,
        /// <summary>
        /// Disconnecting after receiving a disconnect request from the peer.
        /// </summary>
        PeerDisconnectRequest = 923,
        /// <summary>
        /// Timed out while waiting for peer to close connection.
        /// </summary>
        PeerDisconnectTimeout = 924,
        /// <summary>
        /// Timed out while waiting for transport session to be opened.
        /// </summary>
        SessionOpenTimeout = 925,
        /// <summary>
        /// Timed out while waiting for the remoting handshake to complete.
        /// </summary>
        RemotingHandshakeTimeout = 926,
        /// <summary>
        /// Connection failed due to an internal error.
        /// </summary>
        InternalError = 927,
        /// <summary>
        /// Internal: Last used value of the range of connection result values.
        /// </summary>
        ConnectionReturnValueLast = 928,
        /// <summary>
        /// Internal: Maximum value of the range of connection result values.
        /// </summary>
        ConnectionReturnValueEnd = 1100,
        /// <summary>
        /// Internal: Start of the range of manager result values.
        /// </summary>
        ManagerReturnValueStart = 1199,
        /// <summary>
        /// Internal: Invalid tool ID.
        /// </summary>
        InvalidToolId = 1200,
        /// <summary>
        /// The remote rendering manager has already been created.
        /// </summary>
        ManagerAlreadyCreated = 1201,
        /// <summary>
        /// The remote rendering manager has not been created yet.
        /// </summary>
        ManagerNotCreatedYet = 1202,
        /// <summary>
        /// Another session is already connected to this runtime.
        /// </summary>
        OtherSessionConnected = 1203,
        /// <summary>
        /// Internal.
        /// </summary>
        BadStateTransition = 1204,
        /// <summary>
        /// An internal tool failed to start
        /// </summary>
        FailedToStartTool = 1205,
        /// <summary>
        /// Internal: Insufficient number of slots in Frontend.
        /// </summary>
        InsufficientSlots = 1206,
        /// <summary>
        /// PrepareRender has not been called before BlitRemoteFrame.
        /// </summary>
        PrepareRenderNotCalled = 1207,
        /// <summary>
        /// Internal: Last used value of the range of manager result values.
        /// </summary>
        ManagerReturnValueLast = 1208,
        /// <summary>
        /// Internal: Maximum value of the range of manager result values.
        /// </summary>
        ManagerReturnValueEnd = 1400,
        /// <summary>
        /// Internal: Start of the range of session result values.
        /// </summary>
        SessionReturnValueStart = 1499,
        /// <summary>
        /// The secure connection failed. Check the account settings.
        /// </summary>
        InvalidToken = 1500,
        /// <summary>
        /// The user provided URI is malformed.
        /// </summary>
        InvalidUri = 1501,
        /// <summary>
        /// The session to the user provided session Id could not be found.
        /// </summary>
        SessionNotFound = 1502,
        /// <summary>
        /// Internal: The rate limit has been exceeded. Retry the request after the duration given in the Retry-After header.
        /// </summary>
        TooManyRequests = 1503,
        /// <summary>
        /// Internal: Last used value of the range of session result values.
        /// </summary>
        SessionReturnValueLast = 1504,
        /// <summary>
        /// Internal: Maximum value of the range of session result values.
        /// </summary>
        SessionReturnValueEnd = 1700,
    }

    /// <summary>
    /// Supported graphics APIs.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBinding"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingSimD3d11"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingWmrD3d11"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingOpenXrD3d11"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/graphics-bindings">Graphics binding (Remote Rendering docs)</seealso>
    public enum GraphicsApiType : int
    {
        /// <summary>
        /// Disables the graphics interface (headless mode).
        /// </summary>
        Headless = 0,
        /// <summary>
        /// Creates a graphics binding for local simulation (monoscopic rendering, typically in editor).
        /// </summary>
        SimD3D11 = 1,
        /// <summary>
        /// Creates a graphics binding for Windows Mixed Reality. This must be used when working on a HoloLens device.
        /// </summary>
        WmrD3D11 = 2,
        /// <summary>
        /// Creates a graphics binding for OpenXR. This must be used when working on a HoloLens device using the OpenXR API.
        /// </summary>
        OpenXrD3D11 = 3,
        /// <summary>
        /// internal
        /// </summary>
        Count = 4,
    }

    /// <summary>
    /// Supported material types.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.CreateMaterial(Microsoft.Azure.RemoteRendering.MaterialType)"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Material"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PbrMaterial"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ColorMaterial"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/materials">Materials (Remote Rendering docs)</seealso>
    public enum MaterialType : int
    {
        /// <summary>
        /// Physically-Based Rendering (PBR)
        /// </summary>
        /// <remarks>
        /// PBR materials support lighting and advanced properties such as roughness and metalness.
        /// </remarks>
        Pbr = 0,
        /// <summary>
        /// A fixed color material, optionally multiplied with a texture.
        /// </summary>
        /// <remarks>
        /// This material receives no lighting, it is always fully bright.
        /// </remarks>
        Color = 1,
    }

    /// <summary>
    /// Logging severity levels.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LogLevel"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingClient.LogLevel"/>
    public enum LogLevel : int
    {
        /// <summary>
        /// Used to disable logging.
        /// </summary>
        None = 0,
        /// <summary>
        /// The log message represents an error.
        /// </summary>
        Error = 1,
        /// <summary>
        /// The log message represents a warning.
        /// </summary>
        Warning = 2,
        /// <summary>
        /// The log message represents somewhat important information.
        /// </summary>
        Information = 3,
        /// <summary>
        /// The log message represents verbose information typically only useful for debugging.
        /// </summary>
        Debug = 4,
        /// <summary>
        /// internal
        /// </summary>
        Count = 5,
    }

    /// <summary>
    /// Coordinate system axis definitions.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.CutPlaneComponent"/>
    public enum Axis : int
    {
        /// <summary>
        /// Positive X axis
        /// </summary>
        X = 0,
        /// <summary>
        /// Negative X axis
        /// </summary>
        NegativeX = 1,
        /// <summary>
        /// Positive Y axis
        /// </summary>
        Y = 2,
        /// <summary>
        /// Negative Y axis
        /// </summary>
        NegativeY = 3,
        /// <summary>
        /// Positive Z axis
        /// </summary>
        Z = 4,
        /// <summary>
        /// Negative Z axis
        /// </summary>
        NegativeZ = 5,
    }

    /// <summary>
    /// The state of the remote focus point in the current frame.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBinding"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/late-stage-reprojection">Late stage reprojection</seealso>
    public enum FocusPointResult : int
    {
        /// <summary>
        /// No valid focus point data available.
        /// </summary>
        Invalid = 0,
        /// <summary>
        /// The data is valid but has been computed through a fallback.
        /// </summary>
        Fallback = 1,
        /// <summary>
        /// The data represents a valid focus point.
        /// </summary>
        Valid = 2,
    }

    /// <summary>
    /// Options for rendering single-sided geometry.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SingleSidedSettings"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/single-sided-rendering">Single-sided rendering</seealso>
    public enum SingleSidedMode : int
    {
        /// <summary>
        /// Back faces of single-sided geometry will be invisible.
        /// </summary>
        /// <remarks>
        /// When moving the viewpoint inside single sided geometry, or cutting it open with a <see cref="CutPlaneComponent"/>,
        /// back-facing geometry will not be visible, which may be undesirable. This mode has the least performance impact.
        /// </remarks>
        Normal = 0,
        /// <summary>
        /// Dynamically switch to double-sided rendering when geometry is cut open through a <see cref="CutPlaneComponent"/>.
        /// </summary>
        /// <remarks>
        /// This mode only incurs additional performance cost for geometry that is cut open with a cut plane. Moving the camera
        /// inside geometry doesn't enable double-sided rendering. This mode is most useful for applications that doe use cut planes,
        /// but where it is rare for users to move their head inside of geometry.
        /// </remarks>
        DynamicDoubleSiding = 1,
        /// <summary>
        /// Force single-sided geometry to be rendered double-sided.
        /// </summary>
        /// <remarks>
        /// This mode is useful when it is expected for users to move inside geometry. It does incur more performance overhead, though.
        /// </remarks>
        AlwaysDoubleSided = 2,
    }

    /// <summary>
    /// Enum that describes the three enabled states in a hierarchical context. HierarchicalEnableState is used in conjunction with <see cref="HierarchicalStates"/>
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.HierarchicalStateOverrideComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.HierarchicalStates"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/override-hierarchical-state">Hierarchical state override</seealso>
    public enum HierarchicalEnableState : int
    {
        /// <summary>
        /// The feature is disabled on this hierarchy level and further below.
        /// </summary>
        ForceOff = 0,
        /// <summary>
        /// The feature is enabled on this hierarchy level and further below.
        /// </summary>
        ForceOn = 1,
        /// <summary>
        /// The feature's enabled state is inherited from the parent.
        /// </summary>
        InheritFromParent = 2,
    }

    /// <summary>
    /// Status of the connection to the server.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/sessions">Remote Rendering sessions</seealso>
    public enum ConnectionStatus : int
    {
        /// <summary>
        /// No connection to the server.
        /// </summary>
        Disconnected = 0,
        /// <summary>
        /// The client is currently connecting to the server.
        /// </summary>
        Connecting = 1,
        /// <summary>
        /// The client is currently connected to the server.
        /// </summary>
        Connected = 2,
    }

    /// <summary>
    /// Deprecated, use ConversionStatus instead.
    /// </summary>
    /// <seealso cref="ConversionStatusAsync"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingClient"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/conversion/model-conversion">Model conversion</seealso>
    public enum ConversionSessionStatus : int
    {
        /// <summary>
        /// The session status is unknown.
        /// </summary>
        Unknown = 0,
        /// <summary>
        /// The session has been created successfully.
        /// </summary>
        Created = 1,
        /// <summary>
        /// The conversion is currently running.
        /// </summary>
        Running = 2,
        /// <summary>
        /// The conversion has been aborted.
        /// </summary>
        Aborted = 3,
        /// <summary>
        /// The conversion was stopped due to an error.
        /// </summary>
        Failure = 4,
        /// <summary>
        /// The conversion finished successfully.
        /// </summary>
        Success = 5,
    }

    /// <summary>
    /// The status of an asset conversion.
    /// </summary>
    public enum ConversionStatus : int
    {
        /// <summary>
        /// The state of the conversion is currently unknown.
        /// </summary>
        Unknown = 0,
        /// <summary>
        /// The conversion was canceled.
        /// </summary>
        Canceled = 1,
        /// <summary>
        /// The conversion has failed.
        /// </summary>
        Failed = 2,
        /// <summary>
        /// The conversion was created but hasn't started yet.
        /// </summary>
        NotStarted = 3,
        /// <summary>
        /// The conversion is currently running.
        /// </summary>
        Running = 4,
        /// <summary>
        /// The conversion has succeeded.
        /// </summary>
        Succeeded = 5,
    }

    /// <summary>
    /// Status of a rendering session.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSessionProperties"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/sessions">Remote Rendering sessions</seealso>
    public enum RenderingSessionStatus : int
    {
        /// <summary>
        /// The session status is unknown.
        /// </summary>
        Unknown = 0,
        /// <summary>
        /// The session is currently starting.
        /// </summary>
        Starting = 1,
        /// <summary>
        /// The session is ready for rendering.
        /// </summary>
        Ready = 2,
        /// <summary>
        /// The session has been stopped by the user.
        /// </summary>
        Stopped = 3,
        /// <summary>
        /// The session has been stopped because its lease time expired.
        /// </summary>
        Expired = 4,
        /// <summary>
        /// The session has been stopped because it encountered an error.
        /// </summary>
        Error = 5,
    }

    /// <summary>
    /// The different types of objects used by ARR.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ObjectBase"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ResourceBase"/>
    public enum ObjectType : int
    {
        /// <summary>
        /// Invalid object type.
        /// </summary>
        Invalid = 0,
        /// <summary>
        /// internal
        /// </summary>
        FirstBasicObject = 1,
        /// <summary>
        /// Object is an <see cref="Entity"/>
        /// </summary>
        Entity = 1,
        /// <summary>
        /// Object is a <see cref="Mesh"/>
        /// </summary>
        Mesh = 2,
        /// <summary>
        /// Object is a <see cref="Material"/>
        /// </summary>
        Material = 3,
        /// <summary>
        /// Object is a <see cref="Texture"/>
        /// </summary>
        Texture = 4,
        /// <summary>
        /// internal
        /// </summary>
        LastBasicObject = 4,
        /// <summary>
        /// internal
        /// </summary>
        FirstComponent = 200,
        /// <summary>
        /// Object is a <see cref="MeshComponent"/>
        /// </summary>
        MeshComponent = 200,
        /// <summary>
        /// Object is a <see cref="CutPlaneComponent"/>
        /// </summary>
        CutPlaneComponent = 201,
        /// <summary>
        /// Object is a <see cref="HierarchicalStateOverrideComponent"/>
        /// </summary>
        HierarchicalStateOverrideComponent = 202,
        /// <summary>
        /// Object is a <see cref="PointLightComponent"/>
        /// </summary>
        PointLightComponent = 203,
        /// <summary>
        /// Object is a <see cref="SpotLightComponent"/>
        /// </summary>
        SpotLightComponent = 204,
        /// <summary>
        /// Object is a <see cref="DirectionalLightComponent"/>
        /// </summary>
        DirectionalLightComponent = 205,
        /// <summary>
        /// internal
        /// </summary>
        LastComponent = 205,
    }

    /// <summary>
    /// Size of the server used for the rendering session.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/reference/vm-sizes">Server sizes</seealso>
    public enum RenderingSessionVmSize : int
    {
        /// <summary>
        /// internal
        /// </summary>
        None = 0,
        /// <summary>
        /// Premium size servers support the largest amounts of data.
        /// </summary>
        Premium = 1,
        /// <summary>
        /// Standard size servers may impose restrictions on the allowed rendering data.
        /// </summary>
        Standard = 2,
    }

    /// <summary>
    /// The type of connection to use.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingInitialization"/>
    public enum ConnectionType : int
    {
        /// <summary>
        /// General purpose connection.
        /// </summary>
        General = 0,
        /// <summary>
        /// Game engine specific connection.
        /// </summary>
        Engine = 1,
        /// <summary>
        /// internal
        /// </summary>
        Count = 2,
    }

    /// <summary>
    /// Defines how the alpha portion of a mesh's vertex color contributes to the final color.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PbrMaterial.PbrVertexAlphaMode"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/pbr-materials">PBR materials</seealso>
    public enum PbrVertexAlphaMode : int
    {
        /// <summary>
        /// The alpha value represents an ambient occlusion value and therefore only affects the indirect lighting from the skybox.
        /// </summary>
        Occlusion = 0,
        /// <summary>
        /// The alpha value serves as scale factor for the overall amount of lighting applied, meaning the alpha can be used to darken areas. This affects both indirect as well as direct lighting.
        /// </summary>
        LightMask = 1,
        /// <summary>
        /// The alpha represents how opaque (1.0) or transparent (0.0) the material is.
        /// </summary>
        /// <remarks>
        /// This only has an effect if the used <see cref="PbrMaterial"/> has transparency enabled.
        /// </remarks>
        Opacity = 2,
    }

    /// <summary>
    /// Defines whether the <see cref="ColorMaterial"/> is transparent and how it blends with the background.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ColorMaterial.ColorTransparencyMode"/>
    public enum ColorTransparencyMode : int
    {
        /// <summary>
        /// The material is opaque, but still allows for hard cutouts when the flag <see cref="ColorMaterialFeatures.AlphaClipped"/> is specified.
        /// </summary>
        Opaque = 0,
        /// <summary>
        /// The material is semi-transparent through alpha-blending, using the combined albedo's alpha for opacity.
        /// </summary>
        AlphaBlend = 1,
        /// <summary>
        /// The material uses additive blending.
        /// </summary>
        Additive = 2,
    }

    /// <summary>
    /// The supported texture types.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptions"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.LoadTextureOptions"/>
    public enum TextureType : int
    {
        /// <summary>
        /// The texture is a 2D texture.
        /// </summary>
        Texture2D = 0,
        /// <summary>
        /// The texture is a cubemap.
        /// </summary>
        CubeMap = 1,
    }

    /// <summary>
    /// The possible modes for the server side rendering.
    /// </summary>
    /// <seealso cref="RenderingSession.Connect(RendererInitOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/rendering-modes">Rendering modes</seealso>
    public enum ServiceRenderMode : int
    {
        /// <summary>
        /// The multi-GPU result is composed from distinct meshes by merging depth buffers. Suitable for most scene types; balances rendering quality with resource consumption.
        /// </summary>
        /// <remarks>
        /// This mode does NOT support dynamically switching transparency such as see-through effects via the <see cref="HierarchicalStateOverrideComponent"/>.
        /// </remarks>
        DepthBasedComposition = 0,
        /// <summary>
        /// The multi-GPU result is composed from tiles. This mode has slightly better rendering quality but also higher server resource consumption. Not suitable for very large scenes.
        /// </summary>
        TileBasedComposition = 1,
        /// <summary>
        /// The recommended render mode.
        /// </summary>
        Default = 0,
    }

    /// <summary>
    /// Specifies broad categories for assessing the meaning of a performance measurement.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PerformanceInformation"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PerformanceAssessment"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.QueryServerPerformanceAssessmentAsync"/>
    public enum PerformanceRating : int
    {
        Great = 0,
        Good = 1,
        Mediocre = 2,
        Bad = 3,
    }

    /// <summary>
    /// The screen space floating point z convention used for rendering
    /// </summary>
    /// <remarks>
    /// You should use the z-convention you are expecting locally for your projection matrix. If your screen space z range
    /// is [0;1], set <see cref="CameraZConvention.ZeroToOne"/> and <see cref="CameraZConvention.MinusOneToOne"/> for [-1;1].
    /// If you need an inverse Z matrix, use the respective conventions <see cref="CameraZConvention.OneToZero"/> for [1;0]
    /// and <see cref="CameraZConvention.OneToMinusOne"/> for [1;-1].
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.CameraFov.ToProjectionMatrix(System.Single,System.Single,Microsoft.Azure.RemoteRendering.DepthConvention,Microsoft.Azure.RemoteRendering.Matrix4x4)"/>
    public enum DepthConvention : int
    {
        /// <summary>
        /// Z is in range [0;1], with 0 being the camera-closest and 1 being the camera-farthest z value possible.
        /// </summary>
        /// <remarks>
        /// This is the default z convention.
        /// </remarks>
        ZeroToOne = 0,
        /// <summary>
        /// Z is in range [-1;1], with -1 being the camera-closest and 1 being the camera-farthest z value possible.
        /// </summary>
        MinusOneToOne = 1,
        /// <summary>
        /// Z is in range [1;0], with 1 being the camera-closest and 0 being the camera-farthest z value possible
        /// </summary>
        /// <remarks>
        /// This is an inverse z convention.
        /// </remarks>
        OneToZero = 2,
        /// <summary>
        /// Z is in range [1;-1], with 1 being the camera-closest and -1 being the camera-farthest z value possible
        /// </summary>
        /// <remarks>
        /// This is an inverse z convention.
        /// </remarks>
        OneToMinusOne = 3,
    }

    /// <summary>
    /// The pose mode used for rendering.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBinding.SetPoseMode(Microsoft.Azure.RemoteRendering.PoseMode)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/rendering-modes">Rendering modes</seealso>
    public enum PoseMode : int
    {
        /// <summary>
        /// Client operates in local pose space which uses the latest available pose for rendering.
        /// </summary>
        /// <remarks>
        /// Note, the remote frame is automatically reprojected from remote pose space into local
        /// pose space when using this mode which has a performance impact.
        /// This mode gives the best possible latency and quality for local content.
        /// </remarks>
        Local = 0,
        /// <summary>
        /// Client operates in remote pose space which uses the remote pose of the latest received remote frame for rendering.
        /// </summary>
        /// <remarks>
        /// This mode gives the best performance but with the drawback of rendering local content in remote pose space
        /// as well which means that any network issue affecting pose quality will also apply to local content.
        /// </remarks>
        Remote = 1,
    }

    /// <summary>
    /// Render properties that can be overridden by the <see cref="HierarchicalStateOverrideComponent"/>
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.HierarchicalStateOverrideComponent"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/override-hierarchical-state">Hierarchical state override</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial queries</seealso>
    public enum HierarchicalStates : int
    {
        /// <summary>
        /// No state is overridden.
        /// </summary>
        None = 0,
        /// <summary>
        /// The visible flag is overridden.
        /// </summary>
        Hidden = 1,
        /// <summary>
        /// The selected state is overridden.
        /// </summary>
        Selected = 2,
        /// <summary>
        /// The see-through opacity is overridden.
        /// </summary>
        SeeThrough = 4,
        /// <summary>
        /// The use tint color state is overridden. This flag enables individual tint color per object.
        /// </summary>
        /// <remarks>
        /// This flag enables an individual tint color per object.
        /// </remarks>
        UseTintColor = 8,
        /// <summary>
        /// The disable collision flag is overridden.
        /// </summary>
        /// <remarks>
        /// Parts with this flag will be ignored by <see cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">spatial queries</see>.
        /// </remarks>
        DisableCollision = 16,
        /// <summary>
        /// The use cut plane filter mask state is overridden. This flag enables individual cut plane filter masks per object.
        /// </summary>
        UseCutPlaneFilterMask = 64,
        /// <summary>
        /// Renders the scene sub-tree as a transparent shell.
        /// </summary>
        /// <remarks>
        /// The effect's appearance can be globally configured using the <see cref="ShellRenderingSettings"/> state of the <see cref="RenderingConnection"/>.
        /// </remarks>
        Shell = 128,
        /// <summary>
        /// Combination of all flags.
        /// </summary>
        AllValidFlags = 223,
    }

    /// <summary>
    /// Flags specific to the <see cref="PbrMaterial"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PbrMaterial.PbrFlags"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/pbr-materials">PBR materials</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/single-sided-rendering">Single-sided rendering</seealso>
    public enum PbrMaterialFeatures : int
    {
        None = 0,
        /// <summary>
        /// The material is transparent.
        /// </summary>
        /// <remarks>
        /// The amount of transparency is defined by the alpha value of the albedo color and optionally the alpha of the vertex color. See <see cref="PbrVertexAlphaMode"/> for how the vertex color can affect transparency.
        /// </remarks>
        TransparentMaterial = 1,
        /// <summary>
        /// Use the vertex color (if provided by the mesh).
        /// </summary>
        /// <remarks>
        /// This has to be enabled for the <see cref="PbrMaterial.PbrVertexAlphaMode"/> to take effect.
        /// </remarks>
        UseVertexColor = 2,
        /// <summary>
        /// The material is rendered double-sided. Otherwise back-faces may be culled, depending on the selected <see cref="SingleSidedMode"/>.
        /// </summary>
        DoubleSided = 4,
        /// <summary>
        /// Enables specular highlights for this material.
        /// </summary>
        SpecularHighlights = 8,
        /// <summary>
        /// Enables hard cut-outs on a per-pixel basis based on the alpha value being below <see cref="PbrMaterial.AlphaClipThreshold"/>. This works for opaque materials as well.
        /// </summary>
        AlphaClipped = 16,
        /// <summary>
        /// If enabled, this material fades to black as opposed to fading to transparent when using <see cref="PbrMaterial.FadeOut"/>. Fading to black has the same effect on see-through devices like HoloLens but has significantly lower rendering cost.
        /// </summary>
        FadeToBlack = 32,
        /// <summary>
        /// If enabled this material will have a Fresnel effect additively added to the rendering of the base material. Use the FresnelEffectExponent and FresnelEffectColor to control the effect visuals.
        /// </summary>
        FresnelEffect = 64,
        /// <summary>
        /// Toggles transparency depth writes. Objects rendered transparently do not contribute to the depth buffer as a default. Set this to true if objects associated with this material should write depth.
        /// </summary>
        /// <remarks>
        /// Enabling this on transparent materials can improve the re-projection behavior of transparent objects, and hologram stability by consequence. See the respective <see cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/late-stage-reprojection">LSR documentation</see> for details.
        /// </remarks>
        TransparencyWritesDepth = 128,
    }

    /// <summary>
    /// Flags specific to the <see cref="ColorMaterial"/>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ColorMaterial.ColorFlags"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/color-materials">Color materials</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/single-sided-rendering">Single-sided rendering</seealso>
    public enum ColorMaterialFeatures : int
    {
        None = 0,
        /// <summary>
        /// Use the vertex color (if provided by the mesh).
        /// </summary>
        UseVertexColor = 1,
        /// <summary>
        /// The material is rendered double-sided. Otherwise back-faces may be culled, depending on the selected <see cref="SingleSidedMode"/>.
        /// </summary>
        DoubleSided = 2,
        /// <summary>
        /// If enabled, this material fades to black as opposed to fading to transparent when using <see cref="ColorMaterial.FadeOut"/>. Fading to black has the same effect on see-through devices like HoloLens but has significantly lower rendering cost.
        /// </summary>
        FadeToBlack = 4,
        /// <summary>
        /// Enables hard cut-outs on a per-pixel basis based on the alpha value being below <see cref="ColorMaterial.AlphaClipThreshold"/>. This works for opaque materials as well.
        /// </summary>
        AlphaClipped = 8,
        /// <summary>
        /// Toggles transparency depth writes. Objects rendered transparently do not contribute to the depth buffer as a default. Set this to true if objects associated with this material should write depth.
        /// </summary>
        /// <remarks>
        /// Enabling this on transparent materials can improve the re-projection behavior of transparent objects, and hologram stability by consequence. See the respective <see cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/late-stage-reprojection">LSR documentation</see> for details.
        /// </remarks>
        TransparencyWritesDepth = 16,
        /// <summary>
        /// If enabled this material will have a Fresnel effect additively added to the rendering of the base material. Use the FresnelEffectExponent and FresnelEffectColor to control the effect visuals.
        /// </summary>
        FresnelEffect = 32,
    }

    /// <summary>
    /// Specifies the type of a metadata value.
    /// </summary>
    public enum MetadataValueType : int
    {
        /// <summary>
        /// Invalid meta data type.
        /// </summary>
        Invalid = 0,
        /// <summary>
        /// Bool.
        /// </summary>
        Bool = 1,
        /// <summary>
        /// 32 bit signed integer.
        /// </summary>
        Int32 = 2,
        /// <summary>
        /// 64 bit signed integer.
        /// </summary>
        Int64 = 3,
        /// <summary>
        /// 64 bit unsigned integer.
        /// </summary>
        UInt64 = 4,
        /// <summary>
        /// Double precision floating point.
        /// </summary>
        Double = 5,
        /// <summary>
        /// String.
        /// </summary>
        String = 6,
        /// <summary>
        /// internal
        /// </summary>
        MetadataValueTypeCount = 7,
    }

    /// <summary>
    /// Determines which hits a raycast query returns.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial Queries</seealso>
    public enum HitCollectionPolicy : int
    {
        /// <summary>
        /// Return all hits along the ray up to a configurable limit, sorted by distance.
        /// </summary>
        /// <remarks>
        /// This is the least efficient method but it is also rarely needed.
        /// </remarks>
        ClosestHits = 0,
        /// <summary>
        /// Return the closest hit.
        /// </summary>
        ClosestHit = 1,
        /// <summary>
        /// Return any hit along the ray.
        /// </summary>
        /// <remarks>
        /// This is the most efficient option, to answer 'is B visible from A'?
        /// </remarks>
        AnyHit = 2,
    }

    internal enum HandleType : int
    {
        Unknown = 0,
        SessionContextResult = 1,
        CreateRenderingSessionResult = 2,
        RenderingSessionPropertiesResult = 3,
        ConversionPropertiesResult = 4,
        RenderingSessionPropertiesArrayResult = 5,
        AssetConversionResult = 6,
        AssetConversionStatusResult = 7,
        ConversionPropertiesArrayResult = 8,
        ObjectBase = 9,
        ComponentBase = 10,
        LightComponentBase = 11,
        CutPlaneComponent = 12,
        HierarchicalStateOverrideComponent = 13,
        PointLightComponent = 14,
        SpotLightComponent = 15,
        DirectionalLightComponent = 16,
        MeshComponent = 17,
        ResourceBase = 18,
        Material = 19,
        PbrMaterial = 20,
        ColorMaterial = 21,
        Mesh = 22,
        Texture = 23,
        Entity = 24,
        GraphicsBinding = 25,
        GraphicsBindingSimD3d11 = 26,
        GraphicsBindingWmrD3d11 = 27,
        GraphicsBindingOpenXrD3d11 = 28,
    }

    internal delegate void DestructorHookDelegate();

    /// <summary>
    /// Delegate for receiving log messages.
    /// </summary>
    /// <param name="level">
    /// Level of the log message.
    /// </param>
    /// <param name="message">
    /// Message as an IntPtr to the underlying UTF-8 char array.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingClient"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection"/>
    public delegate void LogEventHandler(Microsoft.Azure.RemoteRendering.LogLevel level, System.IntPtr message);

    /// <summary>
    /// Delegate for receiving connection status updates.
    /// </summary>
    /// <param name="status">
    /// The new connection status.
    /// </param>
    /// <param name="error">
    /// Additional error information in case of an unintended disconnect.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession"/>
    public delegate void ConnectionStatusChangedEventHandler(Microsoft.Azure.RemoteRendering.ConnectionStatus status, Microsoft.Azure.RemoteRendering.Result error);

    /// <summary>
    /// Delegate for receiving notification when an update tick has completed on a <see cref="Microsoft.Azure.RemoteRendering.RenderingConnection"/>.
    /// </summary>
    public delegate void RenderingConnectionUpdatedEventHandler();

    /// <summary>
    /// Informs the application that a remote rendering client requires an updated access token or authentication token.
    /// </summary>
    /// <param name="sender">
    /// The client that requires an updated access token or authentication token.
    /// </param>
    /// <param name="args">
    /// The event arguments that require an AccessToken property or an AuthenticationToken property to be set.
    /// </param>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RemoteRenderingClient.TokenRequired"/>
    public delegate void TokenRequiredEventHandler(object sender, Microsoft.Azure.RemoteRendering.TokenRequiredEventArgs args);

    /// <summary>
    /// Base class for all Remote Rendering API exceptions.
    /// </summary>
    public class RRException : Exception
    {
        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        public RRException()
        {
            this.ErrorCode = default(Result);
        }

        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        /// <param name='code'>Error code for this exception.</param>
        public RRException(Result code)
        {
            this.ErrorCode = code;
        }

        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        /// <param name='code'>Error code for this exception.</param>
        /// <param name='message'>Plain text error message for this exception.</param>
        public RRException(Result code, string message) : base(message)
        {
            this.ErrorCode = code;
        }

        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        /// <param name='code'>Error code for this exception.</param>
        /// <param name='message'>Plain text error message for this exception.</param>
        /// <param name='requestCorrelationVector'>Request correlation vector for this exception.</param>
        /// <param name='responseCorrelationVector'>Response correlation vector for this exception.</param>
        public RRException(Result code, string message, string requestCorrelationVector, string responseCorrelationVector) : base(message)
        {
            this.ErrorCode = code;
            this.RequestCorrelationVector = requestCorrelationVector;
            this.ResponseCorrelationVector = responseCorrelationVector;
        }

        /// <summary>Creates a new instance of the <see cref='RRException'/> class.</summary>
        /// <param name='code'>Error code for this exception.</param>
        /// <param name='message'>Plain text error message for this exception.</param>
        /// <param name='requestCorrelationVector'>Request correlation vector for this exception.</param>
        /// <param name='responseCorrelationVector'>Response correlation vector for this exception.</param>
        /// <param name='inner'>Exception that caused this exception to be thrown.</param>
        public RRException(Result code, string message, string requestCorrelationVector, string responseCorrelationVector, Exception inner) : base(message, inner)
        {
            this.ErrorCode = code;
            this.RequestCorrelationVector = requestCorrelationVector;
            this.ResponseCorrelationVector = responseCorrelationVector;
        }

        /// <summary>
        /// The error code associated with this exception instance.
        /// </summary>
        public Result ErrorCode { get; }

        /// <summary>
        /// The request correlation-vector associated with this exception instance.
        /// </summary>
        public string RequestCorrelationVector { get; }

        /// <summary>
        /// The response correlation-vector associated with this exception instance.
        /// </summary>
        public string ResponseCorrelationVector { get; }

    }

    /// <summary>
    /// Deprecated, do not use
    /// </summary>
    public partial class AssetConversionResult : SessionContextResult
    {
        internal AssetConversionResult(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The UUID of the conversion operation.
        /// </summary>
        public string ConversionUuid
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_asset_conversion_result_get_conversion_uuid(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// Deprecated, use ConversionPropertiesResult instead.
    /// </summary>
    public partial class AssetConversionStatusResult : SessionContextResult
    {
        internal AssetConversionStatusResult(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The result of the query.
        /// </summary>
        /// <remarks>
        /// It is an error to call this while the operation is still in progress or in an error state.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ConversionSessionStatus Result
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ConversionSessionStatus result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_asset_conversion_status_result_get_result(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Get additional information about the result.
        /// </summary>
        public string ErrorMessage
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_asset_conversion_status_result_get_error_message(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// Camera settings.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/camera">Camera</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.CameraSettings"/>
    public partial class CameraSettings
    {
        internal ulong handle;

        internal CameraSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The near plane distance.
        /// </summary>
        public float NearPlane
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_get_near_plane(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The far plane distance.
        /// </summary>
        public float FarPlane
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_get_far_plane(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Enables depth composition with locally rendered content.
        /// </summary>
        /// <remarks>
        /// This is needed, if you want locally rendered content to intersect properly with remotely rendered content.
        /// On the other hand, if you render only UI elements locally that don't need to be occluded by remote content,
        /// turn this off to save performance and bandwidth.
        /// </remarks>
        public bool EnableDepth
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_get_enable_depth(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_set_enable_depth(this.handle, value));
            }
        }

        /// <summary>
        /// Set this to true if you are using the inverse depth range of 1 (closest to the camera) to zero (farthest from the camera) instead of the standard [0;1] for your local depth buffer.
        /// </summary>
        /// <remarks>
        /// The default setting is false, i.e. a standard depth buffer floating-point range of [0;1] is assumed.
        /// Setting this is only necessary in case <see cref="CameraSettings.EnableDepth"/> is set to true, otherwise this option can be ignored.
        /// </remarks>
        public bool InverseDepth
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_get_inverse_depth(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_set_inverse_depth(this.handle, value));
            }
        }

        /// <summary>
        /// Sets the near and far plane of the camera.
        /// </summary>
        /// <param name="nearPlane">
        /// The distance to the near plane. Must be larger than zero.
        /// </param>
        /// <param name="farPlane">
        /// The distance to the far plane. Must be larger than zero.
        /// </param>
        /// <remarks>
        /// For best quality, keep the ratio of farPlane/nearPlane low. For Augmented Reality use cases the far plane doesn't need to be very far away,
        /// 20 to 100 meters should be sufficient.
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs, if nearPlane is greater than or equal to farPlane.
        /// </para>
        /// </remarks>
        public void SetNearAndFarPlane(float nearPlane, float farPlane)
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_camera_settings_set_near_and_far_plane(this.handle, nearPlane, farPlane));
        }

    }

    /// <summary>
    /// A material that doesn't get any lighting applied.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Material"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PbrMaterial"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.CreateMaterial(Microsoft.Azure.RemoteRendering.MaterialType)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/color-materials">Color materials</seealso>
    public partial class ColorMaterial : Material
    {
        internal ColorMaterial(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The <see cref="ColorMaterialFeatures">color material flags</see>.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if an invalid bitmask is passed in.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ColorMaterialFeatures ColorFlags
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ColorMaterialFeatures result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_color_flags(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_color_flags(this.handle, value));
            }
        }

        /// <summary>
        /// Constant albedo color.
        /// </summary>
        /// <remarks>
        /// This color is modulated with the color from the <see cref="ColorMaterial.AlbedoTexture"/>.
        /// The alpha channel represents the opacity, in case the material is flagged as transparent (<see cref="ColorMaterial.ColorTransparencyMode"/>).
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Color4 AlbedoColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_albedo_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_albedo_color(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="Texture"/> used for the albedo color. Pass in <c>null</c> if no dedicated texture is needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture AlbedoTexture
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_albedo_texture(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_albedo_texture(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Scaling factors for texture coordinates.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Used to repeat/tile textures. For instance passing (4, 2) will repeat the texture 4 times along the U texture coordinate, and 2 times along V.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is NaN or infinite.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.ColorMaterial.TexCoordOffset"/>
        public Microsoft.Azure.RemoteRendering.Float2 TexCoordScale
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_tex_coord_scale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_tex_coord_scale(this.handle, value));
            }
        }

        /// <summary>
        /// Constant offset added to texture coordinates.
        /// </summary>
        /// <remarks>
        /// <para>
        /// An offset is normalized to [0..1] range, regardless of texture size, so (0.5, 0.5) always points to the middle of a texture.
        /// The offset can be changed over time to scroll the texture.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is NaN or infinite.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Float2 TexCoordOffset
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_tex_coord_offset(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_tex_coord_offset(this.handle, value));
            }
        }

        /// <summary>
        /// Transparency mode for this material. See <see cref="ColorTransparencyMode"/> for details.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if an invalid mode is passed in.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ColorTransparencyMode ColorTransparencyMode
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ColorTransparencyMode result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_color_transparency_mode(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_color_transparency_mode(this.handle, value));
            }
        }

        /// <summary>
        /// Fade-out value in the [0..1] range, where 0.0 means fully faded out and 1.0 means fully opaque.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is very similar to changing the albedo's alpha on a transparent material, however, this function automatically manages the transparency flag for values of 1.0 (fully opaque) and smaller than 1.0 (semi-transparent).
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float FadeOut
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_fade_out(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_fade_out(this.handle, value));
            }
        }

        /// <summary>
        /// How much the vertex color is mixed into the final color. In [0..1] range.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the mesh has vertex colors, those colors can be multiplied into the final color.
        /// This option defines how much influence the vertex colors will have.
        /// A value of 0.0 means that the vertex color doesn't contribute to the output at all.
        /// At 1.0 the vertex colors are fully multiplied into the albedo color.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float VertexMix
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_vertex_mix(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_vertex_mix(this.handle, value));
            }
        }

        /// <summary>
        /// Threshold that is used for alpha cutouts.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If a pixel's final alpha value [0..1] falls below this threshold, the pixel is clipped, creating a hard cutout.
        /// Note that the material's <see cref="PbrMaterialFeatures.AlphaClipped"/> flag has to be set, for this threshold to have an effect.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float AlphaClipThreshold
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_alpha_clip_threshold(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_alpha_clip_threshold(this.handle, value));
            }
        }

        /// <summary>
        /// The Fresnel effect color used when the effect is enabled (see the 'FresnelEffect' flag in <see cref="ColorMaterialFeatures"/>)
        /// </summary>
        /// <remarks>
        /// Only the rgb channels of the color are used for the Fresnel effect, while the alpha value will be ignored.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Color4 FresnelEffectColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_fresnel_effect_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_fresnel_effect_color(this.handle, value));
            }
        }

        /// <summary>
        /// The Fresnel effect exponent used when the effect is enabled (see the 'FresnelEffect' flag in <see cref="ColorMaterialFeatures"/>)
        /// </summary>
        /// <remarks>
        /// The valid range for the exponent is [0.01, 10].
        /// </remarks>
        public float FresnelEffectExponent
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_get_fresnel_effect_exponent(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_color_material_set_fresnel_effect_exponent(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Base class for all components.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Components add functionality to <see cref="Entity">entities</see>.
    /// For example, a <see cref="CutPlaneComponent"/> turns an entity into an object that cuts meshes open.
    /// </para>
    /// <para>
    /// An entity can only have one instance of each component type attached at any given time.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Entity"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType,Microsoft.Azure.RemoteRendering.Entity)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/components">Components</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/lifetime">Object and resource lifetime</seealso>
    public partial class ComponentBase : ObjectBase
    {
        internal ComponentBase(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// Whether this component is still valid.
        /// </summary>
        /// <remarks>
        /// A component is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The <see cref="Entity"/> that this component is attached to.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Entity Owner
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Entity result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_get_owner(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Entity(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Enabled state of this component.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Disabled components have no effect. This is usually the same, as if the component wasn't attached at all,
        /// except that the enabled state can be toggled at any time, and any other state (for instance, the color of a light source)
        /// is preserved. It is therefore often easier to disable a component, and enable it later again, rather than to delete it and
        /// create a new component later.
        /// </para>
        /// <para>
        /// However, an entity may only have one instance of each component type attached, even if a component is disabled.
        /// </para>
        /// </remarks>
        public bool Enabled
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_get_enabled(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_set_enabled(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this component.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Destroys the component in the runtime.
        /// </summary>
        /// <remarks>
        /// Once Destroy() has been called on a component, subsequent calls to <see cref="ComponentBase.Valid"/> will return <c>false</c>.
        /// </remarks>
        public void Destroy()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_component_base_destroy(this.handle));
        }

    }

    public partial class ConversionPropertiesArrayResult : SessionContextResult
    {
        internal ConversionPropertiesArrayResult(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        public Microsoft.Azure.RemoteRendering.ConversionProperties[] Conversions
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ConversionPropertiesAbi[] result;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_conversion_properties_array_result_get_conversions(this.handle, out result, out result_length));
                return result?.Select(x => x.Convert()).ToArray() ?? null;
            }
        }

    }

    public partial class ConversionPropertiesResult : SessionContextResult
    {
        internal ConversionPropertiesResult(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        public Microsoft.Azure.RemoteRendering.ConversionProperties Properties
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ConversionPropertiesAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_conversion_properties_result_get_properties(this.handle, out result));
                return result.Convert();
            }
        }

        /// <summary>
        /// The minimum number of seconds one has to wait before polling the conversion properties again.
        /// </summary>
        public int MinimumRetryDelay
        {
            get
            {
                int result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_conversion_properties_result_get_minimum_retry_delay(this.handle, out result));
                return result;
            }
        }

    }

    public partial class CreateRenderingSessionResult : SessionContextResult
    {
        internal CreateRenderingSessionResult(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        public Microsoft.Azure.RemoteRendering.RenderingSession Session
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.RenderingSession result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_create_rendering_session_result_get_session(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.RenderingSession(result_handle, transfer:true) : null;
                return result_object;
            }
        }

    }

    /// <summary>
    /// Cut planes are used to cut away parts of meshes to be able to peek inside.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Once a cut plane is part of the scene, all rendered pixels that are on the back side of the plane will be discarded.
    /// By moving the cut plane around or changing its orientation, one can adjust which parts of the scene are visible.
    /// </para>
    /// <para>
    /// The position of the cut plane is specified through the position of the owning <see cref="Entity"/>.
    /// The orientation is specified through the <see cref="CutPlaneComponent.Normal"/> and the rotation of the entity.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Entity"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType,Microsoft.Azure.RemoteRendering.Entity)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/cut-planes">Cut planes</seealso>
    public partial class CutPlaneComponent : ComponentBase
    {
        internal CutPlaneComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The main axis of the cut plane when the owning <see cref="Entity"/> has an identity rotation.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Pixels that end up behind the cut plane will be discarded by the renderer.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs, if the passed in axis is out of range.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Axis Normal
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Axis result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_get_normal(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_set_normal(this.handle, value));
            }
        }

        /// <summary>
        /// The color towards which pixels that are closer than <see cref="CutPlaneComponent.FadeLength"/> will be faded.
        /// </summary>
        /// <remarks>
        /// If the alpha value is non-zero, pixels close to the cut plane will fade towards the RGB part of FadeColor. The strength of the alpha channel determines whether it will fade fully towards the fade color or only partially.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Color4Ub FadeColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4Ub result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_get_fade_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_set_fade_color(this.handle, value));
            }
        }

        /// <summary>
        /// The distance over which the cut plane fades the original pixel color towards the <see cref="CutPlaneComponent.FadeColor"/>.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if a negative length is set.
        /// </para>
        /// </remarks>
        public float FadeLength
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_get_fade_length(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_set_fade_length(this.handle, value));
            }
        }

        /// <summary>
        /// Sets the bit mask that can be used to perform per-object cut plane filtering.
        /// </summary>
        public byte CutPlaneFilterMask
        {
            get
            {
                byte result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_get_cut_plane_filter_mask(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_cut_plane_component_set_cut_plane_filter_mask(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Options for debug rendering features
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.DebugRenderingSettings"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/debug-rendering">Debug Rendering</seealso>
    public partial class DebugRenderingSettings
    {
        internal ulong handle;

        internal DebugRenderingSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Controls the server-side overlay to render a frame counter.
        /// </summary>
        public bool RenderFrameCount
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_get_render_frame_count(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_set_render_frame_count(this.handle, value));
            }
        }

        /// <summary>
        /// Controls the server-side overlay to render the polygon count.
        /// </summary>
        public bool RenderPolygonCount
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_get_render_polygon_count(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_set_render_polygon_count(this.handle, value));
            }
        }

        /// <summary>
        /// Controls whether geometry should be rendered as wireframe.
        /// </summary>
        public bool RenderWireframe
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_get_render_wireframe(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_debug_rendering_settings_set_render_wireframe(this.handle, value));
            }
        }

    }

    /// <summary>
    /// A light source that emits light globally into a fixed direction.
    /// </summary>
    /// <remarks>
    /// This component simulates a light source that is very far away, such as the sun or the moon.
    /// Consequently, the owner's position is ignored and only the orientation is used. The light shines into the direction of the negative z-axis of the owner <see cref="Entity"/>.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.LightComponentBase"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PointLightComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SpotLightComponent"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/lights">Scene lighting</seealso>
    public partial class DirectionalLightComponent : LightComponentBase
    {
        internal DirectionalLightComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

    }

    /// <summary>
    /// An entity represents an object in space.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Entities have a transform, meaning a position, rotation and scale.
    /// By themselves entities don't have any observable functionality. Instead behavior is added through components (see <see cref="ComponentBase"/>),
    /// which are attached to entities. For instance attaching a <see cref="MeshComponent"/> will make a mesh appear at the position of the entity.
    /// </para>
    /// <para>
    /// The most important aspect of the entity itself is the hierarchy and the resulting hierarchical transform. For example, when
    /// multiple entities are attached as children to a shared parent entity, all of these entities can be moved, rotated and scaled in unison by
    /// changing the transform of the parent entity.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.CreateEntity"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/entities">Entities</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/components">Components</seealso>
    public partial class Entity : ObjectBase
    {
        internal Entity(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this object.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Whether this entity is still valid.
        /// </summary>
        /// <remarks>
        /// An entity is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The entity that acts as this entity's parent.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Top level entities don't have a parent, in which case this returns <c>null</c>.
        /// Setting a new parent automatically adds this entity to the list of children of the provided parent.
        /// </para>
        /// <para>
        /// * A <see cref="Result.CyclicReference"/> error occurs, if the new parent is a descendant of this object.
        /// * A <see cref="Result.InvalidId"/> error occurs, if an invalid entity is set as the parent.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Entity Parent
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Entity result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_parent(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Entity(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_parent(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Read-only list of all the entities that are attached as children to this one.
        /// </summary>
        /// <remarks>
        /// To make an entity the child of another entity, use the <see cref="Entity.Parent"/> property.
        /// </remarks>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Entity> Children
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Entity> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_children(this.handle, out result_array, out result_length));
                result = result_array?.Select(handle => new Microsoft.Azure.RemoteRendering.Entity(handle, transfer:true)).ToArray() ?? Array.Empty<Microsoft.Azure.RemoteRendering.Entity>();
                return result;
            }
        }

        /// <summary>
        /// Read-only list of all the components that are attached to this entity.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ComponentBase> Components
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ComponentBase> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_components(this.handle, out result_array, out result_length));
                result = result_array?.Select(handle => Factories.ComponentBaseFactory(handle, transfer:true)).ToArray() ?? Array.Empty<Microsoft.Azure.RemoteRendering.ComponentBase>();
                return result;
            }
        }

        /// <summary>
        /// Enables or disables the entity and all its components and children.
        /// </summary>
        /// <remarks>
        /// Disabling an entity is similar to deleting it, except that it can be enabled again easily.
        /// All components on a disabled entity are disabled as well, and so are all child entities.
        /// </remarks>
        public bool Enabled
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_enabled(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_enabled(this.handle, value));
            }
        }

        /// <summary>
        /// Indicates whether this object originates from a model conversion that used the 'SceneGraphMode=static' parameter for conversion. These objects cannot be transformed individually or re-parented. Calling transform or re-parenting on a static object will return the 'ObjectStatic' error code.
        /// </summary>
        public bool Static
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_static(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Position, relative to the parent node.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidParam"/> error occurs if the given value is NaN or infinite.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Double3 Position
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Double3 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_position(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_position(this.handle, value));
            }
        }

        /// <summary>
        /// Rotation, relative to the parent node.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidParam"/> error occurs if the given value is NaN or infinite.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Quaternion Rotation
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Quaternion result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_rotation(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_rotation(this.handle, value));
            }
        }

        /// <summary>
        /// Scale, relative to the parent node.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidParam"/> error occurs if the given value is NaN or infinite.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Float3 Scale
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float3 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_scale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_scale(this.handle, value));
            }
        }

        /// <summary>
        /// Optional name property.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.StringTooLong"/> error occurs if the given string is excessively long.
        /// </para>
        /// </remarks>
        public string Name
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_get_name(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_set_name(this.handle, value));
            }
        }

        /// <summary>
        /// Tries to find a component of the given type.
        /// </summary>
        /// <param name="type">
        /// Component type to search for.
        /// </param>
        /// <remarks>
        /// Only one instance of each component type can be attached to each entity. Therefore this function either returns a single result, or <c>null</c>, if none is found.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ComponentBase FindComponentOfType(Microsoft.Azure.RemoteRendering.ObjectType type)
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.ComponentBase result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_find_component_of_type(this.handle, type, out result_handle));
            result_object = (result_handle != default(ulong)) ? Factories.ComponentBaseFactory(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Destroys the entity.
        /// </summary>
        /// <remarks>
        /// Destroying an entity will also destroy all of its components and child entities.
        /// Once Destroy() has been called, <see cref="Entity.Valid"/> returns <c>false</c>.
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.Entity.Valid"/>
        public void Destroy()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_destroy(this.handle));
        }

        /// <summary>
        /// Queries the world-space bounding box from the server.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The bounding box represents the volume that this entity, all its child entities, and attached meshes take up.
        /// </para>
        /// <para>
        /// QueryWorldBoundsAsync is an asynchronous call. The computation of the bounds is performed on the server and returned when available.
        /// </para>
        /// <para>
        /// * A <see cref="Result.NoConnection"/> error occurs no connection was found.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.Mesh.Bounds"/>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.Bounds> QueryWorldBoundsAsync()
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => Microsoft.Azure.RemoteRendering.Bounds.Create(value.Pointer), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_query_world_bounds_async(this.handle, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Queries the local-space bounding box from the server.
        /// </summary>
        /// <remarks>
        /// QueryLocalBoundsAsync is an asynchronous call. The computation of the bounds is performed on the server and returned when available.
        /// <para>
        /// * A <see cref="Result.NoConnection"/> error occurs no connection was found.
        /// </para>
        /// </remarks>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.Bounds> QueryLocalBoundsAsync()
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => Microsoft.Azure.RemoteRendering.Bounds.Create(value.Pointer), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_query_local_bounds_async(this.handle, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Queries for any available metadata on a single entity.
        /// </summary>
        /// <remarks>
        /// <para>
        /// * A <see cref="Result.NoConnection"/> error occurs if no connection was found.
        /// </para>
        /// </remarks>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.ObjectMetadata> QueryMetadataAsync()
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.ObjectMetadata(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_entity_query_metadata_async(this.handle, promise_.Handle));
                return await promise_.Task;
            }
        }

    }

    /// <summary>
    /// Base class for graphics bindings.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/graphics-bindings">Graphics binding</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingWmrD3d11"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingOpenXrD3d11"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBindingSimD3d11"/>
    public partial class GraphicsBinding
    {
        internal ulong handle;

        internal GraphicsBinding(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        protected GraphicsBinding()
        {
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_create(out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        /// <summary>
        /// The derived graphics binding that this instance can be cast to.
        /// </summary>
        /// <remarks>
        /// This may only be called when the <see cref="RemoteRenderingClient"/> is initialized.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.GraphicsApiType Api
        {
            get
            {
                Microsoft.Azure.RemoteRendering.GraphicsApiType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_get_api(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Retrieves the last frame's statistics.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.NoConnection"/> error occurs if this is called while there is no connection to the server.
        /// </para>
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/performance-queries">Server-side performance queries</seealso>
        public Microsoft.Azure.RemoteRendering.Result GetLastFrameStatistics(out Microsoft.Azure.RemoteRendering.FrameStatistics stats)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_get_last_frame_statistics(this.handle, out stats, out result));
            return result;
        }

        /// <summary>
        /// Set the pose mode.
        /// </summary>
        /// <remarks>
        /// <para>
        /// /// A <see cref="Result.NotSupported"/> error occurs if <see cref="PoseMode.Remote"/> is used on Android.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result SetPoseMode(Microsoft.Azure.RemoteRendering.PoseMode mode)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_set_pose_mode(this.handle, mode, out result));
            return result;
        }

    }

    /// <summary>
    /// D3D11 binding for OpenXR.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Important: <c>RemoteManagerStatic.StartupRemoteRendering</c> must be called before the OpenXR loader negotiates with the underlying OpenXR runtime.
    /// </para>
    /// <para>
    /// At runtime the only thing that needs to be done by the user is to call <see cref="GraphicsBindingOpenXrD3d11.BlitRemoteFrame"/> to render the remote frame to the current render target.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBinding"/>
    public partial class GraphicsBindingOpenXrD3d11 : GraphicsBinding
    {
        internal GraphicsBindingOpenXrD3d11(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// Blits the current remote frame to the bound render target.
        /// </summary>
        /// <remarks>
        /// When this function is executed it is assumed that the color and depth buffers provided by OpenXR are bound as the render target.
        /// This should be done as the very first thing in each frame as this function will overwrite all content in the target buffers.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result BlitRemoteFrame()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_open_xr_d3d11_blit_remote_frame(this.handle, out result));
            return result;
        }

        /// <summary>
        /// Retrieves the remote focus point.
        /// </summary>
        /// <param name="spaceHandle">
        /// The OpenXR space in which the focus point should be expressed. Passing an invalid space handle will result in invalid focus points.
        /// </param>
        /// <param name="position">
        /// The focus point's position in world-space.
        /// </param>
        /// <param name="normal">
        /// The focus point's normal in world-space.
        /// </param>
        /// <param name="velocity">
        /// The focus point's velocity measured in units per second, in world-space.
        /// </param>
        /// <remarks>
        /// <para>
        /// This focus point must be explicitly set as the focus point to be used.
        /// </para>
        /// <para>
        /// A <see cref="Result.NoConnection"/> error occurs if this is called while there is no connection to the server.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.FocusPointResult GetRemoteFocusPoint(ulong spaceHandle, out Microsoft.Azure.RemoteRendering.Float3 position, out Microsoft.Azure.RemoteRendering.Float3 normal, out Microsoft.Azure.RemoteRendering.Float3 velocity)
        {
            Microsoft.Azure.RemoteRendering.FocusPointResult result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_open_xr_d3d11_get_remote_focus_point(this.handle, spaceHandle, out position, out normal, out velocity, out result));
            return result;
        }

        /// <summary>
        /// Informs ARR of a new app space.
        /// </summary>
        /// <param name="spaceHandle">
        /// OpenXR space handle.
        /// </param>
        /// <remarks>
        /// ARR must be informed whenever the app space changes.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result UpdateAppSpace(ulong spaceHandle)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_open_xr_d3d11_update_app_space(this.handle, spaceHandle, out result));
            return result;
        }

    }

    /// <summary>
    /// Graphics API binding for local simulation.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This graphics binding is used to render a monoscopic remote image on a normal desktop application.
    /// With no sensors to provide head movement available, this binding requires the user to provide a current
    /// camera update each frame. The basic setup works as follow:
    /// </para>
    /// <para>
    /// 1. Remote and local content is rendered onto an off-screen color / depth render target called 'proxy' using the proxy camera provided by the Update function.
    /// The proxy needs to be created matching the resolution of the back-buffer.
    /// Before any rendering takes place, InitSimulation() needs to be called with the proxy texture handles, as well as a D3D device to fully initialize the simulation.
    /// </para>
    /// <para>
    /// 2. Each frame, before any rendering takes place, Update is called with the current camera transform and the returned proxy transform is applied to the proxy camera.
    /// </para>
    /// <para>
    /// 3. At the start of rendering into the proxy, <see cref="GraphicsBindingSimD3d11.BlitRemoteFrameToProxy"/> needs to be called, this fills the remote color and depth information into the proxy render targets.
    /// Any local content can now be rendered onto the proxy using the proxy camera.
    /// </para>
    /// <para>
    /// 4. Once the back-buffer is bound, only <see cref="GraphicsBindingSimD3d11.ReprojectProxy"/> needs to be called and no other rendering should take place.
    /// </para>
    /// <para>
    /// 5. Repeat with step 2 until session ends.
    /// </para>
    /// <para>
    /// 6. Call <see cref="GraphicsBindingSimD3d11.DeinitSimulation"/> after the remote session has ended.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBinding"/>
    public partial class GraphicsBindingSimD3d11 : GraphicsBinding
    {
        internal GraphicsBindingSimD3d11(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// Initializes the simulation. Needs to be called before a remote rendering session is started.
        /// </summary>
        /// <param name="d3dDevice">
        /// The d3d device that will be used to render the remote image.
        /// </param>
        /// <param name="proxyDepth">
        /// Depth texture of the proxy render-target.
        /// </param>
        /// <param name="proxyColor">
        /// Color texture of the proxy render-target. The minimum dimension of the texture is 256x256.
        /// </param>
        /// <param name="refreshRate">
        /// Target refresh rate at which the remote runtime should render.
        /// </param>
        /// <param name="flipBlitRemoteFrameTextureVertically">
        /// If set, <see cref="GraphicsBindingSimD3d11.BlitRemoteFrameToProxy"/> will flip the rendered image vertically.
        /// </param>
        /// <param name="flipReprojectTextureVertically">
        /// If set, <see cref="GraphicsBindingSimD3d11.ReprojectProxy"/> will flip the rendered image vertically.
        /// </param>
        /// <param name="stereo">
        /// Simulation will use stereoscopic rendering if set to true. The proxy textures need to have two array layers in this case!
        /// </param>
        public Microsoft.Azure.RemoteRendering.Result InitSimulation(System.IntPtr d3dDevice, System.IntPtr proxyDepth, System.IntPtr proxyColor, float refreshRate, bool flipBlitRemoteFrameTextureVertically, bool flipReprojectTextureVertically, bool stereo)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_init_simulation_int_ptr_d3d_device_int_ptr_proxy_depth_int_ptr_proxy_color_single_refresh_rate_boolean_flip_blit_remote_frame_texture_vertically_boolean_flip_reproject_texture_vertically_boolean_stereo(this.handle, d3dDevice, proxyDepth, proxyColor, refreshRate, flipBlitRemoteFrameTextureVertically, flipReprojectTextureVertically, stereo, out result));
            return result;
        }

        /// <summary>
        /// Initializes the simulation. Needs to be called before a remote rendering session is started. This is an alternative initialization call, where no proxy targets are configured. Therefore, local pose mode will be forced and <see cref="GraphicsBindingSimD3d11.ReprojectProxy"/> will essentially become a no-op. The caller is expected to bind the final render target before calling <see cref="GraphicsBindingSimD3d11.BlitRemoteFrameToProxy"/>.
        /// </summary>
        /// <param name="d3dDevice">
        /// The d3d device that will be used to render the remote image.
        /// </param>
        /// <param name="renderTargetWidth">
        /// The width of the final render target (minimum: 256).
        /// </param>
        /// <param name="renderTargetHeight">
        /// The heigth of the final render target (minimum: 256).
        /// </param>
        /// <param name="refreshRate">
        /// Target refresh rate at which the remote runtime should render.
        /// </param>
        /// <param name="flipBlitRemoteFrameTextureVertically">
        /// If set, <see cref="GraphicsBindingSimD3d11.BlitRemoteFrameToProxy"/> will flip the rendered image vertically.
        /// </param>
        /// <param name="flipReprojectTextureVertically">
        /// If set, <see cref="GraphicsBindingSimD3d11.ReprojectProxy"/> will flip the rendered image vertically.
        /// </param>
        /// <param name="stereo">
        /// Simulation will use stereoscopic rendering if set to true. The final render target needs to have two array layers in this case!
        /// </param>
        public Microsoft.Azure.RemoteRendering.Result InitSimulation(System.IntPtr d3dDevice, int renderTargetWidth, int renderTargetHeight, float refreshRate, bool flipBlitRemoteFrameTextureVertically, bool flipReprojectTextureVertically, bool stereo)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_init_simulation_int_ptr_d3d_device_int32_render_target_width_int32_render_target_height_single_refresh_rate_boolean_flip_blit_remote_frame_texture_vertically_boolean_flip_reproject_texture_vertically_boolean_stereo(this.handle, d3dDevice, renderTargetWidth, renderTargetHeight, refreshRate, flipBlitRemoteFrameTextureVertically, flipReprojectTextureVertically, stereo, out result));
            return result;
        }

        /// <summary>
        /// Deinitializes the simulation. Needs to be called after a remote rendering session has ended.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result DeinitSimulation()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_deinit_simulation(this.handle, out result));
            return result;
        }

        /// <summary>
        /// Needs to be called every frame.
        /// </summary>
        /// <param name="updateParameters">
        /// The update parameters of the main camera. This information will be sent to the server for rendering.
        /// </param>
        /// <param name="proxyFrameUpdateResult">
        /// The camera update for the proxy. Matches the current remote frame and needs to be applied locally.
        /// </param>
        /// <remarks>
        /// Typically there are multiple frames in flight. The frame data that is received and rendered locally, is always lagging behind a bit. Therefore, when calling Update() you need to specify the latest matrices with which the server should render that frame, but the matrices that you need to use for rendering local contant have to match the ones that were used for the currently arriving video frame. Therefore ARR provides you with that information through the proxyFrameUpdate parameter, so that you don't need to keep track of old rendering matrices yourself.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result Update(Microsoft.Azure.RemoteRendering.SimulationUpdateParameters updateParameters, out Microsoft.Azure.RemoteRendering.SimulationUpdateResult proxyFrameUpdateResult)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_update(this.handle, updateParameters, out proxyFrameUpdateResult, out result));
            return result;
        }

        /// <summary>
        /// Blits the current remote frame to the currently bound render target.
        /// </summary>
        /// <remarks>
        /// When this function is executed it is assumed that the proxy color and depth buffers are bound as the current render target.
        /// This should be done as the very first thing in each frame as this function will overwrite all content in the target buffers.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result BlitRemoteFrameToProxy()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_blit_remote_frame_to_proxy(this.handle, out result));
            return result;
        }

        /// <summary>
        /// Reprojects the proxy color texture onto the back-buffer.
        /// </summary>
        /// <remarks>
        /// When this function is executed it is assumed that the back-buffer color and depth buffers are bound as the current render target.
        /// This should be done as the very last thing in each frame.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result ReprojectProxy()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_reproject_proxy(this.handle, out result));
            return result;
        }

        /// <summary>
        /// Retrieves the remote focus point.
        /// </summary>
        /// <param name="position">
        /// The focus point's position in world-space.
        /// </param>
        /// <param name="normal">
        /// The focus point's normal in world-space.
        /// </param>
        /// <param name="velocity">
        /// The focus point's velocity measured in units per second, in world-space.
        /// </param>
        /// <remarks>
        /// <para>
        /// This focus point must be explicitly set as the focus point to be used.
        /// </para>
        /// <para>
        /// A <see cref="Result.NoConnection"/> error occurs if this is called while there is no connection to the server.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.FocusPointResult GetRemoteFocusPoint(out Microsoft.Azure.RemoteRendering.Float3 position, out Microsoft.Azure.RemoteRendering.Float3 normal, out Microsoft.Azure.RemoteRendering.Float3 velocity)
        {
            Microsoft.Azure.RemoteRendering.FocusPointResult result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_sim_d3d11_get_remote_focus_point(this.handle, out position, out normal, out velocity, out result));
            return result;
        }

    }

    /// <summary>
    /// D3D11 binding for Windows Mixed Reality.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Important: <c>RemoteManagerStatic.StartupRemoteRendering</c> must be called before any Holographic space is created
    /// and before any Mirage API is called.
    /// </para>
    /// <para>
    /// At runtime the only thing that needs to be done by the user is to call <see cref="GraphicsBindingWmrD3d11.BlitRemoteFrame"/> to render the remote frame to the current render target.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.GraphicsBinding"/>
    public partial class GraphicsBindingWmrD3d11 : GraphicsBinding
    {
        internal GraphicsBindingWmrD3d11(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// Blits the current remote frame to the bound render target.
        /// </summary>
        /// <remarks>
        /// When this function is executed it is assumed that the color and depth buffers provided by Mirage are bound as the render target.
        /// This should be done as the very first thing in each frame as this function will overwrite all content in the target buffers.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result BlitRemoteFrame()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_wmr_d3d11_blit_remote_frame(this.handle, out result));
            return result;
        }

        /// <summary>
        /// Retrieves the remote focus point.
        /// </summary>
        /// <param name="coordinateSystem">
        /// The coordinate frame in which the focus point should be expressed. Passing an invalid coordinate system will result in invalid focus points.
        /// </param>
        /// <param name="position">
        /// The focus point's position in world-space.
        /// </param>
        /// <param name="normal">
        /// The focus point's normal in world-space.
        /// </param>
        /// <param name="velocity">
        /// The focus point's velocity measured in units per second, in world-space.
        /// </param>
        /// <remarks>
        /// <para>
        /// This focus point must be explicitly set as the focus point to be used.
        /// </para>
        /// <para>
        /// A <see cref="Result.NoConnection"/> error occurs if this is called while there is no connection to the server.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.FocusPointResult GetRemoteFocusPoint(System.IntPtr coordinateSystem, out Microsoft.Azure.RemoteRendering.Float3 position, out Microsoft.Azure.RemoteRendering.Float3 normal, out Microsoft.Azure.RemoteRendering.Float3 velocity)
        {
            Microsoft.Azure.RemoteRendering.FocusPointResult result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_wmr_d3d11_get_remote_focus_point(this.handle, coordinateSystem, out position, out normal, out velocity, out result));
            return result;
        }

        /// <summary>
        /// Informs ARR of a new frame of reference.
        /// </summary>
        /// <param name="coordinateSystem">
        /// Pointer to ABI::Windows::Perception::Spatial::ISpatialCoordinateSystem.
        /// </param>
        /// <remarks>
        /// ARR must be informed whenever a new frame of reference is created and used as the new user coordinate system.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Result UpdateUserCoordinateSystem(System.IntPtr coordinateSystem)
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_graphics_binding_wmr_d3d11_update_user_coordinate_system(this.handle, coordinateSystem, out result));
            return result;
        }

    }

    /// <summary>
    /// Controls the visualization of sub-hierarchies of <see cref="Entity">entities</see>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.HierarchicalStates"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType,Microsoft.Azure.RemoteRendering.Entity)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/override-hierarchical-state"/>
    public partial class HierarchicalStateOverrideComponent : ComponentBase
    {
        internal HierarchicalStateOverrideComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The color to use for tinting the meshes below this node.
        /// </summary>
        /// <remarks>
        /// The tint color is only used if the <see cref="HierarchicalStateOverrideComponent.UseTintColorState"/> is set to <see cref="HierarchicalEnableState.ForceOn"/>.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Color4Ub TintColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4Ub result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_tint_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_tint_color(this.handle, value));
            }
        }

        /// <summary>
        /// The cut plane filter mask of this component.
        /// </summary>
        public byte CutPlaneFilterMask
        {
            get
            {
                byte result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_cut_plane_filter_mask(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_cut_plane_filter_mask(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the <see cref="HierarchicalStates.Hidden"/> feature.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState HiddenState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_hidden_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_hidden_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the <see cref="HierarchicalStates.Selected"/> feature.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState SelectedState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_selected_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_selected_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the <see cref="HierarchicalStates.SeeThrough"/> feature.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState SeeThroughState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_see_through_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_see_through_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the <see cref="HierarchicalStates.UseTintColor"/> feature.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState UseTintColorState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_use_tint_color_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_use_tint_color_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the HierarchicalStateFlags.UseCutPlaneFilterMask feature
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState UseCutPlaneFilterMaskState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_use_cut_plane_filter_mask_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_use_cut_plane_filter_mask_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the <see cref="HierarchicalStates.DisableCollision"/> feature.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState DisableCollisionState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_disable_collision_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_disable_collision_state(this.handle, value));
            }
        }

        /// <summary>
        /// Wraps around GetState/SetState for the <see cref="HierarchicalStates.Shell"/> feature.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState ShellState
        {
            get
            {
                Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_shell_state(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_shell_state(this.handle, value));
            }
        }

        /// <summary>
        /// Sets specific features to a new state of type <see cref="HierarchicalEnableState"/>.
        /// </summary>
        /// <param name="feature">
        /// The feature(s) to modify. A bitwise combination of features can be passed here to modify multiple features simultaneously.
        /// </param>
        /// <param name="enabledState">
        /// The new state.
        /// </param>
        /// <remarks>
        /// <para>
        /// * A <see cref="Result.InvalidParam"/> error occurs if 'feature' is an invalid bitmask.
        /// * A <see cref="Result.InvalidParam"/> error occurs if 'enabledState' is an invalid value.
        /// </para>
        /// </remarks>
        public void SetState(Microsoft.Azure.RemoteRendering.HierarchicalStates feature, Microsoft.Azure.RemoteRendering.HierarchicalEnableState enabledState)
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_set_state(this.handle, feature, enabledState));
        }

        /// <summary>
        /// Returns the current <see cref="HierarchicalEnableState">enabled state</see> of a feature.
        /// </summary>
        /// <param name="feature">
        /// A single feature to query the current status on. Unlike SetState, multiple feature bits cannot be combined here.
        /// </param>
        /// <remarks>
        /// <para>
        /// * A <see cref="Result.InvalidParam"/> error occurs if 'feature' is an invalid bitmask.
        /// * A <see cref="Result.InvalidParam"/> error occurs if 'enabledState' is an invalid value.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.HierarchicalEnableState GetState(Microsoft.Azure.RemoteRendering.HierarchicalStates feature)
        {
            Microsoft.Azure.RemoteRendering.HierarchicalEnableState result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_hierarchical_state_override_component_get_state(this.handle, feature, out result));
            return result;
        }

    }

    /// <summary>
    /// Base class for all light components.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Attaching a light component to an <see cref="Entity"/> turns it into a dynamic light source that illuminates the geometry
    /// in addition to the <see cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/sky">global sky light</see>. The position and orientation of the entity determines the location and direction of the light.
    /// </para>
    /// <para>
    /// Only geometry that uses a <see cref="PbrMaterial"/> will be affected by this light. Geometry that has a <see cref="ColorMaterial"/> assigned generally receives no lighting.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PointLightComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SpotLightComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.DirectionalLightComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType,Microsoft.Azure.RemoteRendering.Entity)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/lights">Scene lighting</seealso>
    public partial class LightComponentBase : ComponentBase
    {
        internal LightComponentBase(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The overall brightness and range of the light.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This value has no physical unit, however, it can be considered to be proportional to the physical power of the light source.
        /// </para>
        /// <para>
        /// For lights that have a falloff (<see cref="SpotLightComponent"/> and <see cref="PointLightComponent"/>), the intensity determines both brightness and range of influence. For infinite light sources (<see cref="DirectionalLightComponent"/>) it only determines the brightness.
        /// </para>
        /// <para>
        /// At an intensity of 1000 a point light roughly has a range of 100 world units. However, note that this doesn't scale linearly.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        public float Intensity
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_light_component_base_get_intensity(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_light_component_base_set_intensity(this.handle, value));
            }
        }

        /// <summary>
        /// The color of the light in Gamma color space.
        /// </summary>
        /// <remarks>
        /// The color's alpha channel is ignored.
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.Color4Ub"/>
        public Microsoft.Azure.RemoteRendering.Color4Ub Color
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4Ub result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_light_component_base_get_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_light_component_base_set_color(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Result data for a load model request.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelOptions)"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadModelFromSasAsync(Microsoft.Azure.RemoteRendering.LoadModelFromSasOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
    public partial class LoadModelResult
    {
        internal IntPtr handle;

        internal LoadModelResult(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_addref(ahandle);
        }

        ~LoadModelResult()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Root <see cref="Entity"/> of the loaded model.
        /// </summary>
        /// <remarks>
        /// This is the top most <see cref="Entity"/> node in the model structure. You can place the model by setting this node's transform (see <see cref="Entity.Position"/>, <see cref="Entity.Rotation"/>, <see cref="Entity.Scale"/>).
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Entity Root
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Entity result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_get_root(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Entity(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Retrieves all objects of the given type that were loaded as part of this model.
        /// </summary>
        /// <param name="type">
        /// The requested type must specify a valid object type such as <see cref="ObjectType.Entity"/> or <see cref="ObjectType.MeshComponent"/>.
        /// </param>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if 'type' is outside the specified range.
        /// </para>
        /// </remarks>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ObjectBase> GetLoadedObjectsOfType(Microsoft.Azure.RemoteRendering.ObjectType type)
        {
            System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ObjectBase> result;
            ulong[] result_array;
            int result_length;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_get_loaded_objects_of_type(this.handle, type, out result_array, out result_length));
            result = result_array?.Select(handle => Factories.ObjectBaseFactory(handle, transfer:true)).ToArray() ?? Array.Empty<Microsoft.Azure.RemoteRendering.ObjectBase>();
            return result;
        }

        /// <summary>
        /// Retrieves all resources of the given type that were loaded as part of this model.
        /// </summary>
        /// <param name="type">
        /// The requested type must specify a valid resource type such as <see cref="ObjectType.Mesh"/> or <see cref="ObjectType.Material"/>.
        /// </param>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if 'type' is outside the specified range.
        /// </para>
        /// </remarks>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ResourceBase> GetLoadedResourceOfType(Microsoft.Azure.RemoteRendering.ObjectType type)
        {
            System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ResourceBase> result;
            ulong[] result_array;
            int result_length;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_load_model_result_get_loaded_resource_of_type(this.handle, type, out result_array, out result_length));
            result = result_array?.Select(handle => Factories.ResourceBaseFactory(handle, transfer:true)).ToArray() ?? Array.Empty<Microsoft.Azure.RemoteRendering.ResourceBase>();
            return result;
        }

    }

    /// <summary>
    /// Materials are shared resources used to describe the rendering properties of a <see cref="Mesh"/>.
    /// </summary>
    /// <remarks>
    /// <para>
    /// A material specifies which <see cref="Texture">textures</see> to use and how to apply lighting to geometry. This class is the base class for all material resources. Derived classes determine the exact appearance.
    /// </para>
    /// <para>
    /// If a material is modified, all meshes that reference the material will be affected. To modify only the material of a specific object
    /// you need to create a dedicated material and replace the material reference on the <see cref="MeshComponent"/> to point to the custom material.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PbrMaterial"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ColorMaterial"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.MeshComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.CreateMaterial(Microsoft.Azure.RemoteRendering.MaterialType)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/materials">Materials</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/lifetime">Object and resource lifetime</seealso>
    public partial class Material : ResourceBase
    {
        internal Material(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this resource.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Whether this resource is still valid.
        /// </summary>
        /// <remarks>
        /// A resource is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The name of this material.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.StringTooLong"/> error occurs if the given string is excessively long.
        /// </para>
        /// </remarks>
        public string Name
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_get_name(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_set_name(this.handle, value));
            }
        }

        public Microsoft.Azure.RemoteRendering.MaterialType MaterialSubType
        {
            get
            {
                Microsoft.Azure.RemoteRendering.MaterialType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_get_material_sub_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Copies material properties from another material.
        /// </summary>
        /// <param name="other">
        /// The material from which to copy properties.
        /// </param>
        /// <remarks>
        /// <para>
        /// If the material types don't match, only common properties such as albedo color and texture are copied.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if 'other' is an invalid material.
        /// </para>
        /// </remarks>
        public void CopyFrom(Microsoft.Azure.RemoteRendering.Material other)
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_material_copy_from(this.handle, other != null ? other.handle : default(ulong)));
        }

    }

    /// <summary>
    /// Renders a mesh at the position of the <see cref="Entity"/>.
    /// </summary>
    /// <remarks>
    /// The referenced <see cref="MeshComponent.Mesh"/> is rendered at the location of the owner entity. The mesh component also allows to override the <see cref="Material">materials</see> that are used for rendering. If the mesh has been converted with collision information, it will also participate in <see cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">spatial queries</see>.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.MeshComponent.Mesh"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Material"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType,Microsoft.Azure.RemoteRendering.Entity)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/meshes">Meshes</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial queries</seealso>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/materials">Materials</seealso>
    public partial class MeshComponent : ComponentBase
    {
        internal MeshComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// Returns the list of materials set on this component.
        /// </summary>
        /// <remarks>
        /// These are materials that were specifically set to override the default mesh materials, through SetMaterial().
        /// The array will always be the same size as <see cref="Mesh.Materials"/>, however, entries for which no override is set, will be <c>null</c>.
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.MeshComponent.UsedMaterials"/>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> Materials
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_get_materials(this.handle, out result_array, out result_length));
                result = result_array?.Select(handle => Factories.MaterialFactory(handle, transfer:true)).ToArray() ?? Array.Empty<Microsoft.Azure.RemoteRendering.Material>();
                return result;
            }
        }

        /// <summary>
        /// Returns the list of actually used materials for rendering the mesh.
        /// </summary>
        /// <remarks>
        /// The array will either contain the override material (<see cref="MeshComponent.Materials"/>) or, if no override was set,
        /// the default material of the referenced <see cref="MeshComponent.Mesh"/>.
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.MeshComponent.Materials"/>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> UsedMaterials
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_get_used_materials(this.handle, out result_array, out result_length));
                result = result_array?.Select(handle => Factories.MaterialFactory(handle, transfer:true)).ToArray() ?? Array.Empty<Microsoft.Azure.RemoteRendering.Material>();
                return result;
            }
        }

        /// <summary>
        /// The <see cref="Mesh"/> used for rendering and spatial queries.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Mesh Mesh
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Mesh result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_get_mesh(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Mesh(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_set_mesh(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Sets an override material for a given material slot.
        /// </summary>
        /// <param name="idx">
        /// A valid index into the <see cref="MeshComponent.Materials"/> array.
        /// </param>
        /// <param name="material">
        /// The material to set as the override. Passing <c>null</c> clears any previous override, such that the mesh's default material is used again.
        /// </param>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.IndexOutOfRange"/> error occurs if 'idx' is outside the valid range.
        /// </para>
        /// </remarks>
        public void SetMaterial(int idx, Microsoft.Azure.RemoteRendering.Material material)
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_component_set_material(this.handle, idx, material != null ? material.handle : default(ulong)));
        }

    }

    /// <summary>
    /// Meshes contain geometry data and <see cref="Material"/> references for rendering.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Meshes can't be loaded directly, instead when a model is loaded, for instance through <see cref="RenderingConnection.LoadModelAsync(LoadModelOptions)"/>, the loaded model contains at least one <see cref="Entity"/> which has a <see cref="MeshComponent"/> which in turn references a mesh. Once a model is loaded, you can get the mesh reference and also assign it to other objects.
    /// </para>
    /// <para>
    /// Mesh data can't be modified at runtime. It is possible to modify the materials that a mesh references, however, that would affect all entities which use that mesh. Instead, the preferred method is to specify override materials on a <see cref="MeshComponent"/> to change which materials are used for rendering.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Material"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.MeshComponent"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/meshes">Meshes</seealso>
    public partial class Mesh : ResourceBase
    {
        internal Mesh(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this resource.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Whether this resource is still valid.
        /// </summary>
        /// <remarks>
        /// A resource is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The list of materials used for rendering the mesh, unless overridden by a <see cref="MeshComponent"/>.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> Materials
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.Material> result;
                ulong[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_get_materials(this.handle, out result_array, out result_length));
                result = result_array?.Select(handle => Factories.MaterialFactory(handle, transfer:true)).ToArray() ?? Array.Empty<Microsoft.Azure.RemoteRendering.Material>();
                return result;
            }
        }

        /// <summary>
        /// Returns the local-space bounding box of the mesh.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Bounds Bounds
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Bounds result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_mesh_get_bounds(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// Base class for <see cref="Entity">entities</see> and <see cref="ComponentBase">components</see>.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Entity"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ComponentBase"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/lifetime">Object and resource lifetime</seealso>
    public partial class ObjectBase
    {
        internal ulong handle;

        internal ObjectBase(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        protected ObjectBase()
        {
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_base_create(out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_base_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this object.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_base_get_type(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// A single metadata entry for an object.
    /// </summary>
    /// <remarks>
    /// Lifetime is managed by the owning metadata container (<see cref="ObjectMetadata"/>).
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ObjectMetadata"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.MetadataValueType"/>
    public partial class ObjectMetadataEntry
    {
        internal IntPtr handle;

        internal ObjectMetadataEntry(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        /// <summary>
        /// Name of this metadata entry.
        /// </summary>
        public string Name
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_entry_get_name(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Type of this metadata. See <see cref="MetadataValueType"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.MetadataValueType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.MetadataValueType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_entry_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the value of this metadata as a bool.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidType"/> error occurs if this is called although <see cref="ObjectMetadataEntry.Type"/> doesn't match.
        /// </remarks>
        public bool AsBool
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_entry_get_as_bool(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the value of this metadata as an Int32.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidType"/> error occurs if this is called although <see cref="ObjectMetadataEntry.Type"/> doesn't match.
        /// </remarks>
        public int AsInt
        {
            get
            {
                int result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_entry_get_as_int(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the value of this metadata as an Int64.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidType"/> error occurs if this is called although <see cref="ObjectMetadataEntry.Type"/> doesn't match.
        /// </remarks>
        public long AsInt64
        {
            get
            {
                long result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_entry_get_as_int64(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the value of this metadata as a UInt64.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidType"/> error occurs if this is called although <see cref="ObjectMetadataEntry.Type"/> doesn't match.
        /// </remarks>
        public ulong AsUInt64
        {
            get
            {
                ulong result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_entry_get_as_uint64(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the value of this metadata as a double.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidType"/> error occurs if this is called although <see cref="ObjectMetadataEntry.Type"/> doesn't match.
        /// </remarks>
        public double AsDouble
        {
            get
            {
                double result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_entry_get_as_double(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the value of this metadata as a string.
        /// </summary>
        /// <remarks>
        /// A <see cref="Result.InvalidType"/> error occurs if this is called although <see cref="ObjectMetadataEntry.Type"/> doesn't match.
        /// </remarks>
        public string AsString
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_entry_get_as_string(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// A collection of metadata values for an object.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ObjectMetadataEntry"/>
    public partial class ObjectMetadata
    {
        internal IntPtr handle;

        internal ObjectMetadata(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_addref(ahandle);
        }

        ~ObjectMetadata()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Provides read-only access to all entries in this collection.
        /// </summary>
        public System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ObjectMetadataEntry> Metadata
        {
            get
            {
                System.Collections.Generic.IReadOnlyList<Microsoft.Azure.RemoteRendering.ObjectMetadataEntry> result;
                IntPtr[] result_array;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_get_metadata(this.handle, out result_array, out result_length));
                result = result_array?.Select(handle => new Microsoft.Azure.RemoteRendering.ObjectMetadataEntry(handle, transfer:true)).ToArray() ?? Array.Empty<Microsoft.Azure.RemoteRendering.ObjectMetadataEntry>();
                return result;
            }
        }

        /// <summary>
        /// Query for an entry by name.
        /// </summary>
        /// <param name="name">
        /// The name of the entry to search.
        /// </param>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if no meta data of the requested name exists.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.ObjectMetadataEntry GetMetadataByName(string name)
        {
            IntPtr result_handle;
            Microsoft.Azure.RemoteRendering.ObjectMetadataEntry result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_object_metadata_get_metadata_by_name(this.handle, name, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? new Microsoft.Azure.RemoteRendering.ObjectMetadataEntry(result_handle, transfer:true) : null;
            return result_object;
        }

    }

    /// <summary>
    /// Global settings for outline rendering.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/outlines">Outline rendering</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.OutlineSettings"/>
    public partial class OutlineSettings
    {
        internal ulong handle;

        internal OutlineSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The color of the outlines.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Color4Ub Color
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4Ub result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_get_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_set_color(this.handle, value));
            }
        }

        /// <summary>
        /// The rate (in Hz) at which the outline intensity oscillates.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        public float PulseRateHz
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_get_pulse_rate_hz(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_set_pulse_rate_hz(this.handle, value));
            }
        }

        /// <summary>
        /// The intensity with which the outline pulses.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This value must be in (0..1) range with 0=no pulsing effect and 1=full amplitude.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float PulseIntensity
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_get_pulse_intensity(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_outline_settings_set_pulse_intensity(this.handle, value));
            }
        }

    }

    /// <summary>
    /// A material for Physically Based Rendering.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Material"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.ColorMaterial"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.CreateMaterial(Microsoft.Azure.RemoteRendering.MaterialType)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/pbr-materials">PBR materials</seealso>
    public partial class PbrMaterial : Material
    {
        internal PbrMaterial(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The <see cref="PbrMaterialFeatures">PBR material flags</see>.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if an invalid flags bitmask is set.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.PbrMaterialFeatures PbrFlags
        {
            get
            {
                Microsoft.Azure.RemoteRendering.PbrMaterialFeatures result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_pbr_flags(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_pbr_flags(this.handle, value));
            }
        }

        /// <summary>
        /// Scaling factors for texture coordinates.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Used to repeat/tile textures. For instance passing (4, 2) will repeat the texture 4 times along the U texture coordinate, and 2 times along V.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is NaN or infinite.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.PbrMaterial.TexCoordOffset"/>
        public Microsoft.Azure.RemoteRendering.Float2 TexCoordScale
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_tex_coord_scale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_tex_coord_scale(this.handle, value));
            }
        }

        /// <summary>
        /// Constant offset added to texture coordinates.
        /// </summary>
        /// <remarks>
        /// <para>
        /// An offset is normalized to [0..1] range, regardless of texture size, so (0.5, 0.5) always points to the middle of a texture.
        /// The offset can be changed over time to scroll the texture.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is NaN or infinite.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Float2 TexCoordOffset
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_tex_coord_offset(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_tex_coord_offset(this.handle, value));
            }
        }

        /// <summary>
        /// Constant albedo color.
        /// </summary>
        /// <remarks>
        /// This color is modulated with the color from the <see cref="PbrMaterial.AlbedoTexture"/>.
        /// The alpha channel represents the opacity, in case the material is flagged as transparent (<see cref="PbrMaterialFeatures.TransparentMaterial"/>).
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Color4 AlbedoColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_albedo_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_albedo_color(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="Texture"/> used for the albedo color. Pass in <c>null</c> if no dedicated texture is needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture AlbedoTexture
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_albedo_texture(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_albedo_texture(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Determines how the alpha channel of vertex colors is used. See <see cref="PbrVertexAlphaMode"/> for details.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This mode has no effect if the mesh doesn't provide vertex colors or if the flag <see cref="PbrMaterialFeatures.UseVertexColor"/> is not set.
        /// The default value is <see cref="PbrVertexAlphaMode.Occlusion"/>.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if an unknown mode is passed in.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.PbrVertexAlphaMode PbrVertexAlphaMode
        {
            get
            {
                Microsoft.Azure.RemoteRendering.PbrVertexAlphaMode result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_pbr_vertex_alpha_mode(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_pbr_vertex_alpha_mode(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="Texture"/> used as the normal map. Pass in <c>null</c> if no dedicated texture is needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Although any texture can be used, note that a valid normalmap encodes the normal vector into RGB portions, rather than being a grayscale heightmap.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture NormalMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_normal_map(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_normal_map(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// How strongly to apply ambient occlusion to this material. [0..1] range.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float AOScale
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_aoscale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_aoscale(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="Texture"/> used for ambient occlusion. Pass in <c>null</c> if no dedicated texture is needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A valid AO texture is a grayscale texture that defines which areas are occluded (dark/black) and which ones aren't (bright/white).
        /// The AO value from the texture will be modulated with the <see cref="PbrMaterial.AOScale"/> property.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture AOMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_aomap(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_aomap(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// A constant roughness value.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Roughness is a scalar in the [0..1] range. 
        /// The roughness constant is only used if no <see cref="PbrMaterial.RoughnessMap"/> is provided.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float Roughness
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_roughness(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_roughness(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="Texture"/> used for roughness. Pass in <c>null</c> if no dedicated texture is needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A valid roughness texture is a grayscale texture that defines which areas are rough (values close to 1.0) and which are smooth (values close to 0.0).
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture RoughnessMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_roughness_map(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_roughness_map(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// A constant metalness value.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Metalness is a scalar in the [0..1] range, which in most of the use cases is either 0.0 (non-metallic) or 1.0 (metallic).
        /// The metalness constant is only used if no <see cref="PbrMaterial.MetalnessMap"/> is provided.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float Metalness
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_metalness(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_metalness(this.handle, value));
            }
        }

        /// <summary>
        /// The <see cref="Texture"/> used for metalness. Pass in <c>null</c> if no dedicated texture is needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A valid metalness texture is a grayscale texture that defines which areas should be considered metal (1.0) and which areas are non-metals (0.0). Values in between are possible, but are not physically plausible.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture MetalnessMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_metalness_map(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_metalness_map(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

        /// <summary>
        /// Threshold that is used for alpha cutouts.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If a pixel's final alpha value falls below this threshold, the pixel is clipped, creating a hard cutout.
        /// Note that the material's <see cref="PbrMaterialFeatures.AlphaClipped"/> flag has to be set, for this threshold to have an effect.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float AlphaClipThreshold
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_alpha_clip_threshold(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_alpha_clip_threshold(this.handle, value));
            }
        }

        /// <summary>
        /// Fade-out value in the [0..1] range, where 0.0 means fully faded out and 1.0 means fully opaque.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is very similar to changing the albedo's alpha on a transparent material, however, this function automatically manages the transparency flag for values of 1.0 (fully opaque) and smaller than 1.0 (semi-transparent).
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside [0..1] range.
        /// </para>
        /// </remarks>
        public float FadeOut
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_fade_out(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_fade_out(this.handle, value));
            }
        }

        /// <summary>
        /// The Fresnel effect color used when the effect is enabled (see the 'FresnelEffect' flag in <see cref="PbrMaterialFeatures"/>)
        /// </summary>
        /// <remarks>
        /// Only the rgb channels of the color are used for the Fresnel effect, while the alpha value will be ignored.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Color4 FresnelEffectColor
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Color4 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_fresnel_effect_color(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_fresnel_effect_color(this.handle, value));
            }
        }

        /// <summary>
        /// The Fresnel effect exponent used when the effect is enabled (see the 'FresnelEffect' flag in <see cref="PbrMaterialFeatures"/>)
        /// </summary>
        /// <remarks>
        /// The valid range for the exponent is [0.01, 10].
        /// </remarks>
        public float FresnelEffectExponent
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_get_fresnel_effect_exponent(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_pbr_material_set_fresnel_effect_exponent(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Settings for point cloud rendering (experimental).
    /// </summary>
    /// <seealso cref="RenderingConnection.PointCloudSettings"/>
    public partial class PointCloudSettings
    {
        internal ulong handle;

        internal PointCloudSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_cloud_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// A global size override for point cloud's local-space point sizes, specified in meters (e.g. 0.1 = 10cm). Value of -1.0 results in override to have not effect on point sizes. The default value is -1.0.
        /// </summary>
        /// <remarks>
        /// In case point size override is applied, points scaling (applicable through PointSizeScale) is still applied on top of it.
        /// </remarks>
        public float PointSizeOverride
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_cloud_settings_get_point_size_override(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_cloud_settings_set_point_size_override(this.handle, value));
            }
        }

        /// <summary>
        /// A global size multiplier for point sizes when rendering point clouds. The default scale is 1.0.
        /// </summary>
        public float PointSizeScale
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_cloud_settings_get_point_size_scale(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_cloud_settings_set_point_size_scale(this.handle, value));
            }
        }

    }

    /// <summary>
    /// A light source that emits light uniformly into all directions.
    /// </summary>
    /// <remarks>
    /// Point lights are used for local lights such as light bulbs.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.LightComponentBase"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.SpotLightComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.DirectionalLightComponent"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/lights">Scene lighting</seealso>
    public partial class PointLightComponent : LightComponentBase
    {
        internal PointLightComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The radius of the light emitting shape.
        /// </summary>
        /// <remarks>
        /// <para>
        /// By default the radius is zero and the emitting shape is just a point.
        /// If the radius is set to a larger value, the shape becomes a sphere or even a tube, if <see cref="PointLightComponent.Length"/> is also set.
        /// </para>
        /// <para>
        /// A non-zero radius yields more realistic lighting for light bulbs and other objects that have a glowing
        /// surface. However, for performance reasons the computation is only an approximation of an area light. If such a light source comes too close to geometry or even intersects with it, the resulting lighting won't be physically correct.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        public float Radius
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_get_radius(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_set_radius(this.handle, value));
            }
        }

        /// <summary>
        /// The length of the light emitting shape.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.PointLightComponent.Radius"/>
        public float Length
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_get_length(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_set_length(this.handle, value));
            }
        }

        /// <summary>
        /// Custom interval of min/max distances over which the light's attenuated intensity is scaled down to zero.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This option can be used to enforce a smaller range of influence.
        /// By default these values are implicitly derived from the light's <see cref="LightComponentBase.Intensity">intensity</see>.
        /// Use this option if you want to create a light source that should be bright, but with a relatively small area of influence.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Float2 AttenuationCutoff
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_get_attenuation_cutoff(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_set_attenuation_cutoff(this.handle, value));
            }
        }

        /// <summary>
        /// Optional cubemap <see cref="Texture"/> to be projected onto surrounding geometry.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The orientation of the owner <see cref="Entity"/> determines how the cubemap is projected onto surrounding geometry.
        /// The color from the cubemap is used to modulate the light's color.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a cubemap.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture ProjectedCubeMap
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_get_projected_cube_map(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_point_light_component_set_projected_cube_map(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

    }

    public partial class RayCastQueryResult
    {
        internal IntPtr handle;

        internal RayCastQueryResult(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_ray_cast_query_result_addref(ahandle);
        }

        ~RayCastQueryResult()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_ray_cast_query_result_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// A (potentially empty) array of <see cref="RayCastHit">intersections</see> that the raycast encountered.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RayCastHit[] Hits
        {
            get
            {
                Microsoft.Azure.RemoteRendering.RayCastHitAbi[] result;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_ray_cast_query_result_get_hits(this.handle, out result, out result_length));
                return result?.Select(x => x.Convert()).ToArray() ?? null;
            }
        }

    }

    /// <summary>
    /// RemoteRenderingClient is an authorized connection to the Azure APIs for Remote Rendering.
    /// </summary>
    /// <remarks>
    /// It is the main entry point for users to use remote rendering. Use this to create <see cref="RenderingSession"/> instances.
    /// </remarks>
    public partial class RemoteRenderingClient : IDisposable, ICachedObject
    {
        internal ulong handle;

        internal RemoteRenderingClient(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_addref(ahandle);
        }

        public RemoteRenderingClient(Microsoft.Azure.RemoteRendering.SessionConfiguration configuration)
        {
            Microsoft.Azure.RemoteRendering.SessionConfigurationAbi configuration_converted = configuration.Convert();
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_create_session_configuration_configuration(configuration_converted, out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="RemoteRenderingClient"/> class.
        /// </summary>
        ~RemoteRenderingClient()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.arr_remote_rendering_client_release(this.handle));
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.arr_remote_rendering_client_dispose(this.handle));
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Only messages at this <see cref="LogLevel">log level</see> or below will be delivered through <see cref="RemoteRenderingClient.MessageLogged"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LogLevel LogLevel
        {
            get
            {
                Microsoft.Azure.RemoteRendering.LogLevel result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_get_log_level(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_set_log_level(this.handle, value));
            }
        }

        /// <summary>
        /// Parameters with which this instance was initialized.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.SessionConfiguration Configuration
        {
            get
            {
                Microsoft.Azure.RemoteRendering.SessionConfigurationAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_get_configuration(this.handle, out result));
                return result.Convert();
            }
        }

        /// <summary>Static handler.</summary>
        [AOT.MonoPInvokeCallback(typeof(LogEventHandlerNative))]
        private static void MessageLoggedStaticHandler(ulong cookie, Microsoft.Azure.RemoteRendering.LogLevel level, System.IntPtr message)
        {
            try
            {
                Microsoft.Azure.RemoteRendering.RemoteRenderingClient instance = GetInstance(cookie);

                if (instance == null)
                {
                    throw new System.InvalidOperationException("The object instance is not tracked by the cache.");
                }

                Microsoft.Azure.RemoteRendering.LogEventHandler handler =
                    Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.GetEventHandler<Microsoft.Azure.RemoteRendering.LogEventHandler>(
                        instance,
                        nameof(MessageLogged));

                handler?.Invoke(level, message);
            }
            catch (Exception e)
            {
                // We must not throw during a reverse p-invoke or else mono will unroll our native stack
                // without any kind of graceful destruction
                Debug.LogException(e);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.LogEventHandlerNative MessageLoggedStaticHandlerDelegate = MessageLoggedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.LogEventHandler MessageLogged
        {
            add
            {
                Microsoft.Azure.RemoteRendering.ProjectedObjectCache.Add(this);
                Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.AddEventHandler(this, nameof(this.MessageLogged), value);
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_set_message_logged(this.handle, ((ICachedObject)this).Cookie, MessageLoggedStaticHandlerDelegate));
            }
            remove
            {
                Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.RemoveEventHandler(this, nameof(this.MessageLogged), value);
            }
        }

        /// <summary>Static handler.</summary>
        [AOT.MonoPInvokeCallback(typeof(TokenRequiredEventHandlerNative))]
        private static void TokenRequiredStaticHandler(ulong cookie, IntPtr args)
        {
            try
            {
                Microsoft.Azure.RemoteRendering.RemoteRenderingClient instance = GetInstance(cookie);

                if (instance == null)
                {
                    throw new System.InvalidOperationException("The object instance is not tracked by the cache.");
                }

                Microsoft.Azure.RemoteRendering.TokenRequiredEventHandler handler =
                    Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.GetEventHandler<Microsoft.Azure.RemoteRendering.TokenRequiredEventHandler>(
                        instance,
                        nameof(TokenRequired));

                handler?.Invoke(instance, new Microsoft.Azure.RemoteRendering.TokenRequiredEventArgs(args, transfer: false));
            }
            catch (Exception e)
            {
                // We must not throw during a reverse p-invoke or else mono will unroll our native stack
                // without any kind of graceful destruction
                Debug.LogException(e);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.TokenRequiredEventHandlerNative TokenRequiredStaticHandlerDelegate = TokenRequiredStaticHandler;
        public event Microsoft.Azure.RemoteRendering.TokenRequiredEventHandler TokenRequired
        {
            add
            {
                Microsoft.Azure.RemoteRendering.ProjectedObjectCache.Add(this);
                Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.AddEventHandler(this, nameof(this.TokenRequired), value);
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_set_token_required(this.handle, ((ICachedObject)this).Cookie, TokenRequiredStaticHandlerDelegate));
            }
            remove
            {
                Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.RemoveEventHandler(this, nameof(this.TokenRequired), value);
            }
        }

        /// <summary>
        /// Queries for all existing rendering sessions for the account associated with this client.
        /// </summary>
        /// <remarks>
        /// Since the underlying call is a REST call, there should be sufficient delay (5-10s) between subsequent calls to avoid server throttling.
        /// In case of throttling, the function will fail and the <see cref="SessionGeneralContext.HttpResponseCode">HttpResponseCode</see> reports code 429 ("too many requests").
        /// The returned async will complete in an arbitrary thread.
        /// </remarks>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesArrayResult> GetCurrentRenderingSessionsAsync()
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesArrayResult(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_get_current_rendering_sessions_async(this.handle, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Opens an existing rendering session.
        /// </summary>
        /// <param name="sessionId">
        /// The UUID of a rendering session.
        /// </param>
        /// <remarks>
        /// The session id can be created through <see cref="RemoteRenderingClient.CreateNewRenderingSessionAsync(RenderingSessionCreationOptions)"/>, as well as through external tooling such as PowerShell.
        /// </remarks>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.CreateRenderingSessionResult> OpenRenderingSessionAsync(string sessionId)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.CreateRenderingSessionResult(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_open_rendering_session_async(this.handle, sessionId, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Creates a new rendering session.
        /// </summary>
        /// <param name="options">
        /// Session creation parameters
        /// </param>
        /// <remarks>
        /// This spins up a new server in the Azure cloud.
        /// Once ready, CreateSessionAsync returns the created RenderingSession object or an error context.
        /// </remarks>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.CreateRenderingSessionResult> CreateNewRenderingSessionAsync(Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptions options)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.CreateRenderingSessionResult(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsAbi options_converted = options.Convert();
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_create_new_rendering_session_async(this.handle, options_converted, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Internal.
        /// </summary>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.CreateRenderingSessionResult> CreateNewRenderingSessionUnsafeAsync(Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafe options)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.CreateRenderingSessionResult(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.RenderingSessionCreationOptionsUnsafeAbi options_converted = options.Convert();
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_create_new_rendering_session_unsafe_async(this.handle, options_converted, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Starts converting an asset.
        /// </summary>
        /// <param name="conversionOptions">
        /// Conversion properties. Includes the conversion id, the asset input information, and the output information
        /// </param>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.AssetConversionResult> StartAssetConversionAsync(Microsoft.Azure.RemoteRendering.AssetConversionOptions conversionOptions)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.AssetConversionResult(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.AssetConversionOptionsAbi conversionOptions_converted = conversionOptions.Convert();
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_start_asset_conversion_async(this.handle, conversionOptions_converted, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Deprecated. Use GetConversionPropertiesAsync() instead.
        /// </summary>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.AssetConversionStatusResult> GetAssetConversionStatusAsync(string conversionId)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.AssetConversionStatusResult(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_get_asset_conversion_status_async(this.handle, conversionId, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Queries the properties of an asset conversion.
        /// </summary>
        /// <param name="conversionId">
        /// The conversion ID returned by StartAssetConversionAsync.
        /// </param>
        /// <remarks>
        /// <para>
        /// Since the underlying call is a REST call, there should be sufficient delay (5-10s) between subsequent calls to avoid server throttling.
        /// In case of throttling, the function will fail and the <see cref="SessionGeneralContext.HttpResponseCode">HttpResponseCode</see> reports code 429 ("too many requests").
        /// </para>
        /// <para>
        /// * A <see cref="Result.InvalidParam"/> error occurs if no conversionId is provided, or the rendering service URL was empty, because the account domain and account Id was not provided.
        /// * A <see cref="Result.AuthenticationFailed"/> error occurs if the request could not be authenticated.
        /// * A <see cref="Result.TooManyRequests"/> error occurs if the rate limit has been exceeded. Retry the request after the duration given in the Retry-After header.
        /// </para>
        /// </remarks>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.ConversionPropertiesResult> GetConversionPropertiesAsync(string conversionId)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.ConversionPropertiesResult(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_get_conversion_properties_async(this.handle, conversionId, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Queries for all asset conversions of the last 30 days for the account associated with this client.
        /// </summary>
        /// <remarks>
        /// Since the underlying call is a REST call, there should be sufficient delay (5-10s) between subsequent calls to avoid server throttling.
        /// In case of throttling, the function will fail and the <see cref="SessionGeneralContext.HttpResponseCode">HttpResponseCode</see> reports code 429 ("too many requests").
        /// The returned async will complete in an arbitrary thread.
        /// </remarks>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.ConversionPropertiesArrayResult> GetCurrentConversionsAsync()
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.ConversionPropertiesArrayResult(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_remote_rendering_client_get_current_conversions_async(this.handle, promise_.Handle));
                return await promise_.Task;
            }
        }

        ulong ICachedObject.Cookie => ConvertHandleToCookie(this.handle);

        private static readonly Func<ulong, Microsoft.Azure.RemoteRendering.RemoteRenderingClient> createFromCookieFactoryFunction =
            cookie => new Microsoft.Azure.RemoteRendering.RemoteRenderingClient(cookie, transfer: false);

        internal static Microsoft.Azure.RemoteRendering.RemoteRenderingClient GetInstance(ulong cookie)
            => Microsoft.Azure.RemoteRendering.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.RemoteRendering.RemoteRenderingClient>(cookie, createFromCookieFactoryFunction);

        private static ulong ConvertHandleToCookie(ulong handle)
        {
            if (handle == default(ulong))
            {
                throw new ArgumentException("Invalid handle.", nameof(handle));
            }

            return handle;
        }
    }

    /// <summary>
    /// Main entry point for Remote Rendering specific actions. Can be accessed via RenderingSession.Connection, after a successful connection.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession"/>
    public partial class RenderingConnection : ICachedObject
    {
        internal ulong handle;

        internal RenderingConnection(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        /// <summary>
        /// Only messages at this <see cref="LogLevel">log level</see> or below will be delivered through <see cref="RenderingConnection.MessageLogged"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.LogLevel LogLevel
        {
            get
            {
                Microsoft.Azure.RemoteRendering.LogLevel result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_get_log_level(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_set_log_level(this.handle, value));
            }
        }

        /// <summary>
        /// Global <see cref="CameraSettings">camera settings</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/camera">Camera</seealso>
        public Microsoft.Azure.RemoteRendering.CameraSettings CameraSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.CameraSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_get_camera_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.CameraSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global <see cref="StageSpaceSettings">stage space settings</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/stage-space">Stage space</seealso>
        public Microsoft.Azure.RemoteRendering.StageSpaceSettings StageSpaceSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.StageSpaceSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_get_stage_space_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.StageSpaceSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global <see cref="SkyReflectionSettings">sky reflection settings</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/sky">Sky reflections</seealso>
        public Microsoft.Azure.RemoteRendering.SkyReflectionSettings SkyReflectionSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.SkyReflectionSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_get_sky_reflection_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.SkyReflectionSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global <see cref="OutlineSettings">outline settings</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/outlines">Outline rendering</seealso>
        public Microsoft.Azure.RemoteRendering.OutlineSettings OutlineSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.OutlineSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_get_outline_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.OutlineSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global <see cref="ZFightingMitigationSettings">z-fighting mitigation state</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/z-fighting-mitigation">Z-fighting mitigation</seealso>
        public Microsoft.Azure.RemoteRendering.ZFightingMitigationSettings ZFightingMitigationSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.ZFightingMitigationSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_get_zfighting_mitigation_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.ZFightingMitigationSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global shell rendering settings.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/shell-rendering">Shell rendering</seealso>
        public Microsoft.Azure.RemoteRendering.ShellRenderingSettings ShellRenderingSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.ShellRenderingSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_get_shell_rendering_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.ShellRenderingSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global <see cref="SingleSidedSettings">single-sided rendering settings</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/single-sided-rendering">Single-sided rendering</seealso>
        public Microsoft.Azure.RemoteRendering.SingleSidedSettings SingleSidedSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.SingleSidedSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_get_single_sided_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.SingleSidedSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Experimental: Access the global point cloud settings.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.PointCloudSettings PointCloudSettings_Experimental
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.PointCloudSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_get_point_cloud_settings_experimental(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.PointCloudSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// Global <see cref="DebugRenderingSettings">debug rendering settings</see>.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/debug-rendering">Debug rendering</seealso>
        public Microsoft.Azure.RemoteRendering.DebugRenderingSettings DebugRenderingSettings
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.DebugRenderingSettings result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_get_debug_rendering_settings(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.DebugRenderingSettings(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>Static handler.</summary>
        [AOT.MonoPInvokeCallback(typeof(LogEventHandlerNative))]
        private static void MessageLoggedStaticHandler(ulong cookie, Microsoft.Azure.RemoteRendering.LogLevel level, System.IntPtr message)
        {
            try
            {
                Microsoft.Azure.RemoteRendering.RenderingConnection instance = GetInstance(cookie);

                if (instance == null)
                {
                    throw new System.InvalidOperationException("The object instance is not tracked by the cache.");
                }

                Microsoft.Azure.RemoteRendering.LogEventHandler handler =
                    Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.GetEventHandler<Microsoft.Azure.RemoteRendering.LogEventHandler>(
                        instance,
                        nameof(MessageLogged));

                handler?.Invoke(level, message);
            }
            catch (Exception e)
            {
                // We must not throw during a reverse p-invoke or else mono will unroll our native stack
                // without any kind of graceful destruction
                Debug.LogException(e);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.LogEventHandlerNative MessageLoggedStaticHandlerDelegate = MessageLoggedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.LogEventHandler MessageLogged
        {
            add
            {
                Microsoft.Azure.RemoteRendering.ProjectedObjectCache.Add(this);
                Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.AddEventHandler(this, nameof(this.MessageLogged), value);
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_set_message_logged(this.handle, ((ICachedObject)this).Cookie, MessageLoggedStaticHandlerDelegate));
            }
            remove
            {
                Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.RemoveEventHandler(this, nameof(this.MessageLogged), value);
            }
        }

        /// <summary>Static handler.</summary>
        [AOT.MonoPInvokeCallback(typeof(RenderingConnectionUpdatedEventHandlerNative))]
        private static void UpdatedStaticHandler(ulong cookie)
        {
            try
            {
                Microsoft.Azure.RemoteRendering.RenderingConnection instance = GetInstance(cookie);

                if (instance == null)
                {
                    throw new System.InvalidOperationException("The object instance is not tracked by the cache.");
                }

                Microsoft.Azure.RemoteRendering.RenderingConnectionUpdatedEventHandler handler =
                    Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.GetEventHandler<Microsoft.Azure.RemoteRendering.RenderingConnectionUpdatedEventHandler>(
                        instance,
                        nameof(Updated));

                handler?.Invoke();
            }
            catch (Exception e)
            {
                // We must not throw during a reverse p-invoke or else mono will unroll our native stack
                // without any kind of graceful destruction
                Debug.LogException(e);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.RenderingConnectionUpdatedEventHandlerNative UpdatedStaticHandlerDelegate = UpdatedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.RenderingConnectionUpdatedEventHandler Updated
        {
            add
            {
                Microsoft.Azure.RemoteRendering.ProjectedObjectCache.Add(this);
                Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.AddEventHandler(this, nameof(this.Updated), value);
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_set_updated(this.handle, ((ICachedObject)this).Cookie, UpdatedStaticHandlerDelegate));
            }
            remove
            {
                Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.RemoveEventHandler(this, nameof(this.Updated), value);
            }
        }

        /// <summary>
        /// Initiates the loading of a model which is located in Azure storage.
        /// </summary>
        /// <param name="options">
        /// Parameters for loading the model.
        /// </param>
        /// <remarks>
        /// This call returns immediately and initiates an asynchronous task that returns when loading the model is complete.
        /// <para>
        /// * A <see cref="Result.AuthenticationFailed"/> error occurs if the request could not be authenticated.
        /// * A <see cref="Result.NoConnection"/> error occurs, if there was no connection found.
        /// * A <see cref="Result.InvalidType"/> error occurs if the provided file type is not supported.
        /// * A <see cref="Result.InvalidParentId"/> error occurs if the set parent Id is invalid.
        /// * A <see cref="Result.TooManyRequests"/> error occurs if the rate limit has been exceeded. Retry the request after the duration given in the Retry-After header.
        /// </para>
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.LoadModelResult> LoadModelAsync(Microsoft.Azure.RemoteRendering.LoadModelOptions options, Action<float> progressCallback)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.LoadModelResult(value.Pointer, true), progressCallback, System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.LoadModelOptionsAbi options_converted = options.Convert();
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_load_model_async(this.handle, options_converted, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Initiates the loading of a model using a SAS token to identify the model.
        /// </summary>
        /// <param name="options">
        /// Parameters for loading the model.
        /// </param>
        /// <remarks>
        /// This call returns immediately and initiates an asynchronous task that returns when loading the model is complete.
        /// <para>
        /// * A <see cref="Result.AuthenticationFailed"/> error occurs if the request could not be authenticated.
        /// * A <see cref="Result.NoConnection"/> error occurs, if there was no connection found.
        /// * A <see cref="Result.InvalidType"/> error occurs if the provided file type is not supported.
        /// * A <see cref="Result.InvalidParentId"/> error occurs if the set parent Id is invalid.
        /// * A <see cref="Result.TooManyRequests"/> error occurs if the rate limit has been exceeded. Retry the request after the duration given in the Retry-After header.
        /// </para>
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/models">Models</seealso>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.LoadModelResult> LoadModelFromSasAsync(Microsoft.Azure.RemoteRendering.LoadModelFromSasOptions options, Action<float> progressCallback)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.LoadModelResult(value.Pointer, true), progressCallback, System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.LoadModelFromSasOptionsAbi options_converted = options.Convert();
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_load_model_from_sas_async(this.handle, options_converted, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Initiates the loading of a texture which is located in Azure storage.
        /// </summary>
        /// <param name="options">
        /// Parameters for loading the texture.
        /// </param>
        /// <remarks>
        /// This call returns immediately and initiates an asynchronous task that returns when loading the texture is complete.
        /// <para>
        /// * A <see cref="Result.AuthenticationFailed"/> error occurs if the request could not be authenticated.
        /// * A <see cref="Result.NoConnection"/> error occurs, if there was no connection found.
        /// * A <see cref="Result.InvalidType"/> error occurs if the provided file type is not supported.
        /// * A <see cref="Result.InvalidParentId"/> error occurs if the set parent Id is invalid.
        /// * A <see cref="Result.TooManyRequests"/> error occurs if the rate limit has been exceeded. Retry the request after the duration given in the Retry-After header.
        /// </para>
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures</seealso>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.Texture> LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureOptions options)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.Texture(value.UInt64, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.LoadTextureOptionsAbi options_converted = options.Convert();
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_load_texture_async(this.handle, options_converted, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Initiates the loading of a texture using a SAS token to identify the texture.
        /// </summary>
        /// <param name="options">
        /// Parameters for loading the texture.
        /// </param>
        /// <remarks>
        /// This call returns immediately and initiates an asynchronous task that returns when loading the texture is complete.
        /// <para>
        /// * A <see cref="Result.AuthenticationFailed"/> error occurs if the request could not be authenticated.
        /// * A <see cref="Result.NoConnection"/> error occurs, if there was no connection found.
        /// * A <see cref="Result.InvalidType"/> error occurs if the provided file type is not supported.
        /// * A <see cref="Result.InvalidParentId"/> error occurs if the set parent Id is invalid.
        /// * A <see cref="Result.TooManyRequests"/> error occurs if the rate limit has been exceeded. Retry the request after the duration given in the Retry-After header.
        /// </para>
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures</seealso>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.Texture> LoadTextureFromSasAsync(Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptions options)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.Texture(value.UInt64, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptionsAbi options_converted = options.Convert();
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_load_texture_from_sas_async(this.handle, options_converted, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Performs a raycast query on the remote scene.
        /// </summary>
        /// <param name="cast">
        /// Raycast description.
        /// </param>
        /// <remarks>
        /// This call returns immediately and emits an event when the raycast result has arrived.
        /// The raycast will be performed on the server against the state of the world on the frame that the raycast was issued on.
        /// Results will be sorted by distance, with the closest intersection to the user being the first item in the array.
        /// <para>
        /// * A <see cref="Result.NoConnection"/> error occurs, if there was no connection found.
        /// </para>
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/spatial-queries">Spatial queries</seealso>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.RayCastQueryResult> RayCastQueryAsync(Microsoft.Azure.RemoteRendering.RayCast cast)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.RayCastQueryResult(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_ray_cast_query_async(this.handle, cast, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Performs a performance assessment query on the server.
        /// </summary>
        /// <remarks>
        /// This call returns immediately and emits an event when the query result has arrived.
        /// <para>
        /// * A <see cref="Result.NoConnection"/> error occurs, if there was no connection found.
        /// </para>
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/performance-queries">Server-side performance queries</seealso>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.PerformanceAssessment> QueryServerPerformanceAssessmentAsync()
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => Microsoft.Azure.RemoteRendering.PerformanceAssessment.Create(value.Pointer), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_query_server_performance_assessment_async(this.handle, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Creates a new entity.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/entities">Entities</seealso>
        public Microsoft.Azure.RemoteRendering.Entity CreateEntity()
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.Entity result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_create_entity(this.handle, out result_handle));
            result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Entity(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Creates a new <see cref="Material"/>.
        /// </summary>
        /// <param name="type">
        /// Material type to create.
        /// </param>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/materials">Materials</seealso>
        public Microsoft.Azure.RemoteRendering.Material CreateMaterial(Microsoft.Azure.RemoteRendering.MaterialType type)
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.Material result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_create_material(this.handle, type, out result_handle));
            result_object = (result_handle != default(ulong)) ? Factories.MaterialFactory(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Creates a new component.
        /// </summary>
        /// <param name="componentType">
        /// Component type to create.
        /// </param>
        /// <param name="owner">
        /// Owner entity for the component.
        /// </param>
        /// <remarks>
        /// A <see cref="Result.AlreadyExists"/> error occurs, if the entity already has a component of the requested type.
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/components">Components</seealso>
        public Microsoft.Azure.RemoteRendering.ComponentBase CreateComponent(Microsoft.Azure.RemoteRendering.ObjectType componentType, Microsoft.Azure.RemoteRendering.Entity owner)
        {
            ulong result_handle;
            Microsoft.Azure.RemoteRendering.ComponentBase result_object;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_create_component(this.handle, componentType, owner != null ? owner.handle : default(ulong), out result_handle));
            result_object = (result_handle != default(ulong)) ? Factories.ComponentBaseFactory(result_handle, transfer:true) : null;
            return result_object;
        }

        /// <summary>
        /// Pushes all client updates to the server and dispatches all messages received from the server.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Client updates such as entity and component state changes, raycast requests, and other async operations are queued on the client side
        /// and only sent to the server during a call to Update().
        /// </para>
        /// <para>
        /// Similarly, results from the server that arrived in the mean time, for example for raycasts and model loads, have been queued and will be dispatched to the client code only during Update().
        /// </para>
        /// <para>
        /// Consequently, Update() must be called once every frame.
        /// Calls to Update() invoke the <see cref="RenderingConnection.Updated"/> event.
        /// </para>
        /// <para>
        /// * A <see cref="Result.NoConnection"/> error occurs, if there was no connection found.
        /// </para>
        /// </remarks>
        public void Update()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_connection_update(this.handle));
        }

        ulong ICachedObject.Cookie => ConvertHandleToCookie(this.handle);

        private static readonly Func<ulong, Microsoft.Azure.RemoteRendering.RenderingConnection> createFromCookieFactoryFunction =
            cookie => new Microsoft.Azure.RemoteRendering.RenderingConnection(cookie, transfer: false);

        internal static Microsoft.Azure.RemoteRendering.RenderingConnection GetInstance(ulong cookie)
            => Microsoft.Azure.RemoteRendering.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.RemoteRendering.RenderingConnection>(cookie, createFromCookieFactoryFunction);

        private static ulong ConvertHandleToCookie(ulong handle)
        {
            if (handle == default(ulong))
            {
                throw new ArgumentException("Invalid handle.", nameof(handle));
            }

            return handle;
        }
    }

    /// <summary>
    /// Each rendering session is running on a dedicated server, providing the Azure Remote Rendering functionality.
    /// </summary>
    /// <remarks>
    /// An application can manage multiple RenderingSession objects.
    /// However, each application can only connect a single RenderingSession for rendering.
    /// </remarks>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/sessions">Remote Rendering Sessions</seealso>
    public partial class RenderingSession : ICachedObject
    {
        internal ulong handle;

        internal RenderingSession(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_addref(ahandle);
        }

        ~RenderingSession()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_release(this.handle));
            this.handle = default(ulong);
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Retrieves the associated owner <see cref="RemoteRenderingClient"/>
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RemoteRenderingClient Client
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.RemoteRenderingClient result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_get_client(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.RemoteRenderingClient(result_handle, transfer:true) : null;
                return result_object;
            }
        }

        /// <summary>
        /// String UUID of this session.
        /// </summary>
        /// <remarks>
        /// This can be used to connect to the session later or perform independent REST calls, for example with PowerShell.
        /// </remarks>
        public string SessionUuid
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_get_session_uuid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Last connection parameters used in a call to <see cref="RenderingSession.ConnectAsync(RendererInitOptions)"/>.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.RendererInitOptions RendererInitOptions
        {
            get
            {
                Microsoft.Azure.RemoteRendering.RendererInitOptionsAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_get_renderer_init_options(this.handle, out result));
                return result.Convert();
            }
        }

        /// <summary>
        /// Current connection status of this session.
        /// </summary>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingSession.ConnectionStatusChanged"/>
        public Microsoft.Azure.RemoteRendering.ConnectionStatus ConnectionStatus
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ConnectionStatus result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_get_connection_status(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Utility function to query whether this session is connected.
        /// </summary>
        public bool IsConnected
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_get_is_connected(this.handle, out result));
                return result;
            }
        }

        /// <summary>Static handler.</summary>
        [AOT.MonoPInvokeCallback(typeof(ConnectionStatusChangedEventHandlerNative))]
        private static void ConnectionStatusChangedStaticHandler(ulong cookie, Microsoft.Azure.RemoteRendering.ConnectionStatus status, Microsoft.Azure.RemoteRendering.Result error)
        {
            try
            {
                Microsoft.Azure.RemoteRendering.RenderingSession instance = GetInstance(cookie);

                if (instance == null)
                {
                    throw new System.InvalidOperationException("The object instance is not tracked by the cache.");
                }

                Microsoft.Azure.RemoteRendering.ConnectionStatusChangedEventHandler handler =
                    Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.GetEventHandler<Microsoft.Azure.RemoteRendering.ConnectionStatusChangedEventHandler>(
                        instance,
                        nameof(ConnectionStatusChanged));

                // WARNING: this is a workaround for a supposed mono bug that never returns execution to us after
                // any delegate call. We defer the delegate to later. This has to be added manually here for now
                // and should not be overwritten by generating from the api model.
                if (handler != null)
                {
                    Unity.MainThreadInvoker.Invoke(() => handler(status, error), false);
                }
            }
            catch (Exception e)
            {
                // We must not throw during a reverse p-invoke or else mono will unroll our native stack
                // without any kind of graceful destruction
                Debug.LogException(e);
            }
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.RemoteRendering.ConnectionStatusChangedEventHandlerNative ConnectionStatusChangedStaticHandlerDelegate = ConnectionStatusChangedStaticHandler;
        public event Microsoft.Azure.RemoteRendering.ConnectionStatusChangedEventHandler ConnectionStatusChanged
        {
            add
            {
                Microsoft.Azure.RemoteRendering.ProjectedObjectCache.Add(this);
                Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.AddEventHandler(this, nameof(this.ConnectionStatusChanged), value);
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_set_connection_status_changed(this.handle, ((ICachedObject)this).Cookie, ConnectionStatusChangedStaticHandlerDelegate));
            }
            remove
            {
                Microsoft.Azure.RemoteRendering.ProjectedObjectEventHandlerCache.RemoveEventHandler(this, nameof(this.ConnectionStatusChanged), value);
            }
        }

        /// <summary>
        /// Gets a file path pointing to an HTML file to connect to the ArrInspector website.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The ArrInspector provides introspection and service status updates.
        /// </para>
        /// </remarks>
        /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/resources/tools/arr-inspector">The ArrInspector inspection tool</seealso>
        public async System.Threading.Tasks.Task<string> ConnectToArrInspectorAsync()
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => PackedValue.UnpackString(value), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_connect_to_arr_inspector_async(this.handle, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Queries the properties of the session (hostname, lease time, size, etc).
        /// </summary>
        /// <remarks>
        /// <para>
        /// Since the underlying call is a REST call, there should be sufficient delay (5-10s) between subsequent calls to avoid server throttling.
        /// In case of throttling, the function will fail and the <see cref="SessionGeneralContext.HttpResponseCode">HttpResponseCode</see> reports code 429 ("too many requests").
        /// </para>
        /// <para>
        /// * A <see cref="Result.InvalidParam"/> error occurs if the rendering service URL was empty, because the account domain and account Id was not provided.
        /// * A <see cref="Result.SessionNotFound"/> error occurs if the corresponding session could not be found. Please check the provided session Id.
        /// * A <see cref="Result.AuthenticationFailed"/> error occurs if the request could not be authenticated.
        /// * A <see cref="Result.NotInitialized"/> error occurs if the RemoteRenderingClient was not initialized.
        /// * A <see cref="Result.TooManyRequests"/> error occurs if the rate limit has been exceeded. Retry the request after the duration given in the Retry-After header.
        /// </para>
        /// </remarks>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesResult> GetPropertiesAsync()
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesResult(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_get_properties_async(this.handle, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Stops the Azure session. It is not possible to connect to this session again.
        /// </summary>
        /// <remarks>
        /// <para>
        /// * A <see cref="Result.InvalidParam"/> error occurs if the rendering service URL was empty, because the account domain and account Id was not provided.
        /// * A <see cref="Result.AuthenticationFailed"/> error occurs if the request could not be authenticated.
        /// * A <see cref="Result.NotInitialized"/> error occurs if the RemoteRenderingClient was not initialized.
        /// * A <see cref="Result.TooManyRequests"/> error occurs if the rate limit has been exceeded. Retry the request after the duration given in the Retry-After header.
        /// </para>
        /// </remarks>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.SessionContextResult> StopAsync()
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.SessionContextResult(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_stop_async(this.handle, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Updates the session parameters for this rendering session.
        /// </summary>
        /// <param name="updateOptions">
        /// The new parameters to use
        /// </param>
        /// <remarks>
        /// <para>
        /// See <see cref="RenderingSessionUpdateOptions"/> for details.
        /// </para>
        /// <para>
        /// Since the underlying call is a REST call, there should be sufficient delay (5-10s) between subsequent calls to avoid server throttling.
        /// In case of throttling, the function will fail and the <see cref="SessionGeneralContext.HttpResponseCode">HttpResponseCode</see> reports code 429 ("too many requests").
        /// </para>
        /// <para>
        /// * A <see cref="Result.InvalidParam"/> error occurs if the rendering service URL was empty, because the account domain and account Id was not provided, or if the maxLeaseTimeMinutes value was invalid. It has to be bigger than the current value of maxLeaseTimeMinutes.
        /// * A <see cref="Result.AuthenticationFailed"/> error occurs if the request could not be authenticated.
        /// * A <see cref="Result.NotInitialized"/> error occurs if the RemoteRenderingClient was not initialized.
        /// * A <see cref="Result.TooManyRequests"/> error occurs if the rate limit has been exceeded. Retry the request after the duration given in the Retry-After header.
        /// </para>
        /// </remarks>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.SessionContextResult> RenewAsync(Microsoft.Azure.RemoteRendering.RenderingSessionUpdateOptions updateOptions)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => new Microsoft.Azure.RemoteRendering.SessionContextResult(value.Pointer, true), System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_renew_async(this.handle, updateOptions, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Connect to the runtime on the server associated with this session.
        /// </summary>
        /// <param name="inputOptions">
        /// Connection parameters.
        /// </param>
        /// <remarks>
        /// <para>
        /// * A <see cref="Result.AlreadyConnected"/> error occurs, if another session in the same process is already connected to its runtime.
        /// * A <see cref="Result.InProgress"/> error occurs, if Connect has been called before.
        /// * A <see cref="Result.OtherSessionConnected"/> error occurs, if another session is already connected to this runtime.
        /// * A <see cref="Result.NoConnection"/> error occurs, if no connection could be established.
        /// * A <see cref="Result.InvalidParam"/> error occurs if the rendering service URL was empty, because the account domain and account Id was not provided.
        /// * A <see cref="Result.SessionNotFound"/> error occurs if the corresponding session could not be found. Please check the provided session Id.
        /// * A <see cref="Result.AuthenticationFailed"/> error occurs if the request could not be authenticated.
        /// * A <see cref="Result.NotInitialized"/> error occurs if the RemoteRenderingClient or RenderingSession was not initialized.
        /// * A <see cref="Result.TooManyRequests"/> error occurs if the rate limit has been exceeded. Retry the request after the duration given in the Retry-After header.
        /// </para>
        /// </remarks>
        public async System.Threading.Tasks.Task<Microsoft.Azure.RemoteRendering.ConnectionStatus> ConnectAsync(Microsoft.Azure.RemoteRendering.RendererInitOptions initOptions)
        {
            using (var promise_ = Microsoft.Azure.RemoteRendering.Promise.Create(value => (Microsoft.Azure.RemoteRendering.ConnectionStatus)value.Int64, System.Threading.CancellationToken.None))
            {
                Microsoft.Azure.RemoteRendering.RendererInitOptionsAbi initOptions_converted = initOptions.Convert();
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_connect_async(this.handle, initOptions_converted, promise_.Handle));
                return await promise_.Task;
            }
        }

        /// <summary>
        /// Disconnect this session if connected to the runtime.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.Result Disconnect()
        {
            Microsoft.Azure.RemoteRendering.Result result;
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_disconnect(this.handle, out result));
            return result;
        }

        ulong ICachedObject.Cookie => ConvertHandleToCookie(this.handle);

        private static readonly Func<ulong, Microsoft.Azure.RemoteRendering.RenderingSession> createFromCookieFactoryFunction =
            cookie => new Microsoft.Azure.RemoteRendering.RenderingSession(cookie, transfer: false);

        internal static Microsoft.Azure.RemoteRendering.RenderingSession GetInstance(ulong cookie)
            => Microsoft.Azure.RemoteRendering.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.RemoteRendering.RenderingSession>(cookie, createFromCookieFactoryFunction);

        private static ulong ConvertHandleToCookie(ulong handle)
        {
            if (handle == default(ulong))
            {
                throw new ArgumentException("Invalid handle.", nameof(handle));
            }

            return handle;
        }
    }

    public partial class RenderingSessionPropertiesArrayResult : SessionContextResult
    {
        internal RenderingSessionPropertiesArrayResult(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        public Microsoft.Azure.RemoteRendering.RenderingSessionProperties[] SessionProperties
        {
            get
            {
                Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi[] result;
                int result_length;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_properties_array_result_get_session_properties(this.handle, out result, out result_length));
                return result?.Select(x => x.Convert()).ToArray() ?? null;
            }
        }

    }

    public partial class RenderingSessionPropertiesResult : SessionContextResult
    {
        internal RenderingSessionPropertiesResult(IntPtr ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        public Microsoft.Azure.RemoteRendering.RenderingSessionProperties SessionProperties
        {
            get
            {
                Microsoft.Azure.RemoteRendering.RenderingSessionPropertiesAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_properties_result_get_session_properties(this.handle, out result));
                return result.Convert();
            }
        }

        /// <summary>
        /// The minimum number of seconds one has to wait before polling the rendering session properties again.
        /// </summary>
        public int MinimumRetryDelay
        {
            get
            {
                int result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_rendering_session_properties_result_get_minimum_retry_delay(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// Base class for all resources.
    /// </summary>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Mesh"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Texture"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.Material"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/lifetime">Object and resource lifetime</seealso>
    public partial class ResourceBase
    {
        internal ulong handle;

        internal ResourceBase(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_addref(ahandle);
        }

        protected ResourceBase()
        {
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_create(out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        ~ResourceBase()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_release(this.handle));
            this.handle = default(ulong);
        }

        /// <summary>
        /// Whether this resource is still valid.
        /// </summary>
        /// <remarks>
        /// A resource is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this resource.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_resource_base_get_type(this.handle, out result));
                return result;
            }
        }

    }

    public partial class SessionContextResult
    {
        internal IntPtr handle;

        internal SessionContextResult(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_context_result_addref(ahandle);
        }

        protected SessionContextResult()
        {
            Microsoft.Azure.RemoteRendering.status resultStatus = (Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_context_result_create(out this.handle));
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
        }

        ~SessionContextResult()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_context_result_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        public Microsoft.Azure.RemoteRendering.Result ErrorCode
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Result result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_context_result_get_error_code(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// In case of failure (ErrorCode != Success), additional information such as the http response code and an error string can be gathered through this object. In case of success, this object is still valid, but does not provide additional information.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.SessionGeneralContext Context
        {
            get
            {
                Microsoft.Azure.RemoteRendering.SessionGeneralContextAbi result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_session_context_result_get_context(this.handle, out result));
                return result.Convert();
            }
        }

    }

    /// <summary>
    /// Global settings for objects rendered using the <see cref="HierarchicalStates.Shell">hierarchical override shell effect</see>.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/shell-rendering">Shell rendering</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.ShellRenderingSettings"/>
    public partial class ShellRenderingSettings
    {
        internal ulong handle;

        internal ShellRenderingSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_shell_rendering_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The opacity of shell-rendered geometry. Ranges from 0 (invisible) to 1 (fully opaque).
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if a value outside the [0;1] range is passed in.
        /// </para>
        /// </remarks>
        public float Opacity
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_shell_rendering_settings_get_opacity(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_shell_rendering_settings_set_opacity(this.handle, value));
            }
        }

        /// <summary>
        /// Amount of color de-saturation to apply to the shell-rendered objects. Ranges from 0 (original color) to 1 (gray scale).
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if a value outside the [0;1] range is passed in.
        /// </para>
        /// </remarks>
        public float Desaturation
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_shell_rendering_settings_get_desaturation(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_shell_rendering_settings_set_desaturation(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Settings for single-sided geometry rendering.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/single-sided-rendering">Single-sided rendering</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.SingleSidedSettings"/>
    public partial class SingleSidedSettings
    {
        internal ulong handle;

        internal SingleSidedSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_single_sided_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// What mode to use for rendering single-sided geometry.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if an invalid mode value is passed in.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.SingleSidedMode"/>
        public Microsoft.Azure.RemoteRendering.SingleSidedMode Mode
        {
            get
            {
                Microsoft.Azure.RemoteRendering.SingleSidedMode result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_single_sided_settings_get_mode(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_single_sided_settings_set_mode(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Settings for the global sky reflections.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/sky">Sky reflections</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.SkyReflectionSettings"/>
    public partial class SkyReflectionSettings
    {
        internal ulong handle;

        internal SkyReflectionSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_sky_reflection_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The sky <see cref="Texture"/> used for reflections.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This can be either a cubemap or a 2D texture in spherical coordinates.
        /// </para>
        /// <para>
        /// * A <see cref="Result.InvalidParam"/> error occurs if the provided texture is invalid.
        /// * A <see cref="Result.InvalidType"/> error occurs if the provided texture is not a 2D or cube texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture SkyReflectionTexture
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_sky_reflection_settings_get_sky_reflection_texture(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_sky_reflection_settings_set_sky_reflection_texture(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

    }

    /// <summary>
    /// A light source that emits light within a directed cone.
    /// </summary>
    /// <remarks>
    /// In contrast to the <see cref="PointLightComponent"/>, this component only emits light within a cone shape.
    /// The main direction of the cone is along the owner's negative z-axis.
    /// Typical use cases for spotlights are flashlights.
    /// However, they can also be used to emulate the shadow of point lights that are encased in a hull.
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.LightComponentBase"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.PointLightComponent"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.DirectionalLightComponent"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/lights">Scene lighting</seealso>
    public partial class SpotLightComponent : LightComponentBase
    {
        internal SpotLightComponent(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The radius of the light emitting shape.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.PointLightComponent.Radius"/>
        public float Radius
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_radius(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_radius(this.handle, value));
            }
        }

        /// <summary>
        /// The inner and outer angle (in degree) of the spot light cone.
        /// </summary>
        /// <remarks>
        /// <para>
        /// * Everything within the inner angle is illuminated with full brightness.
        /// * Everything outside the outer angle won't be illuminated at all.
        /// * Between the inner and outer angle a falloff that creates a penumbra-like effect is applied.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if x or y is outside the range [0; 89] or if x is >= y.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Float2 SpotAngleDeg
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_spot_angle_deg(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_spot_angle_deg(this.handle, value));
            }
        }

        /// <summary>
        /// The strength of the light falloff between the inner and outer cone angle.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The larger the value, the sharper the transition.
        /// The default value of 1.0 results in a linear transition.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is outside the range [0.01; 256].
        /// </para>
        /// </remarks>
        public float FalloffExponent
        {
            get
            {
                float result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_falloff_exponent(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_falloff_exponent(this.handle, value));
            }
        }

        /// <summary>
        /// Custom interval of min/max distances over which the light's attenuated intensity is scaled down to zero.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A <see cref="Result.InvalidParam"/> error occurs if the value is negative, NaN or infinite.
        /// </para>
        /// </remarks>
        /// <seealso cref="Microsoft.Azure.RemoteRendering.PointLightComponent.AttenuationCutoff"/>
        public Microsoft.Azure.RemoteRendering.Float2 AttenuationCutoff
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Float2 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_attenuation_cutoff(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_attenuation_cutoff(this.handle, value));
            }
        }

        /// <summary>
        /// Optional 2D <see cref="Texture"/> to be projected onto geometry.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The color from the texture is used to modulate the light's color.
        /// </para>
        /// <para>
        /// A <see cref="Result.InvalidType"/> error occurs if a texture is set that is not a 2D texture.
        /// </para>
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Texture Projected2dTexture
        {
            get
            {
                ulong result_handle;
                Microsoft.Azure.RemoteRendering.Texture result_object;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_get_projected2d_texture(this.handle, out result_handle));
                result_object = (result_handle != default(ulong)) ? new Microsoft.Azure.RemoteRendering.Texture(result_handle, transfer:true) : null;
                return result_object;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_spot_light_component_set_projected2d_texture(this.handle, value != null ? value.handle : default(ulong)));
            }
        }

    }

    /// <summary>
    /// Options for changing the stage-space origin.
    /// </summary>
    /// <remarks>
    /// To make sure that local and remote content align correctly, any additional transform that is applied on top of the camera transform needs to be set here as well to inform the server.
    /// WARNING: This feature is experimental and changing the origin will break local/remote content alignment for a brief moment.
    /// Thus, it is currently only intended to be used for world locking purposes like anchors that exhibit only very small changes over time.
    /// </remarks>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/stage-space">Stage space</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.StageSpaceSettings"/>
    public partial class StageSpaceSettings
    {
        internal ulong handle;

        internal StageSpaceSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_stage_space_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Stage space origin position.
        /// </summary>
        /// <remarks>
        /// This should be set at the end of each frame to the world-space position of the camera's parent.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Double3 Position
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Double3 result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_stage_space_settings_get_position(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_stage_space_settings_set_position(this.handle, value));
            }
        }

        /// <summary>
        /// Stage space origin rotation.
        /// </summary>
        /// <remarks>
        /// This should be set at the end of each frame to the world-space rotation of the camera's parent.
        /// </remarks>
        public Microsoft.Azure.RemoteRendering.Quaternion Rotation
        {
            get
            {
                Microsoft.Azure.RemoteRendering.Quaternion result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_stage_space_settings_get_rotation(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_stage_space_settings_set_rotation(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Textures represent images that can be applied to geometry.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Textures are immutable, shared resources, loaded through the <see cref="RenderingConnection"/>.
    /// Attempting to load the same texture twice, will return the same object.
    /// </para>
    /// <para>
    /// To apply a texture to geometry, set it on a <see cref="Material"/> and assign the material to a <see cref="Mesh"/>. Textures can also be used in the <see cref="SkyReflectionSettings"/>.
    /// </para>
    /// </remarks>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadTextureAsync(Microsoft.Azure.RemoteRendering.LoadTextureOptions)"/>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.LoadTextureFromSasAsync(Microsoft.Azure.RemoteRendering.LoadTextureFromSasOptions)"/>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/concepts/textures">Textures (Remote Rendering documentation)</seealso>
    public partial class Texture : ResourceBase
    {
        internal Texture(ulong ahandle, bool transfer) : base(ahandle, transfer)
        {
        }

        /// <summary>
        /// The <see cref="ObjectType">exact type</see> of this resource.
        /// </summary>
        public Microsoft.Azure.RemoteRendering.ObjectType Type
        {
            get
            {
                Microsoft.Azure.RemoteRendering.ObjectType result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_texture_get_type(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Whether this resource is still valid.
        /// </summary>
        /// <remarks>
        /// A resource is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_texture_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the name of the texture.
        /// </summary>
        public string Name
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_texture_get_name(this.handle, out result));
                return result;
            }
        }

    }

    /// <summary>
    /// Informs the application that the service requires an updated access token or authentication token.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/how-tos/frontend-apis">Use the Azure Frontend APIs for authentication</seealso>
    public partial class TokenRequiredEventArgs : EventArgs
    {
        internal IntPtr handle;

        internal TokenRequiredEventArgs(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_addref(ahandle);
        }

        ~TokenRequiredEventArgs()
        {
            Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// The access token to be used by the operation that requires it.
        /// </summary>
        public string AccessToken
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_get_access_token(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_set_access_token(this.handle, value));
            }
        }

        /// <summary>
        /// The authentication token to be used by the operation that requires it.
        /// </summary>
        public string AuthenticationToken
        {
            get
            {
                string result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_get_authentication_token(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_token_required_event_args_set_authentication_token(this.handle, value));
            }
        }

    }

    /// <summary>
    /// Settings for z-fighting mitigation.
    /// </summary>
    /// <seealso cref="https://docs.microsoft.com/azure/remote-rendering/overview/features/z-fighting-mitigation">Z-fighting mitigation</seealso>
    /// <seealso cref="Microsoft.Azure.RemoteRendering.RenderingConnection.ZFightingMitigationSettings"/>
    public partial class ZFightingMitigationSettings
    {
        internal ulong handle;

        internal ZFightingMitigationSettings(ulong ahandle, bool transfer)
        {
            this.handle = ahandle;
        }

        /// <summary>
        /// Whether this object is still valid.
        /// </summary>
        /// <remarks>
        /// An object is invalid if it has been destroyed or if the connection has been lost.
        /// It is an error to call any other function on an invalid object.
        /// </remarks>
        public bool Valid
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_get_valid(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Whether z-fighting mitigation is used.
        /// </summary>
        public bool Enabled
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_get_enabled(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_set_enabled(this.handle, value));
            }
        }

        /// <summary>
        /// Activates checkerboard highlighting of potential z-fighting. For debugging purposes.
        /// </summary>
        public bool Highlighting
        {
            get
            {
                bool result;
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_get_highlighting(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.RemoteRendering.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.RemoteRendering.NativeLibrary.arr_zfighting_mitigation_settings_set_highlighting(this.handle, value));
            }
        }

    }

}

#endif
