#if UNITY_WSA && !UNITY_EDITOR
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Microsoft.Azure.ObjectAnchors
// This file was auto-generated from AbiDefinition.cs.
//

// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;

namespace Microsoft.Azure.ObjectAnchors
{
    internal enum status
    {
        /// <summary>
        /// Success
        /// </summary>
        OK = 0,
        /// <summary>
        /// Failed
        /// </summary>
        Failed = 1,
        /// <summary>
        /// Cannot access a disposed object.
        /// </summary>
        ObjectDisposed = 2,
        /// <summary>
        /// Out of memory.
        /// </summary>
        OutOfMemory = 12,
        /// <summary>
        /// Invalid argument.
        /// </summary>
        InvalidArgument = 22,
        /// <summary>
        /// The value is out of range.
        /// </summary>
        OutOfRange = 34,
        /// <summary>
        /// Not implemented.
        /// </summary>
        NotImplemented = 38,
        /// <summary>
        /// The operation was canceled.
        /// </summary>
        OperationCanceled = 59,
        /// <summary>
        /// The key does not exist in the collection.
        /// </summary>
        KeyNotFound = 77,
    }

    internal static class NativeLibraryHelpers
    {
        internal static string[] IntPtrToStringArray(IntPtr result, int result_length)
        {
            // an empty list is returned as a single null character
            if (result_length == 1)
            {
                return Array.Empty<string>();
            }

            byte[] bytes = new byte[result_length - 1];
            System.Runtime.InteropServices.Marshal.Copy(result, bytes, 0, result_length - 1);
            System.Runtime.InteropServices.Marshal.FreeCoTaskMem(result);
            return System.Text.Encoding.UTF8.GetString(bytes).Split('\0');
        }

        internal static void CheckStatus(status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string fullMessage = string.Empty;

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException(string.Empty, fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.OperationCanceled:
                    throw new OperationCanceledException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
            }
        }

        internal static void CheckStatus(IntPtr handle, status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string message;
            string requestCorrelationVector;
            string responseCorrelationVector;

            Microsoft.Azure.ObjectAnchors.status code = Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_get_error_details(handle, out message, out requestCorrelationVector, out responseCorrelationVector);

            string fullMessage;
            if (code == status.Failed)
            {
                throw new InvalidOperationException("Unexpected error in exception handling.");
            }
            else if (code != status.OK)
            {
                fullMessage = "Exception thrown and an unexpected error in exception handling.";
            }
            else
            {
                fullMessage = message + ".";
                if (!string.IsNullOrEmpty(requestCorrelationVector))
                {
                    fullMessage += " Request CV: " + requestCorrelationVector + ".";
                }
                if (!string.IsNullOrEmpty(responseCorrelationVector))
                {
                    fullMessage += " Response CV: " + responseCorrelationVector + ".";
                }
            }

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException(string.Empty, fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.OperationCanceled:
                    throw new OperationCanceledException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
            }
        }
    }

    internal static class ProjectedObjectHelpers
    {
        public static ulong ConvertHandleToCookie(IntPtr handle)
        {
            if (handle == IntPtr.Zero)
            {
                throw new ArgumentException("Invalid handle.", nameof(handle));
            }

            return (ulong)handle.ToInt64();
        }

        public static IntPtr ConvertCookieToHandle(ulong cookie)
        {
            return new IntPtr((long)cookie);
        }
    }

    /// <summary>
    /// This interface is implemented by classes to be cached by the <see cref="ProjectedObjectCache"/>.
    /// </summary>
    internal interface ICachedObject
    {
        /// <summary>
        /// Unique cookie value for projected object identification.
        /// </summary>
        ulong Cookie { get; }
    }

    /// <summary>
    /// Represents a cache of event handlers for projected object events.
    /// </summary>
    internal static class ProjectedObjectEventHandlerCache
    {
        private readonly static IDictionary<ulong, IDictionary<string, Delegate>> tracked = new Dictionary<ulong, IDictionary<string, Delegate>>();

        /// <summary>
        /// Gets a value indicating whether the cache is empty.
        /// </summary>
        public static bool IsEmpty => tracked.Count == 0;

        /// <summary>
        /// Adds an event handler to the cache for the specified instance and event.
        /// The delegate is added to the multicast delegate.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The event handler.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void AddEventHandler<T>(ICachedObject instance, string eventName, T handler)
            where T : Delegate
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            if (string.IsNullOrWhiteSpace(eventName))
            {
                throw new ArgumentException("The argument is either null, empty, or whitespace.", nameof(eventName));
            }

            if (handler == null)
            {
                throw new ArgumentNullException(nameof(handler));
            }

            lock (tracked)
            {
                IDictionary<string, Delegate> eventDelegates = GetOrInitializeEvents(instance);

                if (!eventDelegates.TryGetValue(eventName, out Delegate existingHandler) || existingHandler == null)
                {
                    eventDelegates[eventName] = handler;
                    return;
                }

                eventDelegates[eventName] = Delegate.Combine(existingHandler, handler);
            }
        }

        /// <summary>
        /// Removes an event handler from the cache for the specified instance and event.
        /// The delegate is removed from the multicast delegate.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The handler.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void RemoveEventHandler<T>(ICachedObject instance, string eventName, T handler)
            where T : Delegate
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            if (string.IsNullOrWhiteSpace(eventName))
            {
                throw new ArgumentException("The argument is either null, empty, or whitespace.", nameof(eventName));
            }

            if (handler == null)
            {
                throw new ArgumentNullException(nameof(handler));
            }

            lock (tracked)
            {
                IDictionary<string, Delegate> eventDelegates = GetOrInitializeEvents(instance);

                if (!eventDelegates.TryGetValue(eventName, out Delegate existingHandler) || existingHandler == null)
                {
                    return;
                }

                eventDelegates[eventName] = Delegate.Remove(existingHandler, handler);
            }
        }

        /// <summary>
        /// Gets the event handler for the specified instance and event name.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="instance">The instance.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <returns><see cref="IReadOnlyCollection{T}"/>.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static T GetEventHandler<T>(ICachedObject instance, string eventName)
            where T : Delegate
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            if (string.IsNullOrWhiteSpace(eventName))
            {
                throw new ArgumentException("The argument is either null, empty, or whitespace.", nameof(eventName));
            }

            lock (tracked)
            {
                if (!tracked.TryGetValue(instance.Cookie, out IDictionary<string, Delegate> events))
                {
                    // No events have been cached for the object.
                    return null;
                }

                if (!events.TryGetValue(eventName, out Delegate eventDelegate))
                {
                    // The specified event has not been cached for the object.
                    return null;
                }

                return eventDelegate as T;
            }
        }

        /// <summary>
        /// Clears the cache of event handles for the specified instance.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public static void Clear(ICachedObject instance)
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            Clear(instance.Cookie);
        }

        /// <summary>
        /// Clears the cache of event handles for the specified instance cookie.
        /// </summary>
        /// <param name="cookie">The cookie.</param>
        /// <exception cref="ArgumentException"></exception>
        public static void Clear(ulong cookie)
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            lock (tracked)
            {
                tracked.Remove(cookie);
            }
        }

        private static IDictionary<string, Delegate> GetOrInitializeEvents(ICachedObject instance)
        {
            // We assume a lock on `tracked` is already held at this point, so no need to lock here.
            if (!tracked.TryGetValue(instance.Cookie, out IDictionary<string, Delegate> events))
            {
                // Setup event handler cache for the object.
                events = new Dictionary<string, Delegate>(StringComparer.Ordinal);
                tracked[instance.Cookie] = events;
            }

            return events;
        }
    }

    /// <summary>
    /// Represents a cache of projected object events.
    /// </summary>
    internal static class ProjectedObjectCache
    {
        private static readonly Dictionary<ulong, System.WeakReference<ICachedObject>> tracked = new Dictionary<ulong, System.WeakReference<ICachedObject>>();

        private static readonly Microsoft.Azure.ObjectAnchors.ProjectedObjectCleanupNative projectedObjectCleanupHandlerDelegate = ProjectedObjectCleanupHandler;

        /// <summary>
        /// Gets a value indicating whether the cache is empty.
        /// </summary>
        public static bool IsEmpty => tracked.Count == 0;

        /// <summary>
        /// Initializes static members of the <see cref="ProjectedObjectCache"/> class.
        /// </summary>
        static ProjectedObjectCache()
        {
            NativeLibraryHelpers.CheckStatus(NativeLibrary.aoa_set_projected_object_cleanup(projectedObjectCleanupHandlerDelegate));
        }

        /// <summary>
        /// Adds the specified instance to the cache.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void Add(ICachedObject instance)
        {
            if (instance is null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            lock (tracked)
            {
                if (!tracked.TryGetValue(instance.Cookie, out WeakReference<ICachedObject> cachedReference))
                {
                    tracked[instance.Cookie] = new System.WeakReference<ICachedObject>(instance);
                    return;
                }

                // Ensure that we have a good reference.
                if (!cachedReference.TryGetTarget(out _))
                {
                    cachedReference.SetTarget(instance);
                }
            }
        }

        /// <summary>
        /// Gets a cached instance using the specified instance cookie.
        /// If a cached instance isn't found, a new instance is created using the <paramref name="createFactory"/>, which
        /// is then cached and returned.
        /// </summary>
        /// <typeparam name="T">The type of the object to get or create.</typeparam>
        /// <param name="cookie">The cookie.</param>
        /// <param name="createFactory">The create factory.</param>
        /// <returns>A cached instance of type <typeparamref name="T"/>.</returns>
        /// <exception cref="ArgumentException"><paramref name="cookie"/> is not valid.</exception>
        public static T GetOrCreate<T>(ulong cookie, Func<ulong, T> createFactory)
            where T : class, ICachedObject
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            ICachedObject referenceTarget;

            lock (tracked)
            {
                if (tracked.TryGetValue(cookie, out System.WeakReference<ICachedObject> reference))
                {
                    if (!reference.TryGetTarget(out referenceTarget))
                    {
                        // The reference is gone, so create a new one.
                        referenceTarget = createFactory(cookie);
                        tracked[cookie].SetTarget(referenceTarget);
                    }
                }
                else
                {
                    // Object is not being tracked. Create an instance and track it.
                    referenceTarget = createFactory(cookie);
                    tracked[cookie] = new System.WeakReference<ICachedObject>(referenceTarget);
                }
            }

            return (T)referenceTarget;
        }

        /// <summary>
        /// Removes the specified instance from the cache.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public static void Remove(ICachedObject instance)
        {
            if (instance is null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            Remove(instance.Cookie);
        }

        /// <summary>
        /// Removes the specified instance from the cache using the instance cookie.
        /// </summary>
        /// <param name="cookie">The cookie.</param>
        /// <exception cref="ArgumentException"></exception>
        public static void Remove(ulong cookie)
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            lock (tracked)
            {
                tracked.Remove(cookie);
            }
        }

        [AOT.MonoPInvokeCallback(typeof(Microsoft.Azure.ObjectAnchors.ProjectedObjectCleanupNative))]
        private static void ProjectedObjectCleanupHandler(IntPtr handle)
        {
            ulong cookie = ProjectedObjectHelpers.ConvertHandleToCookie(handle);
            Remove(cookie);
            ProjectedObjectEventHandlerCache.Clear(cookie);
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ObjectInstanceChangedHandlerNative(ulong cookie, IntPtr args);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ProjectedObjectCleanupNative(IntPtr handle);

    // Nullable type helpers.

    [StructLayout(LayoutKind.Sequential)]
    internal struct ObjectInstanceStateNullable
    {
        [MarshalAs(UnmanagedType.U1)]
        public bool has_value;

        public Microsoft.Azure.ObjectAnchors.ObjectInstanceStateAbi value;

        public Microsoft.Azure.ObjectAnchors.ObjectInstanceStateAbi? Convert()
        {
            if (this.has_value)
            {
                return this.value;
            }

            return null;
        }
    }

    internal static partial class NativeLibrary
    {
        internal const string DllName = "Microsoft.Azure.ObjectAnchors.dll";
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_account_information_addref(IntPtr handle);
        [DllImport(DllName, EntryPoint="aoa_account_information_create_guid_account_id_string_account_key_string_account_domain_wide", CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_account_information_create_guid_account_id_string_account_key_string_account_domain(System.Guid account_id, [MarshalAs(UnmanagedType.LPWStr)] string account_key, [MarshalAs(UnmanagedType.LPWStr)] string account_domain, out IntPtr instance);
        [DllImport(DllName, EntryPoint="aoa_account_information_get_account_domain_wide", CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_account_information_get_account_domain(IntPtr handle, [MarshalAs(UnmanagedType.LPWStr)] out string result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_account_information_get_account_id(IntPtr handle, out System.Guid result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_account_information_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_environment_observation_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_environment_observation_get_last_updated_time(IntPtr handle, out long result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_environment_observation_get_origin(IntPtr handle, out Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphLocation result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_environment_observation_get_triangle_index_count(IntPtr handle, out uint result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_environment_observation_get_triangle_indices(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2), Out] uint[] indices, int indices_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_environment_observation_get_vertex_count(IntPtr handle, out uint result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_environment_observation_get_vertex_normals(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2), Out] System.Numerics.Vector3[] normals, int normals_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_environment_observation_get_vertex_positions(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2), Out] System.Numerics.Vector3[] vertices, int vertices_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_environment_observation_release(IntPtr handle);
        [DllImport(DllName, EntryPoint="aoa_get_error_details_wide", CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_get_error_details(IntPtr handle, [MarshalAs(UnmanagedType.LPWStr)] out string result_message, [MarshalAs(UnmanagedType.LPWStr)] out string result_requestCorrelationVector, [MarshalAs(UnmanagedType.LPWStr)] out string result_responseCorrelationVector);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_ilist_object_instance_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_ilist_object_instance_get_count(IntPtr handle, out int result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_ilist_object_instance_get_item(IntPtr handle, int index, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_ilist_object_instance_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_ilist_object_instance_remove_item(IntPtr handle, int index);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_ilist_object_instance_set_item(IntPtr handle, int index, IntPtr value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_ilist_object_search_area_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_ilist_object_search_area_get_count(IntPtr handle, out int result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_ilist_object_search_area_get_item(IntPtr handle, int index, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_ilist_object_search_area_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_ilist_object_search_area_remove_item(IntPtr handle, int index);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_ilist_object_search_area_set_item(IntPtr handle, int index, IntPtr value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_anchors_session_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_anchors_session_create_account_information_account_information(IntPtr account_information, out IntPtr instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_anchors_session_create_object_observer(IntPtr handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_anchors_session_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_changed_event_args_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_changed_event_args_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_dispose(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_get_mode(IntPtr handle, out Microsoft.Azure.ObjectAnchors.ObjectInstanceTrackingMode result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_get_model_id(IntPtr handle, out System.Guid result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_placement_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_placement_compute_model_pose_for_view(IntPtr handle, Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialPose view_in_world, System.Numerics.Matrix4x4 world_to_reference, out Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialPose result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_placement_get_state(IntPtr handle, out Microsoft.Azure.ObjectAnchors.ObjectInstanceStateAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_placement_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_set_changed(IntPtr handle, ulong value, Microsoft.Azure.ObjectAnchors.ObjectInstanceChangedHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_set_mode(IntPtr handle, Microsoft.Azure.ObjectAnchors.ObjectInstanceTrackingMode value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_try_get_current_placement(IntPtr handle, Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphCoordinateSystem reference_coordinate_system, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_instance_try_get_current_state(IntPtr handle, out Microsoft.Azure.ObjectAnchors.ObjectInstanceStateNullable result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_model_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_model_dispose(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_model_get_bounding_box(IntPtr handle, out Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialOrientedBox result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_model_get_id(IntPtr handle, out System.Guid result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_model_get_origin_to_center_transform(IntPtr handle, out System.Numerics.Matrix4x4 result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_model_get_triangle_index_count(IntPtr handle, out uint result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_model_get_triangle_indices(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2), Out] uint[] indices, int indices_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_model_get_vertex_count(IntPtr handle, out uint result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_model_get_vertex_normals(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2), Out] System.Numerics.Vector3[] normals, int normals_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_model_get_vertex_positions(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2), Out] System.Numerics.Vector3[] vertices, int vertices_count);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_model_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_observer_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_observer_detect_async_object_query_query(IntPtr handle, IntPtr query, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_observer_detect_async_queries(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2), In] IntPtr[] queries, int queries_count, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_observer_dispose(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_observer_is_supported([MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_observer_load_object_model_async(IntPtr handle, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2), In] byte[] buffer, int buffer_count, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_observer_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_observer_request_access_async(out Microsoft.Azure.ObjectAnchors.ObjectObserverAccessStatus result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_compute_latest_environment_observation_async(IntPtr handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_compute_latest_environment_observation_async_environment_observation_topology_topology(IntPtr handle, Microsoft.Azure.ObjectAnchors.EnvironmentObservationTopology topology, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_create_object_model_model(IntPtr model, out IntPtr instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_create_object_model_model_object_observation_mode_observation_mode(IntPtr model, Microsoft.Azure.ObjectAnchors.ObjectObservationMode observation_mode, out IntPtr instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_dispose(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_get_expected_max_vertical_orientation_in_degrees(IntPtr handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_get_is_expected_to_be_standing_on_ground_plane(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_get_max_scale_change(IntPtr handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_get_min_surface_coverage(IntPtr handle, out float result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_get_search_areas(IntPtr handle, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_set_expected_max_vertical_orientation_in_degrees(IntPtr handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_set_is_expected_to_be_standing_on_ground_plane(IntPtr handle, [MarshalAs(UnmanagedType.U1)] bool value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_set_max_scale_change(IntPtr handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_query_set_min_surface_coverage(IntPtr handle, float value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_search_area_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_search_area_from_field_of_view(Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphCoordinateSystem coordinate_system, Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialFieldOfView field_of_view, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_search_area_from_location(Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphCoordinateSystem coordinate_system, System.Numerics.Vector3 position, System.Numerics.Quaternion orientation, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_search_area_from_oriented_box(Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphCoordinateSystem coordinate_system, Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialOrientedBox bounds, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_search_area_from_sphere(Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphCoordinateSystem coordinate_system, Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialSphere sphere, out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_search_area_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_set_projected_object_cleanup(Microsoft.Azure.ObjectAnchors.ProjectedObjectCleanupNative callback);
    }

    // CODE STARTS HERE

    abstract class BasePrivateDictionary<TKey, TValue> : IDictionary<TKey, TValue>
    {
        protected abstract int InternalGetCount();
        protected abstract TKey InternalGetKey(int index);
        protected abstract TValue InternalGetItem(TKey key);
        protected abstract void InternalSetItem(TKey key, TValue value);
        protected abstract void InternalRemoveKey(TKey key);

        public TValue this[TKey key] { get { return InternalGetItem(key); } set { InternalSetItem(key, value); } }

        public ICollection<TKey> Keys { get { return Enumerable.Range(0, InternalGetCount()).Select(n => InternalGetKey(n)).ToList().AsReadOnly(); } }

        public ICollection<TValue> Values { get { return Enumerable.Range(0, InternalGetCount()).Select(n => InternalGetKey(n)).Select(k => InternalGetItem(k)).ToList().AsReadOnly(); } }

        public int Count { get { return InternalGetCount(); } }

        public bool IsReadOnly { get { return false; } }

        public void Add(TKey key, TValue value)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                InternalSetItem(key, value);
                return;
            }
            throw new ArgumentException();
        }

        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        public void Clear()
        {
            while (InternalGetCount() > 0)
            {
                TKey key = InternalGetKey(0);
                InternalRemoveKey(key);
            }
        }

        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            try
            {
                TValue value = InternalGetItem(item.Key);
                if (Comparer<TValue>.Default.Compare(value, item.Value) == 0)
                {
                    return true;
                }
                return false;
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
        }

        public bool ContainsKey(TKey key)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            return true;
        }

        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                array[arrayIndex + i] = new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }

        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                yield return new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }

        public bool Remove(TKey key)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            InternalRemoveKey(key);
            return true;
        }

        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return Remove(item.Key);
        }

        public bool TryGetValue(TKey key, out TValue value)
        {
            try
            {
                value = InternalGetItem(key);
                return true;
            }
            catch (KeyNotFoundException)
            {
                value = default(TValue);
                return false;
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                yield return new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }
    }

    abstract class BasePrivateList<T> : IList<T>
    {
        protected abstract int InternalGetCount();
        protected abstract T InternalGetItem(int index);
        protected abstract void InternalSetItem(int index, T value);
        protected abstract void InternalRemoveItem(int index);

        public int Count { get { return InternalGetCount(); } }

        public bool IsReadOnly { get { return false; } }

        public T this[int index] { get { return InternalGetItem(index); } set { InternalSetItem(index, value); } }

        public int IndexOf(T item)
        {
            int count = InternalGetCount();
            for (int i = 0; i < count; i++)
            {
                if (Comparer<T>.Default.Compare(item, InternalGetItem(i)) == 0)
                {
                    return i;
                }
            }
            return -1;
        }

        public void Insert(int index, T item)
        {
            InternalSetItem(index, item);
        }

        public void RemoveAt(int index)
        {
            InternalRemoveItem(index);
        }

        public void Add(T item)
        {
            InternalSetItem(InternalGetCount(), item);
        }

        public void Clear()
        {
            while (InternalGetCount() > 0)
            {
                InternalRemoveItem(0);
            }
        }

        public bool Contains(T item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            for (int i = 0; i < Count; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public bool Remove(T item)
        {
            int index = IndexOf(item);
            if (index < 0) return false;
            InternalRemoveItem(index);
            return true;
        }

        public IEnumerator<T> GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }
    }

    class IList_ObjectSearchArea : BasePrivateList<ObjectSearchArea>
    {
        internal IntPtr handle;

        internal IList_ObjectSearchArea(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_ilist_object_search_area_addref(ahandle);
        }
        ~IList_ObjectSearchArea()
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_ilist_object_search_area_release(this.handle));
            this.handle = IntPtr.Zero;
        }
        protected override int InternalGetCount()
        {
            int result;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_ilist_object_search_area_get_count(this.handle, out result));
            return result;
        }
        protected override ObjectSearchArea InternalGetItem(int index)
        {
            IntPtr result_handle;
            Microsoft.Azure.ObjectAnchors.ObjectSearchArea result_object;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_ilist_object_search_area_get_item(this.handle, index, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? Microsoft.Azure.ObjectAnchors.ObjectSearchArea.GetOrCreateInstance(result_handle, transfer: true) : null;
            return result_object;
        }
        protected override void InternalSetItem(int index, ObjectSearchArea value)
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_ilist_object_search_area_set_item(this.handle, index, value != null ? value.handle : IntPtr.Zero));
        }
        protected override void InternalRemoveItem(int index)
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_ilist_object_search_area_remove_item(this.handle, index));
        }
    }
    class IList_ObjectInstance : BasePrivateList<ObjectInstance>
    {
        internal IntPtr handle;

        internal IList_ObjectInstance(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_ilist_object_instance_addref(ahandle);
        }
        ~IList_ObjectInstance()
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_ilist_object_instance_release(this.handle));
            this.handle = IntPtr.Zero;
        }
        protected override int InternalGetCount()
        {
            int result;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_ilist_object_instance_get_count(this.handle, out result));
            return result;
        }
        protected override ObjectInstance InternalGetItem(int index)
        {
            IntPtr result_handle;
            Microsoft.Azure.ObjectAnchors.ObjectInstance result_object;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_ilist_object_instance_get_item(this.handle, index, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? Microsoft.Azure.ObjectAnchors.ObjectInstance.GetOrCreateInstance(result_handle, transfer: true) : null;
            return result_object;
        }
        protected override void InternalSetItem(int index, ObjectInstance value)
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_ilist_object_instance_set_item(this.handle, index, value != null ? value.handle : IntPtr.Zero));
        }
        protected override void InternalRemoveItem(int index)
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_ilist_object_instance_remove_item(this.handle, index));
        }
    }
    /// <summary>
    /// Defines a "control point" that maps a location in the Spatial Graph to the model coordinate which should be placed there. A control point's accuracy is biased to the Spatial Graph node it is anchored to, so when rendering content relative to the object, control points bound to static nodes that are near the user should be given greater weight.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct ObjectControlPoint
    {
        /// <summary>
        /// Location of the control point relative to a static node in the Spatial Graph.
        /// </summary>
        public Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphLocation Location;

        /// <summary>
        /// Position and orientation of the model coordinate that should be placed at the control point's location.
        /// </summary>
        public Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialPose ModelCoordinate;

    }

    /// <summary>
    /// State of an object instance.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct ObjectInstanceStateAbi
    {
        /// <summary>
        /// Last updated time.
        /// </summary>
        public long LastUpdatedTime;

        /// <summary>
        /// Percentage of surface on object model that matches to real object at current pose, from 0 to 1. The higher the better.
        /// </summary>
        public float SurfaceCoverage;

        /// <summary>
        /// Center of this object instance in the coordinate frame of a spatial graph node.
        /// </summary>
        public Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphLocation Center;

        /// <summary>
        /// Scale changes applied to object model in centered coordinate system.
        /// </summary>
        public System.Numerics.Vector3 ScaleChange;

        public Microsoft.Azure.ObjectAnchors.ObjectInstanceState Convert()
        {
            return Microsoft.Azure.ObjectAnchors.ObjectInstanceStateAbi.Convert(this);
        }

        public static Microsoft.Azure.ObjectAnchors.ObjectInstanceState Convert(Microsoft.Azure.ObjectAnchors.ObjectInstanceStateAbi value)
        {
            Microsoft.Azure.ObjectAnchors.ObjectInstanceState result = new Microsoft.Azure.ObjectAnchors.ObjectInstanceState();

            result.LastUpdatedTime = (value.LastUpdatedTime == 0) ? DateTimeOffset.MaxValue : DateTimeOffset.FromUnixTimeMilliseconds(value.LastUpdatedTime);
            result.SurfaceCoverage = value.SurfaceCoverage;
            result.Center = value.Center;
            result.ScaleChange = value.ScaleChange;

            return result;
        }
    }

    /// <summary>
    /// State of an object instance.
    /// </summary>
    public partial struct ObjectInstanceState
    {
        /// <summary>
        /// Last updated time.
        /// </summary>
        public DateTimeOffset LastUpdatedTime;

        /// <summary>
        /// Percentage of surface on object model that matches to real object at current pose, from 0 to 1. The higher the better.
        /// </summary>
        public float SurfaceCoverage;

        /// <summary>
        /// Center of this object instance in the coordinate frame of a spatial graph node.
        /// </summary>
        public Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphLocation Center;

        /// <summary>
        /// Scale changes applied to object model in centered coordinate system.
        /// </summary>
        public System.Numerics.Vector3 ScaleChange;

        internal Microsoft.Azure.ObjectAnchors.ObjectInstanceStateAbi Convert()
        {
            return Microsoft.Azure.ObjectAnchors.ObjectInstanceState.Convert(this);
        }

        internal static Microsoft.Azure.ObjectAnchors.ObjectInstanceStateAbi Convert(Microsoft.Azure.ObjectAnchors.ObjectInstanceState value)
        {
            Microsoft.Azure.ObjectAnchors.ObjectInstanceStateAbi result = new Microsoft.Azure.ObjectAnchors.ObjectInstanceStateAbi();

            result.LastUpdatedTime = (value.LastUpdatedTime == DateTimeOffset.MaxValue) ? 0 : value.LastUpdatedTime.ToUnixTimeMilliseconds();
            result.SurfaceCoverage = value.SurfaceCoverage;
            result.Center = value.Center;
            result.ScaleChange = value.ScaleChange;

            return result;
        }
    }

    /// <summary>
    /// Specifies the desired topology for an environment observation. Requesting a triangle mesh requires additional time and resources versus a point cloud.
    /// </summary>
    public enum EnvironmentObservationTopology : int
    {
        PointCloud = 0,
        TriangleList = 1,
    }

    /// <summary>
    /// Specifies how the environment should be observed to detect objects. Ambient observation relies on information about the environment that has been gathered by the system automatically as the user uses the device. This can result in quicker detection initially since the environment may already be scanned. However it may also contain stale data which can lead to poorer quality results. It is also limited to a standard resolution and area determined by the system, rather than tailored to the model. Active observation creates a fresh scan of the environment that is optimized for the model being detected. This avoids any problems with stale data, but requires the user to take some time to scan the environment before the object can be detected. Observations will continue to be accumulated until the query object is disposed, so re-using a query for multiple detections may produce quicker results.
    /// </summary>
    public enum ObjectObservationMode : int
    {
        Ambient = 0,
        Active = 1,
    }

    /// <summary>
    /// Tracking mode applied on an object instance.
    /// </summary>
    public enum ObjectInstanceTrackingMode : int
    {
        /// <summary>
        /// Pause tracking.
        /// </summary>
        Paused = 0,
        /// <summary>
        /// Track with low latency and expect coarse 6-Dof pose.
        /// </summary>
        LowLatencyCoarsePosition = 1,
        /// <summary>
        /// Track with high latency and expect accurate 6-Dof pose.
        /// </summary>
        HighLatencyAccuratePosition = 2,
    }

    /// <summary>
    /// Access status.
    /// </summary>
    public enum ObjectObserverAccessStatus : int
    {
        Allowed = 0,
        DeniedBySystem = 1,
        DeniedByUser = 2,
        NotDeclaredByApp = 3,
        UserPromptRequired = 4,
    }

    public delegate void ObjectInstanceChangedHandler(object sender, Microsoft.Azure.ObjectAnchors.ObjectInstanceChangedEventArgs args);

    /// <summary>
    /// Account information for the Azure Object Anchors account .
    /// </summary>
    public partial class AccountInformation : ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected AccountInformation(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_account_information_addref(ahandle);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AccountInformation"/> class. The Id of the Azure Object Anchors account.The key for the Azure Object Anchors account.The domain of the Azure Object Anchors account.
        /// </summary>
        /// <param name="accountId">
        /// The Id of the Azure Object Anchors account.
        /// </param>
        /// <param name="accountKey">
        /// The key for the Azure Object Anchors account.
        /// </param>
        /// <param name="accountDomain">
        /// The domain of the Azure Object Anchors account.
        /// </param>
        public AccountInformation(System.Guid accountId, string accountKey, string accountDomain)
        {
            Microsoft.Azure.ObjectAnchors.status resultStatus = (Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_account_information_create_guid_account_id_string_account_key_string_account_domain(accountId, accountKey, accountDomain, out this.handle));
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="AccountInformation"/> class.
        /// </summary>
        ~AccountInformation()
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_account_information_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// The Id of the Azure Object Anchors account.
        /// </summary>
        public System.Guid AccountId
        {
            get
            {
                System.Guid result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_account_information_get_account_id(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// The domain of the Azure Object Anchors account.
        /// </summary>
        public string AccountDomain
        {
            get
            {
                string result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_account_information_get_account_domain(this.handle, out result));
                return result;
            }
        }

        ulong ICachedObject.Cookie => ProjectedObjectHelpers.ConvertHandleToCookie(this.handle);

        internal static Microsoft.Azure.ObjectAnchors.AccountInformation GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ProjectedObjectHelpers.ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.Azure.ObjectAnchors.AccountInformation GetOrCreateInstance(ulong cookie, bool transfer)
        {
            IntPtr handle = ProjectedObjectHelpers.ConvertCookieToHandle(cookie);
            return Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.ObjectAnchors.AccountInformation>(
                cookie,
                _ => new Microsoft.Azure.ObjectAnchors.AccountInformation(handle, transfer: transfer));
        }
    }

    /// <summary>
    /// Snapshot of observations of the environment, e.g. in the context of an <see cref="ObjectQuery"/>.
    /// </summary>
    public partial class EnvironmentObservation : ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected EnvironmentObservation(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_environment_observation_addref(ahandle);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="EnvironmentObservation"/> class.
        /// </summary>
        ~EnvironmentObservation()
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_environment_observation_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Last updated time.
        /// </summary>
        public DateTimeOffset LastUpdatedTime
        {
            get
            {
                long result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_environment_observation_get_last_updated_time(this.handle, out result));
                return (result == 0) ? DateTimeOffset.MaxValue : DateTimeOffset.FromUnixTimeMilliseconds(result);
            }
        }

        /// <summary>
        /// Origin of coordinate system used to report vertices, etc.
        /// </summary>
        public Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphLocation Origin
        {
            get
            {
                Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphLocation result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_environment_observation_get_origin(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Number of vertices observed.
        /// </summary>
        public uint VertexCount
        {
            get
            {
                uint result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_environment_observation_get_vertex_count(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Index list length of triangles on surface mesh. May be zero if triangles were not requested.
        /// </summary>
        public uint TriangleIndexCount
        {
            get
            {
                uint result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_environment_observation_get_triangle_index_count(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns positions of vertices observed in the environment.
        /// </summary>
        /// <param name="vertices">
        /// Buffer to store the vertexes, allocated by the caller according to <see cref="EnvironmentObservation.VertexCount"/>.
        /// </param>
        public void GetVertexPositions([Out] System.Numerics.Vector3[] vertices)
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_environment_observation_get_vertex_positions(this.handle, vertices, vertices?.Length ?? 0));
        }

        /// <summary>
        /// Returns per-vertex normals observed in the environment.
        /// </summary>
        /// <param name="normals">
        /// Buffer to store the normals, allocated by the caller according to <see cref="EnvironmentObservation.VertexCount"/>.
        /// </param>
        public void GetVertexNormals([Out] System.Numerics.Vector3[] normals)
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_environment_observation_get_vertex_normals(this.handle, normals, normals?.Length ?? 0));
        }

        /// <summary>
        /// Returns triangle indices defining a mesh over the vertices. Will fail if triangles were not requested.
        /// </summary>
        /// <param name="indices">
        /// Buffer to store triangle indices, allocated by the caller according to <see cref="EnvironmentObservation.TriangleIndexCount"/>.
        /// </param>
        public void GetTriangleIndices([Out] uint[] indices)
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_environment_observation_get_triangle_indices(this.handle, indices, indices?.Length ?? 0));
        }

        ulong ICachedObject.Cookie => ProjectedObjectHelpers.ConvertHandleToCookie(this.handle);

        internal static Microsoft.Azure.ObjectAnchors.EnvironmentObservation GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ProjectedObjectHelpers.ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.Azure.ObjectAnchors.EnvironmentObservation GetOrCreateInstance(ulong cookie, bool transfer)
        {
            IntPtr handle = ProjectedObjectHelpers.ConvertCookieToHandle(cookie);
            return Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.ObjectAnchors.EnvironmentObservation>(
                cookie,
                _ => new Microsoft.Azure.ObjectAnchors.EnvironmentObservation(handle, transfer: transfer));
        }
    }

    /// <summary>
    /// An object representing an Azure Object Anchors session that is used to create ObjectObserver instances used to detect objects in the physical world.
    /// </summary>
    public partial class ObjectAnchorsSession : ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected ObjectAnchorsSession(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_anchors_session_addref(ahandle);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectAnchorsSession"/> class.
        /// </summary>
        /// <param name="accountInformation">
        /// The Azure Object Anchors account information.
        /// </param>
        public ObjectAnchorsSession(Microsoft.Azure.ObjectAnchors.AccountInformation accountInformation)
        {
            Microsoft.Azure.ObjectAnchors.status resultStatus = (Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_anchors_session_create_account_information_account_information(accountInformation != null ? accountInformation.handle : IntPtr.Zero, out this.handle));
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="ObjectAnchorsSession"/> class.
        /// </summary>
        ~ObjectAnchorsSession()
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_anchors_session_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Creates a new instance of an ObjectObserver.
        /// </summary>
        public Microsoft.Azure.ObjectAnchors.ObjectObserver CreateObjectObserver()
        {
            IntPtr result_handle;
            Microsoft.Azure.ObjectAnchors.ObjectObserver result_object;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_anchors_session_create_object_observer(this.handle, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? Microsoft.Azure.ObjectAnchors.ObjectObserver.GetOrCreateInstance(result_handle, transfer: true) : null;
            return result_object;
        }

        ulong ICachedObject.Cookie => ProjectedObjectHelpers.ConvertHandleToCookie(this.handle);

        internal static Microsoft.Azure.ObjectAnchors.ObjectAnchorsSession GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ProjectedObjectHelpers.ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.Azure.ObjectAnchors.ObjectAnchorsSession GetOrCreateInstance(ulong cookie, bool transfer)
        {
            IntPtr handle = ProjectedObjectHelpers.ConvertCookieToHandle(cookie);
            return Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.ObjectAnchors.ObjectAnchorsSession>(
                cookie,
                _ => new Microsoft.Azure.ObjectAnchors.ObjectAnchorsSession(handle, transfer: transfer));
        }
    }

    /// <summary>
    /// Information about the change of detected object instances.
    /// </summary>
    public partial class ObjectInstanceChangedEventArgs : System.EventArgs, ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected ObjectInstanceChangedEventArgs(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_changed_event_args_addref(ahandle);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="ObjectInstanceChangedEventArgs"/> class.
        /// </summary>
        ~ObjectInstanceChangedEventArgs()
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_changed_event_args_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        ulong ICachedObject.Cookie => ProjectedObjectHelpers.ConvertHandleToCookie(this.handle);

        internal static Microsoft.Azure.ObjectAnchors.ObjectInstanceChangedEventArgs GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ProjectedObjectHelpers.ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.Azure.ObjectAnchors.ObjectInstanceChangedEventArgs GetOrCreateInstance(ulong cookie, bool transfer)
        {
            IntPtr handle = ProjectedObjectHelpers.ConvertCookieToHandle(cookie);
            return Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.ObjectAnchors.ObjectInstanceChangedEventArgs>(
                cookie,
                _ => new Microsoft.Azure.ObjectAnchors.ObjectInstanceChangedEventArgs(handle, transfer: transfer));
        }
    }

    /// <summary>
    /// Instance of a detected object returned by object observer.
    /// </summary>
    public partial class ObjectInstance : IDisposable, ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected ObjectInstance(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_addref(ahandle);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="ObjectInstance"/> class.
        /// </summary>
        ~ObjectInstance()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.aoa_object_instance_release(this.handle));
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.aoa_object_instance_dispose(this.handle));
        }

        /// <summary>
        /// Id of the object model associated with this instance.
        /// </summary>
        public System.Guid ModelId
        {
            get
            {
                System.Guid result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_get_model_id(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Tracking mode.
        /// </summary>
        public Microsoft.Azure.ObjectAnchors.ObjectInstanceTrackingMode Mode
        {
            get
            {
                Microsoft.Azure.ObjectAnchors.ObjectInstanceTrackingMode result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_get_mode(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_set_mode(this.handle, value));
            }
        }

        /// <summary>Static handler.</summary>
        [AOT.MonoPInvokeCallback(typeof(ObjectInstanceChangedHandlerNative))]
        private static void ChangedStaticHandler(ulong cookie, IntPtr args)
        {
            Microsoft.Azure.ObjectAnchors.ObjectInstance instance = GetOrCreateInstance(cookie, transfer: false);

            if (instance == null)
            {
                throw new System.InvalidOperationException("The object instance is not tracked by the cache.");
            }

            Microsoft.Azure.ObjectAnchors.ObjectInstanceChangedHandler handler =
                Microsoft.Azure.ObjectAnchors.ProjectedObjectEventHandlerCache.GetEventHandler<Microsoft.Azure.ObjectAnchors.ObjectInstanceChangedHandler>(
                    instance,
                    nameof(Changed));

            handler?.Invoke(instance, Microsoft.Azure.ObjectAnchors.ObjectInstanceChangedEventArgs.GetOrCreateInstance(args, transfer: false));
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.Azure.ObjectAnchors.ObjectInstanceChangedHandlerNative ChangedStaticHandlerDelegate = ChangedStaticHandler;
        public event Microsoft.Azure.ObjectAnchors.ObjectInstanceChangedHandler Changed
        {
            add
            {
                Microsoft.Azure.ObjectAnchors.ProjectedObjectEventHandlerCache.AddEventHandler(this, nameof(this.Changed), value);
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_set_changed(this.handle, ((ICachedObject)this).Cookie, ChangedStaticHandlerDelegate));
            }
            remove
            {
                Microsoft.Azure.ObjectAnchors.ProjectedObjectEventHandlerCache.RemoveEventHandler(this, nameof(this.Changed), value);
            }
        }

        /// <summary>
        /// Returns current instance state. Returns null if an instance is closed or lost during tracking.
        /// </summary>
        public Microsoft.Azure.ObjectAnchors.ObjectInstanceState? TryGetCurrentState()
        {
            Microsoft.Azure.ObjectAnchors.ObjectInstanceStateNullable result;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_try_get_current_state(this.handle, out result));
            Microsoft.Azure.ObjectAnchors.ObjectInstanceStateAbi? result_nullable_converted = result.Convert();
            Microsoft.Azure.ObjectAnchors.ObjectInstanceState? result_abi_converted = result_nullable_converted?.Convert() ?? null;
            return result_abi_converted;
        }

        /// <summary>
        /// Returns current placement of the object, expressed in the given reference coordinate system. Returns null if an instance is closed or lost during tracking.
        /// </summary>
        public Microsoft.Azure.ObjectAnchors.ObjectInstancePlacement TryGetCurrentPlacement(Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphCoordinateSystem referenceCoordinateSystem)
        {
            IntPtr result_handle;
            Microsoft.Azure.ObjectAnchors.ObjectInstancePlacement result_object;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_try_get_current_placement(this.handle, referenceCoordinateSystem, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? Microsoft.Azure.ObjectAnchors.ObjectInstancePlacement.GetOrCreateInstance(result_handle, transfer: true) : null;
            return result_object;
        }

        ulong ICachedObject.Cookie => ProjectedObjectHelpers.ConvertHandleToCookie(this.handle);

        internal static Microsoft.Azure.ObjectAnchors.ObjectInstance GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ProjectedObjectHelpers.ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.Azure.ObjectAnchors.ObjectInstance GetOrCreateInstance(ulong cookie, bool transfer)
        {
            IntPtr handle = ProjectedObjectHelpers.ConvertCookieToHandle(cookie);
            return Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.ObjectAnchors.ObjectInstance>(
                cookie,
                _ => new Microsoft.Azure.ObjectAnchors.ObjectInstance(handle, transfer: transfer));
        }
    }

    /// <summary>
    /// Placement of an object, including the corresponding state of the object instance.
    /// </summary>
    public partial class ObjectInstancePlacement : ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected ObjectInstancePlacement(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_placement_addref(ahandle);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="ObjectInstancePlacement"/> class.
        /// </summary>
        ~ObjectInstancePlacement()
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_placement_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Instance state associated with this placement.
        /// </summary>
        public Microsoft.Azure.ObjectAnchors.ObjectInstanceState State
        {
            get
            {
                Microsoft.Azure.ObjectAnchors.ObjectInstanceStateAbi result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_placement_get_state(this.handle, out result));
                return result.Convert();
            }
        }

        /// <summary>
        /// Computes the pose of the center of the model, optimized for the specified view. The view and model poses are expressed in an app-defined world coordinate system, determined by the transform provided relative to the reference coordinate system used to obtain this placement. The pose is computed using by weighting the placement's control points according to their proximity to the view.
        /// </summary>
        /// <param name="viewInWorld">
        /// The pose of the view to optimize for, expressed in the application's world coordinate system.
        /// </param>
        /// <param name="worldToReference">
        /// Transform from the application's world coordinate system to the reference coordinate system used to obtain this placement.
        /// </param>
        public Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialPose ComputeModelPoseForView(Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialPose viewInWorld, System.Numerics.Matrix4x4 worldToReference)
        {
            Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialPose result;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_instance_placement_compute_model_pose_for_view(this.handle, viewInWorld, worldToReference, out result));
            return result;
        }

        ulong ICachedObject.Cookie => ProjectedObjectHelpers.ConvertHandleToCookie(this.handle);

        internal static Microsoft.Azure.ObjectAnchors.ObjectInstancePlacement GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ProjectedObjectHelpers.ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.Azure.ObjectAnchors.ObjectInstancePlacement GetOrCreateInstance(ulong cookie, bool transfer)
        {
            IntPtr handle = ProjectedObjectHelpers.ConvertCookieToHandle(cookie);
            return Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.ObjectAnchors.ObjectInstancePlacement>(
                cookie,
                _ => new Microsoft.Azure.ObjectAnchors.ObjectInstancePlacement(handle, transfer: transfer));
        }
    }

    /// <summary>
    /// An object model exposes visual and geometrics information about a physical object to be detected, as well as parameters to determine how that object can be detected by the object observer.
    /// </summary>
    public partial class ObjectModel : IDisposable, ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected ObjectModel(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_model_addref(ahandle);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="ObjectModel"/> class.
        /// </summary>
        ~ObjectModel()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.aoa_object_model_release(this.handle));
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.aoa_object_model_dispose(this.handle));
        }

        /// <summary>
        /// Unique id of an object model.
        /// </summary>
        public System.Guid Id
        {
            get
            {
                System.Guid result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_model_get_id(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Bounding box aligned to object's principle axii, with size in meters.
        /// </summary>
        public Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialOrientedBox BoundingBox
        {
            get
            {
                Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialOrientedBox result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_model_get_bounding_box(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Transform from the model origin to centered coordinate system.
        /// </summary>
        public System.Numerics.Matrix4x4 OriginToCenterTransform
        {
            get
            {
                System.Numerics.Matrix4x4 result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_model_get_origin_to_center_transform(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Number of vertices on object model surface.
        /// </summary>
        public uint VertexCount
        {
            get
            {
                uint result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_model_get_vertex_count(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Index list length of triangles on object model surface.
        /// </summary>
        public uint TriangleIndexCount
        {
            get
            {
                uint result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_model_get_triangle_index_count(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns vertices on object model surface in centered coordinate system.
        /// </summary>
        /// <param name="vertices">
        /// Buffer to store the vertexes, allocated by the caller.
        /// </param>
        public void GetVertexPositions([Out] System.Numerics.Vector3[] vertices)
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_model_get_vertex_positions(this.handle, vertices, vertices?.Length ?? 0));
        }

        /// <summary>
        /// Returns normals on object model surface in centered coordinate system.
        /// </summary>
        /// <param name="normals">
        /// Buffer to store the normals, allocated by the caller.
        /// </param>
        public void GetVertexNormals([Out] System.Numerics.Vector3[] normals)
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_model_get_vertex_normals(this.handle, normals, normals?.Length ?? 0));
        }

        /// <summary>
        /// Returns triangle indices on object model surface.
        /// </summary>
        /// <param name="indices">
        /// Buffer to store triangle indices, allocated by the caller.
        /// </param>
        public void GetTriangleIndices([Out] uint[] indices)
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_model_get_triangle_indices(this.handle, indices, indices?.Length ?? 0));
        }

        ulong ICachedObject.Cookie => ProjectedObjectHelpers.ConvertHandleToCookie(this.handle);

        internal static Microsoft.Azure.ObjectAnchors.ObjectModel GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ProjectedObjectHelpers.ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.Azure.ObjectAnchors.ObjectModel GetOrCreateInstance(ulong cookie, bool transfer)
        {
            IntPtr handle = ProjectedObjectHelpers.ConvertCookieToHandle(cookie);
            return Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.ObjectAnchors.ObjectModel>(
                cookie,
                _ => new Microsoft.Azure.ObjectAnchors.ObjectModel(handle, transfer: transfer));
        }
    }

    /// <summary>
    /// An object observer detects and tracks multiple object instances simultaneously based on a list of user-provided object models.By default it looks for object within a moving sphere centered at current head location. User can explicitly specify a search area that contains one or multiple objects or provide more accurate location hint per object model to improve the performance.
    /// </summary>
    public partial class ObjectObserver : IDisposable, ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected ObjectObserver(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_observer_addref(ahandle);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="ObjectObserver"/> class.
        /// </summary>
        ~ObjectObserver()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.aoa_object_observer_release(this.handle));
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.aoa_object_observer_dispose(this.handle));
        }

        /// <summary>
        /// Returns true if this feature is supported on this platform and device.
        /// </summary>
        public static bool IsSupported()
        {
            bool result;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_observer_is_supported(out result));
            return result;
        }

        /// <summary>
        /// Requests access to this feature and returns access status.
        /// </summary>
        public static async System.Threading.Tasks.Task<Microsoft.Azure.ObjectAnchors.ObjectObserverAccessStatus> RequestAccessAsync()
        {
            return await Task.Run(() =>
            {
                Microsoft.Azure.ObjectAnchors.ObjectObserverAccessStatus result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_observer_request_access_async(out result));
                return result;
            });
        }

        /// <summary>
        /// Load an object model for detecting its instance.
        /// </summary>
        /// <param name="buffer">
        /// Byte array of an object model blob.
        /// </param>
        public async System.Threading.Tasks.Task<Microsoft.Azure.ObjectAnchors.ObjectModel> LoadObjectModelAsync([In] byte[] buffer)
        {
            return await Task.Run(() =>
            {
                IntPtr result_handle;
                Microsoft.Azure.ObjectAnchors.ObjectModel result_object;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_observer_load_object_model_async(this.handle, buffer, buffer?.Length ?? 0, out result_handle));
                result_object = Microsoft.Azure.ObjectAnchors.ObjectModel.GetOrCreateInstance(result_handle, transfer: true);
                return result_object;
            });
        }

        /// <summary>
        /// Detects object instances of a single model with the given query parameters.
        /// </summary>
        /// <param name="query">
        /// An object query.
        /// </param>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IList<Microsoft.Azure.ObjectAnchors.ObjectInstance>> DetectAsync(Microsoft.Azure.ObjectAnchors.ObjectQuery query)
        {
            return await Task.Run(() =>
            {
                IntPtr result_handle;
                IList_ObjectInstance result_object;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_observer_detect_async_object_query_query(this.handle, query != null ? query.handle : IntPtr.Zero, out result_handle));
                result_object = new IList_ObjectInstance(result_handle, transfer: true);
                return result_object;
            });
        }

        /// <summary>
        /// Detects object instances of multiple models with the given query parameters.
        /// </summary>
        /// <param name="queries">
        /// An array of object queries.
        /// </param>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IList<Microsoft.Azure.ObjectAnchors.ObjectInstance>> DetectAsync([In] Microsoft.Azure.ObjectAnchors.ObjectQuery[] queries)
        {
            return await Task.Run(() =>
            {
                IntPtr[] queries_array = queries?.Select(x => x?.handle ?? IntPtr.Zero).ToArray() ?? Array.Empty<IntPtr>();
                IntPtr result_handle;
                IList_ObjectInstance result_object;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_observer_detect_async_queries(this.handle, queries_array, queries?.Length ?? 0, out result_handle));
                result_object = new IList_ObjectInstance(result_handle, transfer: true);
                return result_object;
            });
        }

        ulong ICachedObject.Cookie => ProjectedObjectHelpers.ConvertHandleToCookie(this.handle);

        internal static Microsoft.Azure.ObjectAnchors.ObjectObserver GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ProjectedObjectHelpers.ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.Azure.ObjectAnchors.ObjectObserver GetOrCreateInstance(ulong cookie, bool transfer)
        {
            IntPtr handle = ProjectedObjectHelpers.ConvertCookieToHandle(cookie);
            return Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.ObjectAnchors.ObjectObserver>(
                cookie,
                _ => new Microsoft.Azure.ObjectAnchors.ObjectObserver(handle, transfer: transfer));
        }
    }

    /// <summary>
    /// Object query parameters associated with an object model.
    /// </summary>
    public partial class ObjectQuery : IDisposable, ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected ObjectQuery(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_addref(ahandle);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Constructs a query object from an object model using ambient query mode, and initializes parameters with default values inherited from the model.
        /// </summary>
        /// <param name="model">
        /// The model.
        /// </param>
        public ObjectQuery(Microsoft.Azure.ObjectAnchors.ObjectModel model)
        {
            Microsoft.Azure.ObjectAnchors.status resultStatus = (Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_create_object_model_model(model != null ? model.handle : IntPtr.Zero, out this.handle));
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Constructs a query object from an object model using the specified query mode, and initializes parameters with default values inherited from the model.
        /// </summary>
        /// <param name="model">
        /// The model.
        /// </param>
        /// <param name="observationMode">
        /// The observation mode.
        /// </param>
        public ObjectQuery(Microsoft.Azure.ObjectAnchors.ObjectModel model, Microsoft.Azure.ObjectAnchors.ObjectObservationMode observationMode)
        {
            Microsoft.Azure.ObjectAnchors.status resultStatus = (Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_create_object_model_model_object_observation_mode_observation_mode(model != null ? model.handle : IntPtr.Zero, observationMode, out this.handle));
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="ObjectQuery"/> class.
        /// </summary>
        ~ObjectQuery()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.aoa_object_query_release(this.handle));
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            NativeLibraryHelpers.CheckStatus(this.handle, NativeLibrary.aoa_object_query_dispose(this.handle));
        }

        /// <summary>
        /// Minimum required surface coverage ratio to consider an object instance as true positive, from 0 to 1.
        /// </summary>
        public float MinSurfaceCoverage
        {
            get
            {
                float result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_get_min_surface_coverage(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_set_min_surface_coverage(this.handle, value));
            }
        }

        /// <summary>
        /// Prior on object's location whether standing on ground plane or not.
        /// </summary>
        public bool IsExpectedToBeStandingOnGroundPlane
        {
            get
            {
                bool result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_get_is_expected_to_be_standing_on_ground_plane(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_set_is_expected_to_be_standing_on_ground_plane(this.handle, value));
            }
        }

        /// <summary>
        /// Expected maximum angle in degrees between up direction of an object instance and gravity, from 0 to 180. Small value indicates object is expected to be up-right, while large value allows more variation on the layout.
        /// </summary>
        public float ExpectedMaxVerticalOrientationInDegrees
        {
            get
            {
                float result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_get_expected_max_vertical_orientation_in_degrees(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_set_expected_max_vertical_orientation_in_degrees(this.handle, value));
            }
        }

        /// <summary>
        /// Maximum scale change from 1.
        /// </summary>
        public float MaxScaleChange
        {
            get
            {
                float result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_get_max_scale_change(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_set_max_scale_change(this.handle, value));
            }
        }

        /// <summary>
        /// A collection of search areas that define the regions to look for objects.
        /// </summary>
        public System.Collections.Generic.IList<Microsoft.Azure.ObjectAnchors.ObjectSearchArea> SearchAreas
        {
            get
            {
                IntPtr result_handle;
                IList_ObjectSearchArea result_object;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_get_search_areas(this.handle, out result_handle));
                result_object = new IList_ObjectSearchArea(result_handle, transfer: true);
                return result_object;
            }
        }

        /// <summary>
        /// Computes the current environment observation in the region defined by <see cref="ObjectQuery.SearchAreas"/>.
        /// </summary>
        public async System.Threading.Tasks.Task<Microsoft.Azure.ObjectAnchors.EnvironmentObservation> ComputeLatestEnvironmentObservationAsync()
        {
            return await Task.Run(() =>
            {
                IntPtr result_handle;
                Microsoft.Azure.ObjectAnchors.EnvironmentObservation result_object;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_compute_latest_environment_observation_async(this.handle, out result_handle));
                result_object = Microsoft.Azure.ObjectAnchors.EnvironmentObservation.GetOrCreateInstance(result_handle, transfer: true);
                return result_object;
            });
        }

        /// <summary>
        /// Computes the current environment observation in the region defined by <see cref="ObjectQuery.SearchAreas"/>.
        /// </summary>
        /// <param name="topology">
        /// Determines whether to compute triangle indices in addition to vertex positions and normals. Default is <see cref="EnvironmentObservationTopology.PointCloud"/>. Requesting <see cref="EnvironmentObservationTopology.TriangleList"/> from a query created with <see cref="ObjectObservationMode.Ambient"/> is not supported and will throw an exception.
        /// </param>
        public async System.Threading.Tasks.Task<Microsoft.Azure.ObjectAnchors.EnvironmentObservation> ComputeLatestEnvironmentObservationAsync(Microsoft.Azure.ObjectAnchors.EnvironmentObservationTopology topology)
        {
            return await Task.Run(() =>
            {
                IntPtr result_handle;
                Microsoft.Azure.ObjectAnchors.EnvironmentObservation result_object;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_query_compute_latest_environment_observation_async_environment_observation_topology_topology(this.handle, topology, out result_handle));
                result_object = Microsoft.Azure.ObjectAnchors.EnvironmentObservation.GetOrCreateInstance(result_handle, transfer: true);
                return result_object;
            });
        }

        ulong ICachedObject.Cookie => ProjectedObjectHelpers.ConvertHandleToCookie(this.handle);

        internal static Microsoft.Azure.ObjectAnchors.ObjectQuery GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ProjectedObjectHelpers.ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.Azure.ObjectAnchors.ObjectQuery GetOrCreateInstance(ulong cookie, bool transfer)
        {
            IntPtr handle = ProjectedObjectHelpers.ConvertCookieToHandle(cookie);
            return Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.ObjectAnchors.ObjectQuery>(
                cookie,
                _ => new Microsoft.Azure.ObjectAnchors.ObjectQuery(handle, transfer: transfer));
        }
    }

    /// <summary>
    /// Area where to look for object(s).
    /// </summary>
    public partial class ObjectSearchArea : ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected ObjectSearchArea(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_search_area_addref(ahandle);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="ObjectSearchArea"/> class.
        /// </summary>
        ~ObjectSearchArea()
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_search_area_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Creates a search area from a location.
        /// </summary>
        /// <param name="coordinateSystem">
        /// Reference coordinate system for the search area.
        /// </param>
        /// <param name="position">
        /// The position.
        /// </param>
        /// <param name="orientation">
        /// The orientation.
        /// </param>
        public static Microsoft.Azure.ObjectAnchors.ObjectSearchArea FromLocation(Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphCoordinateSystem coordinateSystem, System.Numerics.Vector3 position, System.Numerics.Quaternion orientation)
        {
            IntPtr result_handle;
            Microsoft.Azure.ObjectAnchors.ObjectSearchArea result_object;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_search_area_from_location(coordinateSystem, position, orientation, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? Microsoft.Azure.ObjectAnchors.ObjectSearchArea.GetOrCreateInstance(result_handle, transfer: true) : null;
            return result_object;
        }

        /// <summary>
        /// Creates a search area from a field of view.
        /// </summary>
        /// <param name="coordinateSystem">
        /// Reference coordinate system for the search area.
        /// </param>
        /// <param name="fieldOfView">
        /// The field of view.
        /// </param>
        public static Microsoft.Azure.ObjectAnchors.ObjectSearchArea FromFieldOfView(Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphCoordinateSystem coordinateSystem, Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialFieldOfView fieldOfView)
        {
            IntPtr result_handle;
            Microsoft.Azure.ObjectAnchors.ObjectSearchArea result_object;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_search_area_from_field_of_view(coordinateSystem, fieldOfView, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? Microsoft.Azure.ObjectAnchors.ObjectSearchArea.GetOrCreateInstance(result_handle, transfer: true) : null;
            return result_object;
        }

        /// <summary>
        /// Creates a search area from an oriented box.
        /// </summary>
        /// <param name="coordinateSystem">
        /// Reference coordinate system for the search area.
        /// </param>
        /// <param name="bounds">
        /// The bounds.
        /// </param>
        public static Microsoft.Azure.ObjectAnchors.ObjectSearchArea FromOrientedBox(Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphCoordinateSystem coordinateSystem, Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialOrientedBox bounds)
        {
            IntPtr result_handle;
            Microsoft.Azure.ObjectAnchors.ObjectSearchArea result_object;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_search_area_from_oriented_box(coordinateSystem, bounds, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? Microsoft.Azure.ObjectAnchors.ObjectSearchArea.GetOrCreateInstance(result_handle, transfer: true) : null;
            return result_object;
        }

        /// <summary>
        /// Creates a search area from a sphere.
        /// </summary>
        /// <param name="coordinateSystem">
        /// Reference coordinate system for the search area.
        /// </param>
        /// <param name="sphere">
        /// The sphere.
        /// </param>
        public static Microsoft.Azure.ObjectAnchors.ObjectSearchArea FromSphere(Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphCoordinateSystem coordinateSystem, Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialSphere sphere)
        {
            IntPtr result_handle;
            Microsoft.Azure.ObjectAnchors.ObjectSearchArea result_object;
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(Microsoft.Azure.ObjectAnchors.NativeLibrary.aoa_object_search_area_from_sphere(coordinateSystem, sphere, out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? Microsoft.Azure.ObjectAnchors.ObjectSearchArea.GetOrCreateInstance(result_handle, transfer: true) : null;
            return result_object;
        }

        ulong ICachedObject.Cookie => ProjectedObjectHelpers.ConvertHandleToCookie(this.handle);

        internal static Microsoft.Azure.ObjectAnchors.ObjectSearchArea GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ProjectedObjectHelpers.ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.Azure.ObjectAnchors.ObjectSearchArea GetOrCreateInstance(ulong cookie, bool transfer)
        {
            IntPtr handle = ProjectedObjectHelpers.ConvertCookieToHandle(cookie);
            return Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.ObjectAnchors.ObjectSearchArea>(
                cookie,
                _ => new Microsoft.Azure.ObjectAnchors.ObjectSearchArea(handle, transfer: transfer));
        }
    }

}

namespace Microsoft.Azure.ObjectAnchors.SpatialGraph
{
    internal static partial class NativeLibrary
    {
        internal const string DllName = "Microsoft.Azure.ObjectAnchors.dll";
    }

    /// <summary>
    /// Pose
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SpatialPose
    {
        /// <summary>
        /// The position of the pose.
        /// </summary>
        public System.Numerics.Vector3 Position;

        /// <summary>
        /// The orientation of the pose.
        /// </summary>
        public System.Numerics.Quaternion Orientation;

    }

    /// <summary>
    /// Coordinate system used in Object Anchors. It specifies a spatial graph node id and a relative pose from itself to the coordinate system of that spatial graph node.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SpatialGraphCoordinateSystem
    {
        /// <summary>
        /// Spatial graph node id.
        /// </summary>
        public System.Guid NodeId;

        /// <summary>
        /// Relative pose from this coordinate system to the coordinate frame of spatial graph node.
        /// </summary>
        public System.Numerics.Matrix4x4 CoordinateSystemToNodeTransform;

    }

    /// <summary>
    /// Sphere
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SpatialSphere
    {
        /// <summary>
        /// Center of the sphere.
        /// </summary>
        public System.Numerics.Vector3 Center;

        /// <summary>
        /// Radius of the sphere.
        /// </summary>
        public float Radius;

    }

    /// <summary>
    /// Oriented bounding box.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SpatialOrientedBox
    {
        /// <summary>
        /// Center.
        /// </summary>
        public System.Numerics.Vector3 Center;

        /// <summary>
        /// Edge-to-edge length along each dimension.
        /// </summary>
        public System.Numerics.Vector3 Extents;

        /// <summary>
        /// Orientation.
        /// </summary>
        public System.Numerics.Quaternion Orientation;

    }

    /// <summary>
    /// Oriented field of view.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SpatialFieldOfView
    {
        /// <summary>
        /// View's position.
        /// </summary>
        public System.Numerics.Vector3 Position;

        /// <summary>
        /// View's orientation.
        /// </summary>
        public System.Numerics.Quaternion Orientation;

        /// <summary>
        /// Far plane distance.
        /// </summary>
        public float FarDistance;

        /// <summary>
        /// Horizontal field of view in degrees.
        /// </summary>
        public float HorizontalFieldOfViewInDegrees;

        /// <summary>
        /// Aspect ratio between width and height dimensions.
        /// </summary>
        public float AspectRatio;

    }

    /// <summary>
    /// Location w.r.t a spatial graph node.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SpatialGraphLocation
    {
        /// <summary>
        /// Spatial graph node id.
        /// </summary>
        public System.Guid NodeId;

        /// <summary>
        /// Position in the coordinate frame of spatial graph node.
        /// </summary>
        public System.Numerics.Vector3 Position;

        /// <summary>
        /// Orientation in the coordinate frame of spatial graph node.
        /// </summary>
        public System.Numerics.Quaternion Orientation;

    }

}

namespace Microsoft.Azure.ObjectAnchors.Diagnostics
{
    internal static partial class NativeLibrary
    {
        internal const string DllName = "Microsoft.Azure.ObjectAnchors.dll";
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_diagnostics_session_addref(IntPtr handle);
        [DllImport(DllName, EntryPoint="aoa_object_diagnostics_session_close_async_wide", CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_diagnostics_session_close_async(IntPtr handle, [MarshalAs(UnmanagedType.LPWStr)] string diagnostics_file_path);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_diagnostics_session_create_object_observer_observer_uint32_max_session_size_in_mega_bytes(IntPtr observer, uint max_session_size_in_mega_bytes, out IntPtr instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_diagnostics_session_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_diagnostics_session_report_actual_instance_location(IntPtr handle, IntPtr instance, Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphCoordinateSystem coordinate_system, System.Numerics.Vector3 position, System.Numerics.Quaternion orientation);
        [DllImport(DllName, EntryPoint="aoa_object_diagnostics_session_upload_diagnostics_async_wide", CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.Azure.ObjectAnchors.status aoa_object_diagnostics_session_upload_diagnostics_async([MarshalAs(UnmanagedType.LPWStr)] string diagnostics_file_path, IntPtr object_anchors_session, out Microsoft.Azure.ObjectAnchors.Diagnostics.ObjectDiagnosticsUploadStatus result);
    }

    /// <summary>
    /// Status of diagnostics uploading task.
    /// </summary>
    public enum ObjectDiagnosticsUploadStatus : int
    {
        Succeeded = 0,
        Failed = 1,
        InvalidPackage = 2,
        EndpointNotFound = 3,
    }

    /// <summary>
    /// Diagnostics object that captures observer input, output and internal states.
    /// </summary>
    public partial class ObjectDiagnosticsSession : ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected ObjectDiagnosticsSession(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.Azure.ObjectAnchors.Diagnostics.NativeLibrary.aoa_object_diagnostics_session_addref(ahandle);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Creates a diagnostics session.
        /// </summary>
        /// <param name="observer">
        /// Object observer.
        /// </param>
        /// <param name="maxSessionSizeInMegaBytes">
        /// Maximum session size in megabytes.
        /// </param>
        public ObjectDiagnosticsSession(Microsoft.Azure.ObjectAnchors.ObjectObserver observer, uint maxSessionSizeInMegaBytes)
        {
            Microsoft.Azure.ObjectAnchors.status resultStatus = (Microsoft.Azure.ObjectAnchors.Diagnostics.NativeLibrary.aoa_object_diagnostics_session_create_object_observer_observer_uint32_max_session_size_in_mega_bytes(observer != null ? observer.handle : IntPtr.Zero, maxSessionSizeInMegaBytes, out this.handle));
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
            Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="ObjectDiagnosticsSession"/> class.
        /// </summary>
        ~ObjectDiagnosticsSession()
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.Diagnostics.NativeLibrary.aoa_object_diagnostics_session_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Report actual instance location provided by the application.
        /// </summary>
        /// <param name="instance">
        /// An instance being tracked within this session.
        /// </param>
        /// <param name="coordinateSystem">
        /// Reference coordinate system for the user provided instance location.
        /// </param>
        /// <param name="position">
        /// Instance position.
        /// </param>
        /// <param name="orientation">
        /// Instance orientation.
        /// </param>
        public void ReportActualInstanceLocation(Microsoft.Azure.ObjectAnchors.ObjectInstance instance, Microsoft.Azure.ObjectAnchors.SpatialGraph.SpatialGraphCoordinateSystem coordinateSystem, System.Numerics.Vector3 position, System.Numerics.Quaternion orientation)
        {
            Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.Diagnostics.NativeLibrary.aoa_object_diagnostics_session_report_actual_instance_location(this.handle, instance != null ? instance.handle : IntPtr.Zero, coordinateSystem, position, orientation));
        }

        /// <summary>
        /// Closes this session to stop collecting diagnostics. A closed session should be considered as dead thus its state is invalid.
        /// </summary>
        /// <param name="diagnosticsFilePath">
        /// File to store the diagnostics data.
        /// </param>
        public async System.Threading.Tasks.Task CloseAsync(string diagnosticsFilePath)
        {
            await Task.Run(() =>
            {
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.Azure.ObjectAnchors.Diagnostics.NativeLibrary.aoa_object_diagnostics_session_close_async(this.handle, diagnosticsFilePath));
            });
        }

        /// <summary>
        /// Uploads diagnostics to the Azure Object Anchors service and returns the job status. Throws exception on invalid diagnostics package or incorrect account credentials.
        /// </summary>
        /// <param name="diagnosticsFilePath">
        /// The diagnostics file path.
        /// </param>
        /// <param name="objectAnchorsSession">
        /// <see cref="ObjectAnchorsSession"/>The Azure Object Anchors session.
        /// </param>
        public static async System.Threading.Tasks.Task<Microsoft.Azure.ObjectAnchors.Diagnostics.ObjectDiagnosticsUploadStatus> UploadDiagnosticsAsync(string diagnosticsFilePath, Microsoft.Azure.ObjectAnchors.ObjectAnchorsSession objectAnchorsSession)
        {
            return await Task.Run(() =>
            {
                Microsoft.Azure.ObjectAnchors.Diagnostics.ObjectDiagnosticsUploadStatus result;
                Microsoft.Azure.ObjectAnchors.NativeLibraryHelpers.CheckStatus(Microsoft.Azure.ObjectAnchors.Diagnostics.NativeLibrary.aoa_object_diagnostics_session_upload_diagnostics_async(diagnosticsFilePath, objectAnchorsSession != null ? objectAnchorsSession.handle : IntPtr.Zero, out result));
                return result;
            });
        }

        ulong ICachedObject.Cookie => ProjectedObjectHelpers.ConvertHandleToCookie(this.handle);

        internal static Microsoft.Azure.ObjectAnchors.Diagnostics.ObjectDiagnosticsSession GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ProjectedObjectHelpers.ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.Azure.ObjectAnchors.Diagnostics.ObjectDiagnosticsSession GetOrCreateInstance(ulong cookie, bool transfer)
        {
            IntPtr handle = ProjectedObjectHelpers.ConvertCookieToHandle(cookie);
            return Microsoft.Azure.ObjectAnchors.ProjectedObjectCache.GetOrCreate<Microsoft.Azure.ObjectAnchors.Diagnostics.ObjectDiagnosticsSession>(
                cookie,
                _ => new Microsoft.Azure.ObjectAnchors.Diagnostics.ObjectDiagnosticsSession(handle, transfer: transfer));
        }
    }

}

#endif
